| Description   |                 |
|---------------|-----------------|
| keywords      |                 |
| dir-name      |                 |
| dir-name-en   |                 |
| tenant-type   | MySQL Mode      |

# pyobvector Python SDK 接口说明

pyobvector 是 OceanBase 向量存储功能的 python SDK，它提供两种使用模式：

* pymilvus 兼容模式：使用 MilvusLikeClient 对象操作数据库，提供与轻量级 MilvusClient 兼容的常用接口。

* SQLAlchemy 扩展模式：使用 ObVecClient 对象操作数据库，提供关系型数据库的 python SDK 扩展。

本文分别介绍了这两种模式下的使用接口与示例。

## MilvusLikeClient

### 构造函数

```python

def __init__(
    self,
    uri: str = "127.0.0.1:2881",
    user: str = "root@test",
    password: str = "",
    db_name: str = "test",
    **kwargs,
)
```

### collection 相关接口

| API 接口 | 参数描述 | 示例 |
|------|------|------|
| `def create_schema(self, **kwargs) -> CollectionSchema:` | <ul>构造一个 CollectionSchema 对象<li>可以不传参数，即初始化一个空的模式定义。</li><li>可选参数如下：</li><ul><li>fields：一个 FieldSchema 列表（详见下文 add_schema 接口）</li><li>partitions：分区规则（详见使用 ObPartition 定义分区规则章节）</li><li>description：与 Milvus 兼容用，在 OceanBase 中暂无实际作用</li></ul> |  |
| <pre><code>def create_collection(<br/>self,<br/>collection_name: str,<br/>dimension: Optional[int] = None,<br/>primary_field_name: str = "id",<br/>id_type: Union[DataType, str] = DataType.INT64,<br/>vector_field_name: str = "vector",<br/>metric_type: str = "l2",<br/>auto_id: bool = False,<br/>timeout: Optional[float] = None,<br/>schema: Optional[CollectionSchema] = None,  # Used for custom setup<br/>index_params: Optional[IndexParams] = None,  # Used for custom setup<br/>max_length: int = 16384,<br/>**kwargs,<br/>)</code></pre> | 创建一个表：<ul><li>collection_name : 表名称</li><li>dimension : 向量数据维度</li><li>primary_field_name: 主字段名称</li><li>id_type: 主字段数据类型(仅支持 VARCHAR 和 INT 类型)</li><li>vector_field_name : 向量字段名称</li><li>metric_type: OceanBase 中未使用，但保持接口兼容 (因为主表定义不需要指定向量距离函数)</li><li>auto_id：主字段是否自动递增</li><li>timeout : OceanBase 中未使用，但保持接口兼容</li><li>schema : 自定义集合架构，当 `schema` 不为 None 时上面从 dimension 到 metric_type 的参数将被忽略</li><li>index_params: 自定义向量索引参数</li><li>max_length: 当主字段数据类型为 VARCHAR 且 `schema` 不为 None 时最大 varchar 长度为 `max_length`</li></ul> | <pre><code>client.create_collection(<br/>collection_name=test_collection_name,<br/>schema=schema,<br/>index_params=idx_params,<br/>)</code></pre> |
| <pre><code>def get_collection_stats(<br/>self, collection_name: str, timeout: Optional[float] = None # pylint: disable=unused-argument<br/>) -> Dict:</code></pre> | 获取表的记录数量<ul><li>collection_name：表名称</li><li>timeout : OceanBase 中未使用，但保持接口兼容</li></ul> |  |
| <pre><code>def has_collection(self, collection_name: str, timeout: Optional[float] = None) -> bool</code></pre> | 判断表是否存在<ul><li>collection_name：表名称</li><li>timeout : OceanBase 中未使用，但保持接口兼容</li></ul> |  |
| <pre><code>def drop_collection(self, collection_name: str) -> None</code></pre> | 重命名表<ul><li>old_name：表的原名</li><li>new_name：新表名</li></ul> |  |
| <pre><code>def load_table(self, collection_name: str,)</code></pre> | 读取表元数据到 SQLAlchemy 元数据缓存<ul><li>collection_name：表名称</li></ul> |  |

### CollectionSchema & FieldSchema

MilvusLikeClient 通过 CollectionSchema 描述一个表的模式定义，一个 CollectionSchema 包含多个 FieldSchema， FieldSchema 描述一个表的列模式。

#### 通过 MilvusLikeClient 的 create_schema 创建 CollectionSchema

```python
def __init__(
    self,
    fields: Optional[List[FieldSchema]] = None,
    partitions: Optional[ObPartition] = None,
    description: str = "",  # ignored in oceanbase
    **kwargs,
)
```

参数说明如下：

* fields：一组可选的 FieldSchema。

* partitions：分区规则（详见使用 ObPartition 定义分区规则章节）。

* description：与 Milvus 兼容用，在 OceanBase 中暂无实际作用。

#### 创建 FieldSchema 并注册到 CollectionSchema

```python
def add_field(self, field_name: str, datatype: DataType, **kwargs)
```

* field_name：列名称。

* datatype：列数据类型（支持的数据类型请参见[兼容性说明](../800.ob-vector-sdk-refer.md)）。

* kwargs：其他参数用于配置列属性，如下：

    ```python
    def __init__(
    self,
    name: str,
    dtype: DataType,
    description: str = "",
    is_primary: bool = False,
    auto_id: bool = False,
    nullable: bool = False,
    **kwargs,
    )
    ```

    参数说明如下：

    * is_primary：是否是主键。

    * auto_id：是否是自增列。

    * nullable：是否允许为空。

#### 使用示例

```python
schema = self.client.create_schema()
schema.add_field(field_name="id", datatype=DataType.INT64, is_primary=True)
schema.add_field(field_name="title", datatype=DataType.VARCHAR, max_length=512)
schema.add_field(
    field_name="title_vector", datatype=DataType.FLOAT_VECTOR, dim=768
)
schema.add_field(field_name="link", datatype=DataType.VARCHAR, max_length=512)
schema.add_field(field_name="reading_time", datatype=DataType.INT64)
schema.add_field(
    field_name="publication", datatype=DataType.VARCHAR, max_length=512
)
schema.add_field(field_name="claps", datatype=DataType.INT64)
schema.add_field(field_name="responses", datatype=DataType.INT64)

self.client.create_collection(
    collection_name="medium_articles_2020", schema=schema
)
```

### 索引相关

| API 接口 | 参数描述 | 示例或备注 |
|-----|-----|-----|
| <pre><code>def create_index(<br/>self,<br/>collection_name: str,<br/>index_params: IndexParams,<br/>timeout: Optional[float] = None,<br/>**kwargs,<br/>)</code></pre> | 根据已构造的 IndexParams 创建向量索引表（此接口关于 IndexParams 的使用详见 prepare_index_params 和 add_index 接口）<ul><li>collection_name：表名称</li><li>index_params：索引参数</li><li>timeout：OceanBase 中未使用，但保持接口兼容</li><li>kwargs：其他参数，目前未使用，保持兼容</li></ul> |  |
| <pre><code>def drop_index(<br/>self,<br/>collection_name: str,<br/>index_name: str,<br/>timeout: Optional[float] = None,<br/>**kwargs,<br/>)</code></pre> | 删除索引表<ul><li>collection_name：表名称</li><li>index_name：索引名</li></ul> |  |
| <pre><code>def refresh_index(<br/>self,<br/>collection_name: str,<br/>index_name: str,<br/>trigger_threshold: int = 10000,<br/>)</code></pre> | 刷新向量索引表以提升读取性能，可以理解为对增量数据的搬迁<ul><li>collection_name：表名称</li><li>index_name：索引名</li><li>trigger_threshold：刷新动作的触发阈值，如果索引表数据量超过该阈值，则进行刷新</li></ul> | OceanBase 额外引入的接口<br/>非 Milvus 兼容 |
| <pre><code>def rebuild_index(<br/>self,<br/>collection_name: str,<br/>index_name: str,<br/>trigger_threshold: float = 0.2,<br/>)</code></pre> | 重建向量索引表以提升读取性能，可以理解为将增量数据合并入基线索引数据<ul><li>collection_name：表名称</li><li>index_name：索引名</li><li>trigger_threshold：重建动作的触发阈值，值域 0 到 1，增量数据占全量数据比例达到该阈值时触发重建</li></ul> | OceanBase 额外引入的接口<br/>非 Milvus 兼容 |
| <pre><code>def search(<br/>self,<br/>collection_name: str,<br/>data: list,<br/>anns_field: str,<br/>with_dist: bool = False,<br/>filter=None,limit: int = 10,output_fields: Optional[List[str]] = None,<br/>search_params: Optional[dict] = None,<br/>timeout: Optional[float] = None,<br/>partition_names: Optional[List[str]] = None,<br/>**kwargs,<br/>) -> List[dict]</code></pre> | 执行向量近似邻近搜索<ul><li>collection_name：表名称</li><li>data：需要搜索的向量数据</li><li>anns_field: 需要搜索的向量列名</li><li>with_dist: 是否返回带向量距离的结果</li><li>filter : 使用带过滤条件的向量近似邻近搜索</li><li>limit ：top K</li><li>output_fields: 输出列（或称为投影列）</li><li>search_params : 仅支持值为 `l2`/`neg_ip` 的 `metric_type`（例如：search_params = {"metric_type": "neg_ip"} ）</li><li>timeout : OceanBase 中未使用，仅兼容作用</li><li>partition_names : 将查询限制在某些分区</li></ul><ul>返回值：<br/>记录列表，每条记录都是一个字典<br/>表示从 column_name 到列值的映射。</ul> | <pre><code>res = self.client.search(<br/>collection_name=test_collection_name,<br/>data=[0, 0, 1],<br/>anns_field="embedding",<br/>limit=5,<br/>output_fields=["id"],<br/>search_params={"metric_type": "neg_ip"}<br/>)<br/>self.assertEqual(<br/> set([r['id'] for r in res]), set([12, 111, 11, 112, 10])) |
| <pre><code>def query(<br/>self,<br/>collection_name: str,<br/>flter=None,<br/>output_fields: Optional[List[str]] = None,<br/>timeout: Optional[float] = None,<br/>partition_names: Optional[List[str]] = None,<br/>**kwargs,<br/>) -> List[dict]</code></pre> | 使用指定过滤条件读取数据记录<ul><li>collection_name：表名称</li><li>flter : 使用带过滤条件的向量近似邻近搜索</li><li>output_fields: 输出列（或称为投影列）</li><li>timeout : OceanBase 中未使用，仅兼容作用</li><li>partition_names : 将查询限制在某些分区</li></ul><ul>返回值：<br/>记录列表，每条记录都是一个字典<br/>表示从 column_name 到列值的映射。</ul> | <pre><code>table = self.client.load_table(collection_name=test_collection_name)<br/>where_clause = [table.c["id"] < 100]<br/>res = self.client.query(<br/>  collection_name=test_collection_name,<br/>  output_fields=["id"],<br/>  flter=where_clause,<br/>) |
| <pre><code>def get(<br/>self,<br/>collection_name: str,<br/>ids: Union[list, str, int],<br/>output_fields: Optional[List[str]] = None,<br/>timeout: Optional[float] = None,<br/>partition_names: Optional[List[str]] = None,<br/>**kwargs,<br/>) -> List[dict]</code></pre> | 获取指定主键 `ids` 的记录：<ul><li>collection_name：表名称</li><li>ids：某个 id 或者一组 id 列表。注意：MilvusLikeClient get 接口的 ids 参数和 ObVecClient 的 get 不同，详见 <a href="#DML%20操作">ObVecClient get</a></li><li>output_fields: 输出列（或称为投影列）</li><li>timeout : OceanBase 中未使用，仅兼容作用</li><li>partition_names : 将查询限制在某些分区</li></ul>返回值：<br/>记录列表，每条记录都是一个字典<br/>表示从 column_name 到列值的映射。 | <pre><code>res = self.client.get(<br/>  collection_name=test_collection_name,<br/>  output_fields=["id", "meta"],<br/>  ids=[80, 12, 112],<br/>) |
| <pre><code>def delete(<br/>self,<br/>collection_name: str,<br/>ids: Optional[Union[list, str, int]] = None,<br/>timeout: Optional[float] = None, # pylint: disable=unused-argument<br/>flter=None,<br/>partition_name: Optional[str] = "",<br/>**kwargs, # pylint: disable=unused-argument<br/>)</code></pre> | 删除集合中的数据<ul><li>collection_name：表名称</li><li>ids：某个 id 或者一组 id 列表</li><li>timeout : OceanBase 中未使用，仅兼容作用</li><li>flter : 使用带过滤条件的向量近似邻近搜索</li><li>partition_name : 将删除操作限制在某个分区</li></ul> | <pre><code>self.client.delete(<br/>    collection_name=test_collection_name, ids=[12, 112], partition_name="p0"<br/>)</code></pre> |
| <pre><code>def insert(<br/>  self, <br/>  collection_name: str, <br/>  data: Union[Dict, List[Dict]], <br/>  timeout: Optional[float] = None, <br/>  partition_name: Optional[str] = ""<br/>)</code></pre> | 向表中插入数据<ul><li>collection_name：表名称</li><li>data：以 Key-Value 形式描述的待插入数据</li><li>timeout : OceanBase 中未使用，仅兼容作用</li><li>partition_name : 将插入操作限制在某个分区</li></ul> | <pre><code>data = [<br/>    {"id": 12, "embedding": [1, 2, 3], "meta": {"doc": "oceanbase document 1"}},<br/>    {<br/>        "id": 90,<br/>        "embedding": [0.13, 0.123, 1.213],<br/>        "meta": {"doc": "oceanbase document 1"},<br/>    },<br/>    {"id": 112, "embedding": [1, 2, 3], "meta": None},<br/>    {"id": 190, "embedding": [0.13, 0.123, 1.213], "meta": None},<br/>]<br/>self.client.insert(collection_name=test_collection_name, data=data)</code></pre> |
| <pre><code>def upsert(<br/>self,<br/>collection_name: str,<br/>data: Union[Dict, List[Dict]],<br/>timeout: Optional[float] = None, # pylint: disable=unused-argument<br/>partition_name: Optional[str] = "",<br/>) -> List[Union[str, int]]</code></pre> | 更新表中的数据。如果主键已存在，则更新对应记录；否则，插入新记录。<ul><li>collection_name：表名称</li><li>data：待插入或更新的数据，格式与 insert 接口一致</li><li>timeout : OceanBase 中未使用，仅兼容作用</li><li>partition_name : 将操作限制在指定分区</li></ul> | <pre><code>data = [<br/>    {"id": 112, "embedding": [1, 2, 3], "meta": {'doc':'hhh1'}},<br/>    {"id": 190, "embedding": [0.13, 0.123, 1.213], "meta": {'doc':'hhh2'}},<br/>]<br/>self.client.upsert(collection_name=test_collection_name, data=data)</code></pre> |
| <pre><code>def perform_raw_text_sql(self, text_sql: str):<br/>    return super().perform_raw_text_sql(text_sql)</code></pre> | 直接执行 SQL 语句<ul><li>text_sql: 待执行的 SQL</li></ul>返回值：<br/>返回 SQLAlchemy 提供的结果集合迭代器 |  |

## ObVecClient

### 构造函数

```python
def __init__(
    self,
    uri: str = "127.0.0.1:2881",
    user: str = "root@test",
    password: str = "",
    db_name: str = "test",
    **kwargs,
)
```

### 表模式相关操作

| API 接口 | 参数描述 | 示例或备注 |
|-----|-----|-----|
| <pre><code>def check_table_exists(self, table_name: str)</code></pre> | 检查表是否存在<ul><li>table_name：表名称</li></ul> |  |
| <pre><code>def create_table(<br/>self,<br/>table_name: str,<br/>columns: List[Column],<br/>indexes: Optional[List[Index]] = None,<br/>partitions: Optional[ObPartition] = None,<br/>)</code></pre> | 创建表<ul><li>table_name：表名称</li><li>columns：使用 SQLAlchemy 定义的的表的列模式</li><li>indexes：使用 SQLAlchemy 定义的一组索引表模式</li><li>partitions：可选的分区规则（详见使用 ObPartition 定义分区规则小节）</li></ul> |  |
| <pre><code>@classmethod<br/>def prepare_index_params(cls)</code></pre> | 创建一个 IndexParams 对象来记录向量索引表的模式定义<pre><code>class IndexParams:<br/>    """Vector index parameters for MilvusLikeClient"<br/>    def __init__(self):<br/>        self._indexes = {}</code></pre>IndexParams 的定义非常简单，内部只有一个字典类型的成员<br/>存放了 (列名，索引名) 的 tuple 到 IndexParam 结构的映射<br/>IndexParam 类的构造函数为<pre><code>def __init__(<br/>    self,<br/>    index_name: str,<br/>    field_name: str,<br/>    index_type: Union[VecIndexType, str],<br/>    **kwargs<br/>)</code></pre><ul><li>index_name：向量索引表名</li><li>field_name：向量列名</li><li>index_type：向量索引算法类型的一个枚举类，目前仅支持 HNSW</li></ul>通过 `prepare_index_params` 获得一个 IndexParams 后，可以通过 `add_index` 接口来注册 IndexParam：<pre><code>def add_index(<br/>    self,<br/>    field_name: str,<br/>    index_type: VecIndexType,<br/>    index_name: str,<br/>    **kwargs<br/>)</code></pre>参数含义通 IndexParam 的构造函数 | 给出一个创建向量索引的使用案例：<pre><code>idx_params = self.client.prepare_index_params()<br/>idx_params.add_index(<br/>    field_name="title_vector",<br/>    index_type="HNSW",<br/>    index_name="vidx_title_vector",<br/>    metric_type="L2",<br/>    params={"M": 16, "efConstruction": 256},<br/>)<br/>self.client.create_collection(<br/>    collection_name=test_collection_name,<br/>    schema=schema,<br/>   <br/>index_params=idx_params,<br/>)</code></pre>需要注意的是 `prepare_index_params` 函数建议在 MilvusLikeClient 下使用，不建议在 ObVecClient 中使用，ObVecClient 模式下应使用 `create_index` 接口来定义向量索引表。（详见 create_index 接口） |
| <pre><code>def create_table_with_index_params(<br/>self,<br/>table_name: str,<br/>columns: List[Column],<br/>indexes: Optional[List[Index]] = None,<br/>vidxs: Optional[IndexParams] = None,<br/>partitions: Optional[ObPartition] = None,<br/>) | 使用可选的 index_params 在创建表的同时创建向量索引<ul><li>table_name：表名称</li><li>columns：使用 SQLAlchemy 定义的的表的列模式</li><li>indexes：使用 SQLAlchemy 定义的一组索引表模式</li><li>vidxs：通过 IndexParams 指定的向量索引表模式</li><li>partitions：可选的分区规则（详见使用 ObPartition 定义分区规则章节）</li></ul> | 建议在 MilvusLikeClient 下使用，不建议在 ObVecClient 中使用 |
| <pre><code>def create_index(<br/>self,<br/>table_name: str,<br/>is_vec_index: bool,<br/>index_name: str,<br/>column_names: List[str],<br/>vidx_params: Optional[str] = None,<br/>**kw,<br/>)</code></pre> | 支持创建普通索引和向量索引两种模式<ul><li>table_name：表名称</li><li>is_vec_index：是索引或是向量索引</li><li>index_name：索引名称</li><li>column_names ：在哪些列上创建索引</li><li>vidx_params：向量索引参数，例如`“distance=l2, type=hnsw, lib=vsag”`</li></ul>目前 OceanBase 仅支持 `type=hnsw` 以及 `lib=vsag` 请保留这两个的设置，distance 可以设置为 `l2` 或者 `inner_product` | <pre><code>self.client.create_index(<br/>    test_collection_name,<br/>    is_vec_index=True,<br/>    index_name="vidx",<br/>    column_names=["embedding"],<br/>    vidx_params="distance=l2, type=hnsw, lib=vsag",<br/>) |
| <pre><code>def create_vidx_with_vec_index_param(<br/>self,<br/>table_name: str,<br/>vidx_param: IndexParam,<br/>)</code></pre> | 使用向量索引参数创建向量索引<ul><li>table_name：表名称</li><li>vidx_param：IndexParam 构造的向量索引参数</li></ul> |  |
| <pre><code>def drop_table_if_exist(self, table_name: str)</code></pre> | 删除表<ul><li>table_name：表名称</li></ul> |  |
| <pre><code>def drop_index(self, table_name: str, index_name: str)</code></pre> | 删除索引<ul><li>table_name：表名称</li><li>index_name：索引名称</li></ul> |  |
| <pre><code>def refresh_index(<br/>self,<br/>table_name: str,<br/>index_name: str,<br/>trigger_threshold: int = 10000,<br/>)</code></pre> | 刷新向量索引表以提升读取性能，可以理解为对增量数据的搬迁<ul><li>table_name：表名称</li><li>index_name：索引名称</li><li>trigger_threshold：刷新动作的触发阈值，如果索引表数据量超过该阈值，则进行刷新</li></ul> |  |
| <pre><code>def rebuild_index(<br/>self,<br/>table_name: str,<br/>index_name: str,<br/>trigger_threshold: float = 0.2,<br/>)</code></pre> | 重建向量索引表以提升读取性能，可以理解为将增量数据合并入基线索引数据<ul><li>table_name：表名称</li><li>index_name：索引名称</li><li>trigger_threshold：重建动作的触发阈值，值域 0 到 1，增量数据占全量数据比例达到该阈值时触发重建</li></ul> |  |

### DML 操作

| API 接口 | 参数描述 | 示例或备注 |
|-----|-----|-----|
| <pre><code>def insert(<br/>self,<br/>table_name: str,<br/>data: Union[Dict, List[Dict]],<br/>partition_name: Optional[str] = "",<br/>)</code></pre> | 向表中插入数据<ul><li>table_name：表名称</li><li>data：以 Key-Value 形式描述的待插入数据</li><li>partition_name：将插入操作限制在某个分区</li></ul> | <pre><code>vector_value1 = [0.748479, 0.276979, 0.555195]<br/>vector_value2 = [0, 0, 0]<br/>data1 = [{"id": i, "embedding": vector_value1} for i in range(10)]<br/>data1.extend([{"id": i, "embedding": vector_value2} for i in range(10, 13)])<br/>data1.extend([{"id": i, "embedding": vector_value2} for i in range(111, 113)])<br/>self.client.insert(test_collection_name, data=data1)</code></pre> |
| <pre><code>def upsert(<br/>self,<br/>table_name: str,<br/>data: Union[Dict, List[Dict]],<br/>partition_name: Optional[str] = "",<br/>)</code></pre> | 插入或更新表中的数据。如果主键已存在，则更新对应记录；否则，插入新记录。<ul><li>table_name：表名称</li><li>data：待插入或更新的数据，Key-Value 格式</li><li>partition_name：将操作限制在指定分区</li></ul> |  |
| <pre><code>def update(<br/>self,<br/>table_name: str,<br/>values_clause,<br/>where_clause=None,<br/>partition_name: Optional[str] = "",<br/>)</code></pre> | 更新表中的数据。如果主键重复，则替换它。<ul><li>table_name：表名称</li><li>values_clause：更新列的值</li><li>where_clause：更新条件</li><li>partition_name：将更新操作限制在某些分区</li></ul> | <pre><code>data = [<br/>    {"id": 112, "embedding": [1, 2, 3], "meta": {'doc':'hhh1'}},<br/>    {"id": 190, "embedding": [0.13, 0.123, 1.213], "meta": {'doc':'hhh2'}},<br/>]<br/>client.insert(collection_name=test_collection_name, data=data)<br/>client.update(<br/>    table_name=test_collection_name,<br/>    values_clause=[{'meta':{'doc':'HHH'}}],<br/>    where_clause=[text("id=112")]<br/>) |
| <pre><code>def delete(<br/>self,<br/>table_name: str,<br/>ids: Optional[Union[list, str, int]] = None,<br/>where_clause=None,<br/>partition_name: Optional[str] = "",<br/>)</code></pre> | 删除表中的数据<ul><li>table_name：表名称</li><li>ids：某个 id 或者一组 id 列表</li><li>where_clause：删除条件</li><li>partition_name：将删除操作限制在某些分区</li></ul> | <pre><code>self.client.delete(test_collection_name, ids=["bcd", "def"])</code></pre> |
| <pre><code>def get(<br/>self,<br/>table_name: str,<br/>ids: Optional[Union[list, str, int]],<br/>where_clause = None,<br/>output_column_name: Optional[List[str]] = None,<br/>partition_names: Optional[List[str]] = None,<br/>)</code></pre> | 获取指定主键 `ids` 的记录。<ul><li>table_name：表名称</li><li>ids：某个 id 或者一组 id 列表。可选参数，没有可填 `ids=None`。ObVecClient get 接口的 ids 参数和 MilvusLikeClient 的 get 不同，详见 <a href="#索引相关">MilvusLikeClient get</a></li><li>where_clause：获取条件</li><li>output_column_name：一组输出列或者投影列名称</li><li>partition_names：将获取操作限制在某些分区</li></ul>返回值：<br/>不同于 MilvusLikeClient，ObVecClient 的返回值为一个 tuple list，每个 tuple 代表一行记录 | <pre><code>res = self.client.get(<br/>    test_collection_name,<br/>    ids=["abc", "bcd", "cde", "def"],<br/>    where_clause=[text("meta->'$.page' > 1")],<br/>    output_column_name=['id']<br/>) |
| <pre><code>def set_ob_hnsw_ef_search(self, ob_hnsw_ef_search: int)</code></pre> | 设置 HNSW 索引的 efSearch 参数。session 级别变量设置，ef_search 越大召回率越高，但是查询性能有所下降。<ul><li>ob_hnsw_ef_search：HNSW 索引的 efSearch 参数</li></ul> |  |
| <pre><code>def get_ob_hnsw_ef_search(self) -> int</code></pre> | 获取 HNSW 索引的 efSearch 参数 |  |
| <pre><code>def ann_search(<br/>self,<br/>table_name: str,<br/>vec_data: list,<br/>vec_column_name: str,<br/>distance_func,<br/>with_dist: bool = False,<br/>topk: int = 10,<br/>output_column_names: Optional[List[str]] = None,<br/>extra_output_cols: Optional[List] = None,<br/>where_clause=None,<br/>partition_names: Optional[List[str]] = None,<br/>**kwargs,<br/>)</code></pre> | 执行向量近似邻近搜索<ul><li>table_name：表名称</li><li>vec_data：需要搜索的向量数据</li><li>vec_column_name：需要搜索的向量列名</li><li>distance_func：距离函数。提供了 SQLAlchemy func 的扩展，可选值有 `func.l2_distance`/`func.cosine_distance`/`func.inner_product`/`func.negative_inner_product`，分别表示 l2 距离函数、cosine 距离函数、内积距离函数、内积距离的负值</li><li>with_dist：是否返回带向量距离的结果</li><li>topk：取最近多少个向量</li><li>output_column_names：一组输出列或者投影列名称</li><li>extra_output_cols：额外输出列，可以提供更复杂的输出表达式</li><li>where_clause：过滤条件</li><li>partition_names：将查询限制在某些分区</li></ul>返回值：<br/>不同于 MilvusLikeClient，ObVecClient 的返回值为一个 tuple list，每个 tuple 代表一行记录 | <pre><code>res = self.client.ann_search(<br/>    test_collection_name,<br/>    vec_data=[0, 0, 0],<br/>    vec_column_name="embedding",<br/>    distance_func=func.l2_distance,<br/>    with_dist=True,<br/>    topk=5,<br/>    output_column_names=["id"],<br/>) |
| <pre><code>def precise_search(<br/>self,<br/>table_name: str,<br/>vec_data: list,<br/>vec_column_name: str,<br/>distance_func,<br/>topk: int = 10,<br/>output_column_names: Optional[List[str]] = None,<br/>where_clause=None,<br/>**kwargs,<br/>) | 执行精确邻近搜索算法<ul><li>table_name：表名称</li><li>vec_data：查询的向量</li><li>vec_column_name：向量列名</li><li>distance_func：向量距离函数，提供了 SQLAlchemy func 的扩展，可选值有 func.l2_distance/func.cosine_distance/func.inner_product/func.negative_inner_product，分别表示 l2 距离函数、cosine 距离函数、内积距离函数、内积距离的负值</li><li>topk：取最近多少个向量</li><li>output_column_names：一组输出列或者投影列名称</li><li>where_clause：过滤条件</li></ul>返回值：<br/>不同于 MilvusLikeClient，ObVecClient 的返回值为一个 tuple list，每个 tuple 代表一行记录 |  |
| <pre><code>def perform_raw_text_sql(self, text_sql: str)</code></pre> | 直接执行 SQL 语句<ul><li>text_sql: 待执行的 SQL</li></ul>返回值：<br/>返回 SQLAlchemy 提供的结果集合迭代器 |  |

## 使用 ObPartition 定义分区规则

pyobvector 提供了以下类型来支持  range/range columns、list/list columns、hash、key 以及二级分区：

* ObRangePartition：range 一级分区。构造时设置 `is_range_columns = True` 以创建 range columns 分区。

* ObListPartition：list 一级分区。构造时设置 `is_list_columns = True` 以创建 list columns 分区。

* ObHashPartition：hash 一级分区。

* ObKeyPartition：key 一级分区。

* ObSubRangePartition：二级 range 分区。构造时设置 `is_range_columns = True` 以创建 range columns 二级分区。

* ObSubListPartition：list 二级分区。构造时设置 `is_list_columns = True` 以创建 list columns 二级分区。

* ObSubHashPartition：hash 二级分区。

* ObSubKeyPartition：key 二级分区。

### range 分区示例

```python
range_part = ObRangePartition(
    False,
    range_part_infos=[
        RangeListPartInfo("p0", 100),
        RangeListPartInfo("p1", "maxvalue"),
    ],
    range_expr="id",
)
```

### list 分区示例

```python
list_part = ObListPartition(
    False,
    list_part_infos=[
        RangeListPartInfo("p0", [1, 2, 3]),
        RangeListPartInfo("p1", [5, 6]),
        RangeListPartInfo("p2", "DEFAULT"),
    ],
    list_expr="col1",
)
```

### hash 分区示例

```python
hash_part = ObHashPartition("col1", part_count=60)
```

### 多级分区示例

```python
# 一级range分区
range_columns_part = ObRangePartition(
    True,
    range_part_infos=[
        RangeListPartInfo("p0", 100),
        RangeListPartInfo("p1", 200),
        RangeListPartInfo("p2", 300),
    ],
    col_name_list=["col1"],
)
# 二级range分区
range_sub_part = ObSubRangePartition(
    False,
    range_part_infos=[
        RangeListPartInfo("mp0", 1000),
        RangeListPartInfo("mp1", 2000),
        RangeListPartInfo("mp2", 3000),
    ],
    range_expr="col3",
)
range_columns_part.add_subpartition(range_sub_part)
```

## 纯 SQLAlchemy API 模式

如果你希望在 OceanBase 数据库的向量搜索功能下使用纯粹的 SQLAlchemy API，可以通过如下两种方式获取同步的数据库引擎：

* 方式一：使用 ObVecClient 辅助创建数据库引擎

```python
from pyobvector import ObVecClient

client = ObVecClient(uri="127.0.0.1:2881", user="test@test")
engine = client.engine
# 接下来正常使用 SQLAlchemy 创建 session，使用 SQLAlchemy 的 API 即可
```

* 方式二：使用 ObVecClient 的 `create_engine` 接口创建数据库引擎

```python
import pyobvector
from sqlalchemy.dialects import registry
from sqlalchemy import create_engine

uri: str = "127.0.0.1:2881"
user: str = "root@test"
password: str = ""
db_name: str = "test"
registry.register("mysql.oceanbase", "pyobvector.schema.dialect", "OceanBaseDialect")
connection_str = (
    # mysql+oceanbase 表示选择 mysql 标准并使用 OceanBase 数据库的同步驱动
    f"mysql+oceanbase://{user}:{password}@{uri}/{db_name}?charset=utf8mb4"
)
engine = create_engine(connection_str, **kwargs)
# 接下来正常使用 SQLAlchemy 创建 session，使用 SQLAlchemy 的 API 即可
```

如果期望使用 SQLAlchemy 的异步接口，可以使用 OceanBase 数据库的异步驱动：

```python
import pyobvector
from sqlalchemy.dialects import registry
from sqlalchemy.ext.asyncio import create_async_engine

uri: str = "127.0.0.1:2881"
user: str = "root@test"
password: str = ""
db_name: str = "test"
registry.register("mysql.aoceanbase", "pyobvector", "AsyncOceanBaseDialect")
connection_str = (
    # mysql+aoceanbase 表示选择 mysql 标准并使用 OceanBase 数据库的异步驱动
    f"mysql+aoceanbase://{user}:{password}@{uri}/{db_name}?charset=utf8mb4"
)
engine = create_async_engine(connection_str)
# 接下来正常使用 SQLAlchemy 创建 session，使用 SQLAlchemy 的 API 即可
```

## 更多示例

访问 [pyobvector 代码仓库](https://github.com/oceanbase/pyobvector) 获取更多示例。