| Description   |                 |
|---------------|-----------------|
| keywords      |                 |
| dir-name      |                 |
| dir-name-en   |                 |
| tenant-type   | MySQL Mode      |

# 创建向量索引

本文介绍了 OceanBase 如何创建、搜索、维护和删除向量索引。

<main id="notice" type='notice'>
  <h4>注意</h4>
  <p><li>IVF/IVF_PQ 索引从 V4.3.5 BP1 版本开始支持。</li><li>HNSW_BQ 索引从 V4.3.5 BP2 版本开始支持。</li></p>
</main>

## 索引类型

OceanBase 支持的向量索引类型及其具体说明如下：

| 索引类型 | 描述 | 适用场景 |
|-----------|------|----------|
| HNSW      | 索引列最大维度为 4096。HNSW 索引是内存索引，需要完整载入内存。 |  |
| HNSW_SQ   | HNSW_SQ 索引提供了和 HNSW 索引相近的构建速度，搜索性能，召回率，但总的内存使用降低到原本的 1/2～1/3。 | 对性能和召回率有较高要求的场景。 |
| HNSW_BQ   | HNSW_BQ 索引的召回率略低于 HNSW 索引，但显著减少了内存占用。BQ 量化压缩算法（Rabitq）能将向量压缩至原大小的 1/32，随着向量维度增加，HNSW_BQ 索引的内存优化效果更明显。 |  |
| IVF| 基于数据库表实现的 IVF 索引，可不占用常驻内存。 | 对性能要求不高，但数据量较大，成本敏感的场景。 |
| IVF_PQ| 基于数据库表实现的 IVF_PQ 索引，可不占用常驻内存。在 IVF 基础上应用了 PQ 量化技术，索引的召回率略低于 IVF 索引，性能高于 IVF 索引，同时 PQ 量化压缩算法普遍场景下能将向量压缩至原大小的 1/16 ~ 1/32。 | 对性能要求不高，但数据量较大，成本敏感的场景。 |

一些其他说明：

* 稠密向量索引支持 L2、内积（IP）、余弦距离作为索引距离算法。
* 向量索引搜索支持调用部分距离函数，具体请参见 [使用 SQL 函数](250.ob-vector-function.md)。
* 支持带有过滤条件的向量搜索。过滤条件可以是标量类型的条件，可以是空间关系，如 ST_Intersects 等。暂不支持多值索引/全文索引/全局索引作为预过滤器。
* 支持同表创建向量索引和全文索引。
* 向量索引对 Offline DDL 的支持情况请见[Offline DDL](../700.reference/500.sql-reference/100.sql-syntax/200.common-tenant-of-mysql-mode/700.ddl-function-of-mysql-mode/150.online-and-offline-ddl-list-of-mysql-mode.md)。
* 向量索引搜索从 V4.3.5 BP4 版本开始支持弱读（Weak Read），允许读取本地机房的副本数据，而非强制跨区访问主库。

限制如下：

* 对于 V4.3.5 BP3 版本，暂不支持创建列存向量索引。

## 配置向量索引内存

OceanBase 向量搜索通过设置 [ob_vector_memory_limit_percentage](../700.reference/800.configuration-items-and-system-variables/100.system-configuration-items/400.tenant-level-configuration-items/6150.ob_vector_memory_limit_percentage.md) 配置向量索引内存：

* **V4.3.5 BP3 版本之前，使用 HNSW/HNSW_SQ/HNSW_BQ 向量索引前**，需要手动设置 `ob_vector_memory_limit_percentage` 开启向量功能，建议设置为 `30`，以获得最佳的搜索性能。如保持默认值，则表示不为向量索引分配内存，创建索引会报错。IVF/IVF_PQ 索引不需要常驻内存，所以无需关注此参数。配置示例如下：
    ```sql
    ALTER SYSTEM SET ob_vector_memory_limit_percentage = 30;
    ```

* **从 V4.3.5 BP3 版本开始**，向量搜索功能默认启用。默认值为 `0` 表示自适应模式，即系统自动调整租户中的向量索引数据的内存占用比例，无需手动调整：
  * 租户实际内存为 8GB 及以下时，该值自适应为 `40`。
  * 租户实际内存为 8GB 以上时，该值自适应为 `50`。

## 索引内存估算与实际占用查询

支持通过 `DBMS_VECTOR` 系统包进行索引内存估算：

* 未建表时，通过 [INDEX_VECTOR_MEMORY_ADVISOR](../700.reference/600.pl-reference/200.pl-mysql/1000.pl-system-package-mysql/17850.dbms-vector-mysql/500.index-vector-memory-advisor-mysql.md) 过程估算索引内存。
* 已建表且插入数据时，通过 [INDEX_VECTOR_MEMORY_ESTIMATE](../700.reference/600.pl-reference/200.pl-mysql/1000.pl-system-package-mysql/17850.dbms-vector-mysql/400.index-vector-memory-estimate-mysql.md) 过程分析索引内存。

向量索引内存估算会返回两项信息：创建向量索引所需的最少内存配置，以及 HNSW_SQ 和 IVF 索引创建完成后的实际内存占用情况。

我们还提供了配置项 `load_vector_index_on_follower` 来控制 `follower` 角色是否自动加载内存向量索引。语法和示例请参见[load_vector_index_on_follower](../700.reference/800.configuration-items-and-system-variables/100.system-configuration-items/400.tenant-level-configuration-items/4230.load_vector_index_on_follower.md)。如果不需要弱读，可将此配置项关闭以减少向量索引占用的内存。

实际占用内存的详细信息可以通过视图 [GV$OB_VECTOR_MEMORY](../700.reference/700.system-views/400.system-view-of-mysql-mode/300.performance-view-of-mysql-mode/4650.gv-ob_vector_memory-of-mysql-mode.md) 或 [V$OB_VECTOR_MEMORY](../700.reference/700.system-views/400.system-view-of-mysql-mode/300.performance-view-of-mysql-mode/35350.v-ob_vector_memory-of-mysql-mode.md) 获取。

## 创建语法及说明

OceanBase 向量索引的创建支持**在建表时创建**和**后建**两种方式。创建时需要注意：

* 创建向量索引必须带有 `VECTOR` 关键字。
* 后建索引的参数和说明与建表时创建索引一致。
* 如果数据量较大，建议先写完数据，再创建索引，以获得最佳搜索性能。
* HNSW_SQ/IVF/IVF_PQ 索引均建议在写入数据后再创建索引，并在写入较多增量数据后进行索引重建。每个索引具体的创建说明见下文具体示例。

:::tab
tab HNSW/HNSW_SQ/HNSW_BQ

建表时创建索引语法：

```sql
CREATE TABLE table_name (
    column_name1 data_type1,
    column_name2 VECTOR(dimension), -- 向量列，必须指定 VECTOR 类型，dimension 为向量维度
    ...,
    VECTOR INDEX index_name (column_name) WITH (param1=value1, param2=value2, ...)
);
```

后建索引语法：

```sql
-- 后建索引支持设置并行度，以提升索引构建性能，并行度最大设置不超过 CPU 核数 * 2
CREATE [/*+ paralell $value*/] VECTOR INDEX index_name ON table_name(column_name) WITH (param1=value1, param2=value2, ...);
```

`param` 参数说明：

| 参数 | 默认值 | 取值范围 | 是否必填 | 说明 | 备注 |
|------|--------|----------|----------|------|------|
| distance |  | l2/inner_product/cosine | 是 | 指定向量距离算法类型。 | l2 表示欧氏距离，inner_product 表示内积距离，cosine 表示余弦距离。 |
| type |  | 目前支持 `hnsw` / `hnsw_sq`/ `hnsw_bq`。 | 是 | 指定索引类型。 |  |
| lib | vsag | vsag | 否 | 指定向量索引库类型。 | 目前仅支持 VSAG 向量库。 |
| m | 16 | [5,128] | 否 | 每个节点的最大邻居数。 | 值越大，索引构建越慢，搜索性能越好。 |
| ef_construction | 200 | [5,1000] | 否 | 构建索引时的候选集大小。 | 值越大，索引构建越慢，索引质量越好。`ef_construction` 必须大于 `m`。|
| ef_search | 64 | [1,1000] | 否 | 搜索时的候选集大小。 | 值越大，搜索越慢，召回率越高。 |
| extra_info_max_size | 0 | [0,16384] | 否 | 设置每个主键信息的最大大小（单位：字节）。将表的主键存储在索引中，以加快搜索速度。 | <code>0</code>：不存储主键信息。<br/><code>1</code>：强制存储主键信息，忽略大小限制。此时表的主键类型（详见下文）必须为支持的类型。<br/><code>大于 1</code>：设置主键信息的最大大小（单位：字节）。此时，需要满足以下条件：<ul><li>主键信息的大小（计算方法见下文）必须小于设置的大小限制。</li><li>表的主键类型必须是支持的类型。</li></ul> |
| refine_k | 4.0 | [1.0,1000.0] | 否 | <main id="notice" type='notice'><h4>注意</h4><p>该参数从 V4.3.5 BP3 版本开始支持，仅在创建 HNSW_BQ 索引时可指定。</p></main>该参数为浮点数类型，用于调整量化向量索引的重排比例。 | 该参数可以在创建索引时设置，也可以在搜索时指定：<ul><li>如果搜索时没有设置，则使用创建索引时的值；</li><li>如果搜索时设置了，则使用搜索时设置的值。</li></ul> |
| refine_type | sq8 <main id="notice" type='notice'><h4>注意</h4><p>如果集群是从旧版本升级到 V4.3.5 BP3 版本，则该参数默认值为 fp32。</p></main> | sq8/fp32 | 否 | <main id="notice" type='notice'><h4>注意</h4><p>该参数从 V4.3.5 BP3 版本开始支持，仅在创建 HNSW_BQ 索引时可指定。</p></main>用于设置量化向量索引的构建精度。 | 该值通过降低索引构建时的内存开销和索引构建时间来提高效率，但可能会影响召回率。 |
| bq_bits_query | 32 | 0/4/32 | 否 | <main id="notice" type='notice'><h4>注意</h4><p>该参数从 V4.3.5 BP3 版本开始支持，仅在创建 HNSW_BQ 索引时可指定。</p></main>用于设置量化向量索引的搜索精度，单位为 bit。 | 该值通过降低索引构建时的内存开销和索引构建时间来提高效率，但可能会影响召回率。 |
| bq_use_fht | true <main id="notice" type='notice'><h4>注意</h4><p>如果集群是从旧版本升级到 V4.3.5 BP3 版本，则该参数默认值为 false。</p></main>  | true/false | 否 | <main id="notice" type='notice'><h4>注意</h4><p>该参数从 V4.3.5 BP3 版本开始支持，仅在创建 HNSW_BQ 索引时可指定。</p></main>用于设置是否使用 FHT 进行搜索。FHT（Fast Hadamard Transform）是一种用于加速向量内积计算的算法。 |  |

`extra_info_max_size` 支持的主键类型包括：

* [数值类型](../700.reference/100.oceanbase-database-concepts/400.database-objects/200.database-objects-of-mysql-mode/200.table-of-mysql-mode/200.data-type-of-mysql-mode/200.numeric-data-type-of-mysql-mode.md)：支持其中的整数类型、浮点类型和 Bit_value 类型。
* [日期时间类型](../700.reference/500.sql-reference/100.sql-syntax/200.common-tenant-of-mysql-mode/100.basic-elements-of-mysql-mode/100.data-type-of-mysql-mode/300.date-and-time-types-of-mysql-mode/100.date-and-time-types-of-mysql-mode.md)
* [字符类型](../700.reference/100.oceanbase-database-concepts/400.database-objects/200.database-objects-of-mysql-mode/200.table-of-mysql-mode/200.data-type-of-mysql-mode/400.string-data-type-of-mysql-mode.md)：支持其中的 VARCHAR 类型。

主键信息的大小计算方法：

```sql
SET @table_name = 'test'; -- 替换为要查询的 table_name

SELECT
    CASE
        WHEN COUNT(*) <> COUNT(result_value) THEN 'not support'
        ELSE COALESCE(SUM(result_value), 'not support')
    END AS extra_info_size
FROM (
    SELECT
        CASE
            WHEN vdt.data_type_class IN (1, 2, 3, 4, 6, 8, 9, 14, 27, 28) THEN 8 -- 为数值类型 extra_info_size += 8
            WHEN oc.data_type = 22 THEN oc.data_length -- 为 varchar 类型 extra_info_size += data_length
            ELSE NULL -- 其他类型不支持
        END AS result_value
    FROM
        oceanbase.__all_column oc
    JOIN
        oceanbase.__all_virtual_data_type vdt
    ON
        oc.data_type = vdt.data_type
    WHERE
        oc.rowkey_position != 0
        AND oc.table_id = (SELECT table_id FROM oceanbase.__all_table WHERE table_name = @table_name)
) AS result_table;

-- 计算结果为 8 byte
```

tab IVF

建表时创建索引语法：

```sql
CREATE TABLE table_name (
    column_name1 data_type1,
    column_name2 data_type2,
    ...,
    VECTOR INDEX index_name (column_name) WITH (param1=value1, param2=value2, ...)
);
```

后建索引语法：

```sql
-- 后建索引支持设置并行度，以提升索引构建性能，并行度最大设置不超过 CPU 核数 * 2
CREATE [/*+ paralell $value*/] VECTOR INDEX index_name ON table_name(column_name) WITH (param1=value1, param2=value2, ...);
```

`param` 参数说明：

| 参数 | 默认值 | 取值范围 | 是否必填 | 说明 | 备注 |
|------|--------|----------|----------|------|------|
| distance |  | l2/inner_product/cosine | 是 | 指定向量距离算法类型。 | l2 表示欧氏距离，inner_product 表示内积距离，cosine 表示余弦距离。 |
| type |  | ivf_flat/ivf_pq | 是 | 指定 IVF 索引类型。 |  |
| lib | ob | ob | 否 | 指定向量索引库类型。 |  |
| nlist | 128 | [1,65536] | 否 | 聚类中心的个数。 | <ul>V4.3.5 BP5 版本中：<li>如果业务数据少于 100W，推荐值为 `数据量/1000`。</li><li>如果业务数据大于 100W，推荐值为 `sqrt(数据量)`。</li>多分区表场景，`数据量`按照最大分区的数据量来估算。</ul> |
| sample_per_nlist | 256 | [1,int64_max] | 是 | 每个聚类中心的取样的数据量，后建索引中使用。 | V4.3.5 BP5 版本推荐保持默认值，不建议修改。 |
| nbits | 8 | [1,24] | 否 | 指定量化位数。<main id="notice" type='notice'><h4>注意</h4><p>该参数从 V4.3.5 BP3 版本开始支持，仅在创建 IVF_PQ 索引时可指定。</p></main> | 建议取值为 8，建议取值范围为 [8,10]。该值越大，量化精度越高，搜索准确率越高，同时搜索性能会受到影响。 |
| m | 无默认值，必须指定 | [1,65536] | 是 | 指定量化后的向量维度。<main id="notice" type='notice'><h4>注意</h4><p>该参数从 V4.3.5 BP3 版本开始支持，仅在创建 IVF_PQ 索引时可指定。</p></main> | 该值越大，索引构建越慢，搜索准确率越高，同时搜索性能会受到影响。 |

**针对 IVF/IVF_PQ 索引（仅适用于 V4.3.5 BP5 版本）**，有以下额外说明：

* 索引限制：
  * 不支持在堆表和分区表一起使用的场景下创建 IVF/IVF_PQ 索引。
* 构建建议：
  * 强烈建议在数据导入完成后再创建 IVF/IVF_PQ 索引。不建议在建表时同步创建 IVF 索引。因为在创建时若无数据，索引无法进行聚类，导致无法使用。此时需要手动执行 `REBUILD INDEX` 或 `DROP` 后重新 `CREATE INDEX`。
  * 建议在创建索引前，先参考本文[创建向量索引内存估算](#创建向量索引内存估算)章节，估算和查询内存占用情况，以避免创建过程中出现内存不足的问题。
  * 建议在创建索引前，执行合并 `ALTER SYSTEM major freeze` 并等待合并完成。
  * 多节点集群模式下，建议将 SYS 租户内存设置为大于 1G。
  * 建议在创建索引前,  将 [parallel_servers_target](../700.reference/800.configuration-items-and-system-variables/200.system-variable/300.global-system-variable/10600.parallel_servers_target-global.md) 参数值设置为租户 `max_cpu * 10`。
  * 单分区数据量千万以上，租户CPU资源高于10C的场景，建议在创建索引前，通过 `ALTER SYSTEM SET _px_object_sampling = 5000` 修改采样比例，可以提高索引构建的效率。

:::

## 搜索语法及说明

向量索引搜索是一种近似最近邻搜索，并不保证 100% 的结果正确。相应的向量搜索准确率的指标是召回率，例如在查 10 个最近邻时，如果可以稳定返回 9 个正确的结果，那么召回率就是 90%。召回率说明如下：

* 召回率受构建参数和搜索参数的影响。
* 索引搜索参数在建索引时指定，之后不可修改。但可通过 session 变量设置：HNSW/HNSW_SQ/HNSW_BQ 索引通过 `ob_hnsw_ef_search` 设置，IVF 索引通过 `ob_ivf_nprobes` 设置。如果设置了 session 变量，会优先使用它的值。具体设置方式请参见 [ob_hnsw_ef_search](../700.reference/800.configuration-items-and-system-variables/200.system-variable/400.session-system-variable/550.ob_hnsw_ef_search.md) 和 [ob_ivf_nprobes](../700.reference/800.configuration-items-and-system-variables/200.system-variable/400.session-system-variable/560.ob_ivf_nprobes.md)。

稠密向量索引搜索语法具体如下：

```sql
SELECT ... FROM $table_name ORDER BY $distance_function($column_name, $vector_expr) [APPROXIMATE|APPROX] LIMIT $num (OFFSET $num) [PARAMETERS ($param1=$value1, ...)];
```

搜索使用说明如下：

* 搜索语法要求：
  * 必须指定 `APPROXIMATE`/`APPROX` 关键字，搜索才会使用向量索引而非全表扫描。
  * 必须包含 `ORDER BY` 和 `LIMIT` 子句。
  * `ORDER BY` 只支持单个向量条件。
  * `LIMIT + OFFSET` 的取值范围为 `(0, 16384]`。
  * `PARAMETERS` 子句用于指定搜索参数。对于 IVF/IVF_PQ 索引，支持 `nprobes` 参数，例如 `PARAMETERS(nprobes=200)`。该参数从 V4.3.5 BP5 版本开始支持，用于指定搜索时的聚类中心数量。

* 距离函数使用规则：
  * 指定 `APPROXIMATE`/`APPROX`，调用当前版本支持的距离函数，且与向量索引算法匹配，搜索会使用向量索引。
  * 指定 `APPROXIMATE`/`APPROX`，距离函数与向量索引算法不匹配，搜索不会使用向量索引，但也不会报错。
  * 指定 `APPROXIMATE`/`APPROX`，如果距离函数为当前版本不支持的距离函数，搜索不会使用向量索引，且会报错。
  * 未指定 `APPROXIMATE`/`APPROX`，调用当前版本支持的距离函数，搜索不会使用向量索引，但也不会报错。

<main id="notice" type='notice'>
  <h4>注意</h4>
  <p>从 V4.3.5 BP5 版本开始支持使用 <code>PARAMETERS(similarity=$value)</code> 子句指定相似度阈值搜索。</p>
</main>

* 相似度阈值参数（`similarity`）：
  * 语法：在 `LIMIT` 子句后添加 `PARAMETERS (similarity=$value)`，其中 `$value` 为相似度阈值（取值范围为 `[0, 1]`）。通常相似度值越大，表示越相似，距离越小。`inner_product` 例外，距离越大反而越相似。
  * 功能：指定相似度阈值后，返回的结果中只包含相似度大于等于该阈值的结果。
  * 支持的索引类型：HNSW、HNSW_SQ、HNSW_BQ、IVF、IVF_PQ。
  * 支持的距离类型：
    * 查询时，支持为 `cosine_distance` 和 `l2_distance` 距离类型的索引指定相似度。对于 `l2_distance`，建议对向量进行 L2 归一化处理，这有助于提高相似度搜索的准确性。关于向量归一化的说明和示例，请参见[使用 SQL 函数-向量归一化](250.ob-vector-function.md)。
    * 不支持距离类型为 `inner_product` 的索引在查询时指定相似度（会报错 `not support`）。
  * 相似度与距离的对应关系：
    * `cosine_distance`=`2 - 2 * similarity`
    * `l2_distance`=`sqrt(1 / similarity -1)`

* 其他说明：
  * `WHERE` 条件会作为向量索引搜索后的过滤条件。
  * 不指定 `LIMIT` 子句会报错。

* IVF/IVF_PQ 索引搜索优化建议（**仅适用于 V4.3.5 BP5 版本**）：
  * 通过将主表在创建表的时候设置 `ROW_FORMAT=COMPRESSED` 启用压缩行格式，可以提升 IVF 向量索引搜索的性能 20~30%，例如：
    ```sql
    CREATE TABLE t1 (c1 INT PRIMARY KEY, c2 VECTOR(4)) ROW_FORMAT=COMPRESSED;
    ```
  * 不建议打开并行搜索，否则可能会影响搜索性能或结果不正确。

## 索引创建、搜索及删除示例

### 建表时创建

#### 稠密向量索引示例

##### HNSW 示例

<main id="notice" type='notice'>
  <h4>注意</h4>
  <p>创建 HNSW 索引时，索引名长度暂不支持超过 25 个字符，否则可能因为索引辅助表名长度超过 <code>index_name</code> 限制导致异常。未来版本会支持更长的索引名。</p>
</main>

创建测试表。

```sql
CREATE TABLE t1(c1 INT, c0 INT, c2 VECTOR(10), c3 VECTOR(10), PRIMARY KEY(c1), VECTOR INDEX idx1(c2) WITH (distance=l2, type=hnsw, lib=vsag),  VECTOR INDEX idx2(c3) WITH (distance=l2, type=hnsw, lib=vsag));
```

写入测试数据。

```sql
INSERT INTO t1 VALUES(1, 1,'[0.203846,0.205289,0.880265,0.824340,0.615737,0.496899,0.983632,0.865571,0.248373,0.542833]', '[0.203846,0.205289,0.880265,0.824340,0.615737,0.496899,0.983632,0.865571,0.248373,0.542833]');

INSERT INTO t1 VALUES(2, 2, '[0.735541,0.670776,0.903237,0.447223,0.232028,0.659316,0.765661,0.226980,0.579658,0.933939]', '[0.213846,0.205289,0.880265,0.824340,0.615737,0.496899,0.983632,0.865571,0.248373,0.542833]');

INSERT INTO t1 VALUES(3, 3, '[0.327936,0.048756,0.084670,0.389642,0.970982,0.370915,0.181664,0.940780,0.013905,0.628127]', '[0.223846,0.205289,0.880265,0.824340,0.615737,0.496899,0.983632,0.865571,0.248373,0.542833]');
```

使用近似最近邻搜索。

```sql
SELECT * FROM t1 ORDER BY l2_distance(c2, [0.712338,0.603321,0.133444,0.428146,0.876387,0.763293,0.408760,0.765300,0.560072,0.900498]) APPROXIMATE LIMIT 1;
```

返回结果如下：

```shell
+----+------+-------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------+
| c1 | c0   | c2                                                                                        | c3                                                                                         |
+----+------+-------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------+
|  3 |    3 | [0.327936,0.048756,0.08467,0.389642,0.970982,0.370915,0.181664,0.94078,0.013905,0.628127] | [0.223846,0.205289,0.880265,0.82434,0.615737,0.496899,0.983632,0.865571,0.248373,0.542833] |
+----+------+-------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------+
1 row in set
```

##### HNSW_SQ 示例

```sql
CREATE TABLE t2 (c1 INT AUTO_INCREMENT, c2 VECTOR(3), PRIMARY KEY(c1), VECTOR INDEX idx1(c2) WITH (distance=l2, type=hnsw_sq, lib=vsag));
```

##### HNSW_BQ 示例

```sql
CREATE TABLE t3 (c1 INT AUTO_INCREMENT, c2 VECTOR(3), PRIMARY KEY(c1), VECTOR INDEX idx3(c2) WITH (distance=l2, type=hnsw_bq, lib=vsag));
```

HNSW_BQ 索引 `distance` 参数支持 l2 和 cosine。cosine 从 V4.3.5 BP4 版本开始支持。

##### IVF 示例

<main id="notice" type='notice'>
  <h4>注意</h4>
  <p>创建 IVF 索引时，索引名长度暂不支持超过 33 个字符，否则可能因为索引辅助表名长度超过 <code>index_name</code> 限制导致异常。未来版本会支持更长的索引名。</p>
</main>

```sql
CREATE TABLE ivf_vecindex_suite_table_test (c1 INT, c2 VECTOR(3), PRIMARY KEY(c1), VECTOR INDEX idx2(c2) WITH (distance=l2, type=ivf_flat));
```

### 后建

<main id="notice" type='notice'>
  <h4>注意</h4>
  <p>目前仅支持后建稠密向量索引。</p>
</main>

#### HNSW 示例

创建测试表。

```sql
CREATE TABLE vec_table_hnsw (id INT, c2 VECTOR(10));
```

创建 HNSW 索引。

```sql
CREATE VECTOR INDEX vec_idx1 ON vec_table_hnsw(c2) WITH (distance=l2, type=hnsw);
```

查看创建的表。

```sql
SHOW CREATE TABLE vec_table_hnsw;
```

返回结果如下：

```shell
+-----------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Table     | Create Table                                                                                                                                                                                                                                                                                                                                                                                         |
+-----------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| vec_table_hnsw | CREATE TABLE `vec_table_hnsw` (
  `id` int(11) DEFAULT NULL,
  `c2` VECTOR(10) DEFAULT NULL,
  VECTOR KEY `vec_idx1` (`c2`) WITH (DISTANCE=L2, TYPE=HNSW, LIB=VSAG, M=16, EF_CONSTRUCTION=200, EF_SEARCH=64) BLOCK_SIZE 16384
) DEFAULT CHARSET = utf8mb4 ROW_FORMAT = DYNAMIC COMPRESSION = 'zstd_1.3.8' REPLICA_NUM = 2 BLOCK_SIZE = 16384 USE_BLOOM_FILTER = FALSE TABLET_SIZE = 134217728 PCTFREE = 0 |
+-----------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set

OceanBase(root@oceanbase)>SHOW INDEX FROM vec_table_hnsw;
+-----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+-----------+---------------+---------+------------+
| Table     | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment   | Index_comment | Visible | Expression |
+-----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+-----------+---------------+---------+------------+
| vec_table |          1 | vec_idx1 |            1 | c2          | A         |        NULL | NULL     | NULL   | YES  | VECTOR     | available |               | YES     | NULL       |
+-----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+-----------+---------------+---------+------------+
1 row in set
```

#### HNSW_SQ 示例

创建测试表。

```sql
CREATE TABLE vec_table_hnsw_sq (c1 INT AUTO_INCREMENT, c2 VECTOR(3), PRIMARY KEY(c1));
```

创建 HNSW_SQ 索引。

```sql
CREATE VECTOR INDEX vec_idx2 ON vec_table_hnsw_sq(c2) WITH (distance=l2, type=hnsw_sq, lib=vsag, m=16, ef_construction = 200);
```

##### HNSW_BQ 示例

```sql
CREATE VECTOR INDEX vec_idx3 ON vec_table_hnsw_bq(c2) WITH (distance=l2, type=hnsw_bq, lib=vsag, m=16, ef_construction = 200);
```

HNSW_BQ 索引 `distance` 参数支持 l2 和 cosine。cosine 从 V4.3.5 BP4 版本开始支持。

#### IVF 示例

创建测试表。

```sql
CREATE TABLE vec_table_ivf (c1 INT, c2 VECTOR(3), PRIMARY KEY(c1));
```

创建 IVF 索引。

```sql
CREATE VECTOR INDEX vec_idx3 ON vec_table_ivf(c2) WITH (distance=l2, type=ivf_flat);
```

### 删除

删除向量索引的语法如下：

```sql
DROP INDEX vec_idx1 ON vec_table;
```

查看删除的索引。

```sql
SHOW INDEX FROM vec_table;
```

返回结果如下：

```shell
Empty set
```

## 维护

增量数据过多的情况下，搜索性能会下降。为减小增量数据表的数据量，OceanBase 引入了 `DBMS_VECTOR` 对向量索引进行维护。

### 增量刷新

<main id="notice" type='notice'>
  <h4>注意</h4>
  <p>IVF/IVF_PQ 索引无增量刷新机制。</p>
</main>

如果建立索引后写入数据较多，建议使用 `REFRESH_INDEX` 过程进行增量刷新。说明和示例请参见 [REFRESH_INDEX](../700.reference/600.pl-reference/200.pl-mysql/1000.pl-system-package-mysql/17850.dbms-vector-mysql/200.refresh-index-mysql.md)。

增量刷新每 15 分钟会检查一次，如果增量数据超过 1W 条，则自动执行增量刷新。

### 全量刷新（重建）

#### 手动全表重建

如果建立索引后更新或删除数据较多，建议使用 `REBUILD_INDEX` 过程进行全量刷新。说明和示例请参见 [REBUILD_INDEX](../700.reference/600.pl-reference/200.pl-mysql/1000.pl-system-package-mysql/17850.dbms-vector-mysql/300.rebuild-index-mysql.md)。

全量刷新每 24 小时会检查一次，如果新增数据超过原有数据的 20%，则自动执行全量刷新。全量刷新会在后台异步执行，首先创建新的索引，然后替换旧索引。在重建过程中，旧索引保持可用状态，但整体过程相对较慢。

我们还提供了 `vector_index_memory_saving_mode` 配置项来控制索引重建的内存占用。开启此模式可以降低分区表向量索引重建（rebuild）过程中的内存消耗。通常，向量索引重建需要消耗相当于索引两倍的内存。开启省内存模式后，系统会在分区表单个分区构建完成后，通过暂时删除该分区的内存索引来释放内存，从而有效降低重建操作所需的总内存。语法和示例请参见[vector_index_memory_saving_mode](../700.reference/800.configuration-items-and-system-variables/100.system-configuration-items/400.tenant-level-configuration-items/8250.vector_index_memory_saving_mode.md)。

注意事项如下：

* 执行 [离线 DDL](../700.reference/500.sql-reference/100.sql-syntax/200.common-tenant-of-mysql-mode/700.ddl-function-of-mysql-mode/150.online-and-offline-ddl-list-of-mysql-mode.md) 操作（例如 `ALTER TABLE` 修改表结构或主键）时，将导致索引表的重建。由于重建索引无法指定并行度，系统会默认使用单线程，因此在数据量较大时，重建过程会比较缓慢，从而影响整个 离线 DDL 的执行效率。
* 重建索引时如果需要修改索引参数，必须在参数列表中同时指定 `type` 和 `distance`，且 `type` 和 `distance` 必须和原索引类型一致，例如原来索引类型是 `hnsw`，距离算法是 `l2`，则重建时必须同时指定 `type=hnsw` 和 `distance=l2`。
* 重建索引时支持：
    * 修改 `m`，`ef_search`，`ef_construction`值。
    * IVF/IVF_PQ 在 V4.3.5 BP5 版本中修改 `nlist`、`sample_per_nlist`、`distance`、`nbits`、`m` 值，其中 `m` 和 `nbits`  是 IVF_PQ 索引的独有参数。
    * 在线重建 `ef_search` 参数。
    * `hnsw` <-> `hnsw_sq` 的索引类型重建。
    * `ivf_flat` <-> `ivf_flat`，`ivf_pq` <-> `ivf_pq` 的索引类型重建。
    * 支持重建时设置并行度。示例见 [REBUILD_INDEX](../700.reference/600.pl-reference/200.pl-mysql/1000.pl-system-package-mysql/17850.dbms-vector-mysql/300.rebuild-index-mysql.md)。
* 重建索引时不支持：
    * 修改 `type` 和 `distance` 类型。
    * `hnsw` <-> `ivf` 的索引重建。
    * `hnsw` <-> `hnsw_bq` 的索引重建。
    * `ivf_flat`，`ivf_pq` 之间的交叉重建。
* IVF/IVF_PQ 重建索引建议（**仅适用于 V4.3.5 BP5 版本**）：
    * 在执行 `REBUILD INDEX` 前，建议将 `ob_trx_timeout` 参数值设置为大于索引重建（rebuild）所需的时间，以避免出现超时问题。

#### 自动分区重建（推荐）

<main id="notice" type='notice'>
  <h4>注意</h4>
  <p><li>此功能从 V4.3.5 BP3 版本开始支持，如果你的向量集群从旧版本升级到 V4.3.5 BP3，那么你需要在升级后先手动全表重建所有向量索引，否则升级后可能无法自动执行分区重建任务。</li><li>当前版本仅支持 HNSW/HNSW_SQ/HNSW_BQ 索引类型。</li></p>
</main>

当前版本会触发自动分区重建任务的场景有两种：

* 执行向量索引搜索语句时。
* 定时检查，可手动配置执行周期。

1. 配置执行周期

    在 `oceanbase` 数据库下，通过配置项 [vector_index_optimize_duty_time](../700.reference/800.configuration-items-and-system-variables/100.system-configuration-items/400.tenant-level-configuration-items/8260.vector_index_optimize_duty_time.md) 配置执行周期。示例如下：

    ```sql
    ALTER SYSTEM SET vector_index_optimize_duty_time='[23:00:00, 24:00:00]';
    ```

    如上配置完成后，分区重建任务只会在 23:00:00~24:00:00 时间段执行，其他时间段里不会发起。详细参数说明参见相应配置项文档。

2. 查看任务进展/历史任务

    可通过 [CDB/DBA_OB_VECTOR_INDEX_TASKS](../700.reference/700.system-views/400.system-view-of-mysql-mode/200.dictionary-view-of-mysql-mode/12950.o-dba_ob_vector_index_tasks-of-mysql-mode.md) 或 [CDB/DBA_OB_VECTOR_INDEX_TASK_HISTORY](../700.reference/700.system-views/400.system-view-of-mysql-mode/200.dictionary-view-of-mysql-mode/12960.o-dba_ob_vector_index_task_history-of-mysql-mode.md) 视图查看任务进展和历史任务。

    通过 `status` 字段判断任务当前状态：

    * 0（PREPARE），表示任务等待执行。
    * 1（RUNNING），表示任务正在执行中。
    * 2（PENDING），表示任务暂停执行。
    * 3（FINISHED），表示任务已完成。
    执行结束的任务，即状态 `status=FINISHED` 的任务，无论是否执行成功都会被转存到历史表。详细使用示例请参见相应视图文档。

3. 取消任务

    如需取消任务，可通过 `DBA_OB_VECTOR_INDEX_TASKS` 或 `CDB_OB_VECTOR_INDEX_TASKS` 视图获取 trace_id 后，执行以下命令：

    ```sql
    ALTER SYSTEM CANCEL TASK <trace_id>;
    ```

    示例如下：

    ```sql
    ALTER SYSTEM CANCEL TASK "Y61480BA2D976-00063084E80435E2-0-1";
    ```

## 性能优化

<main id="notice" type='notice'>
  <h4>注意</h4>
  <p>此功能从 V4.3.5 BP3 开始支持，目前仅支持 IVF 索引。</p>
</main>

OceanBase 向量搜索为 IVF 索引提供了自动性能优化机制，通过缓存管理和定期维护来提升搜索性能。

### 优化机制

IVF 索引性能优化包含两种自动任务：

1. 缓存预热任务：定期检查所有 IVF 索引，如果发现索引对应的缓存不存在，则自动触发缓存预热，将索引数据加载到内存中。此外，创建 IVF 索引时，会自动预热缓存。
2. 缓存清理任务：定期检查所有 IVF 缓存，如果发现缓存对应的索引已被删除，则自动清理失效的缓存，释放内存资源。此外，删除 IVF 索引时，会自动清理缓存。

### 配置优化执行周期

系统支持自定义性能优化任务的执行时间窗口，避免在业务高峰期执行影响性能。

在 `oceanbase` 数据库下，通过配置项 `vector_index_optimize_duty_time` 设置执行周期：

```sql
ALTER SYSTEM SET vector_index_optimize_duty_time='[23:00:00, 24:00:00]';
```

配置说明如下：

* 时间格式为 `[开始时间, 结束时间]`。
* 上述配置表示只在 23:00:00~24:00:00 时间段执行优化任务。
* 其他时间段不会发起优化任务，避免影响正常业务。

### 监控优化任务

1. 查看当前任务状态

    通过 `DBA_OB_VECTOR_INDEX_TASKS` 视图查看正在执行或等待执行的任务：

    ```sql
    -- 需在 MySQL 租户下查询
    SELECT * FROM oceanbase.DBA_OB_VECTOR_INDEX_TASKS;
    ```

    返回结果示例：

    ```shell
    +----------+---------------------+---------+----------------------------+----------------------------+--------------+----------+-----------+------------------+----------+------------------------------------+
    | TABLE_ID | TABLET_ID           | TASK_ID | START_TIME                 | MODIFY_TIME                | TRIGGER_TYPE | STATUS   | TASK_TYPE | TASK_SCN         | RET_CODE | TRACE_ID                           |
    +----------+---------------------+---------+----------------------------+----------------------------+--------------+----------+-----------+------------------+----------+------------------------------------+
    |   500020 | 1152921504606846990 | 2002281 | 1970-08-23 17:10:23.174127 | 1970-08-23 17:10:23.174137 | USER         | FINISHED |         2 | 1750671687770026 |        0 | YAFF00B9E4D97-00063839E6BD9BBC-0-1 |
    +----------+---------------------+---------+----------------------------+----------------------------+--------------+----------+-----------+------------------+----------+------------------------------------+
    1 row in set
    ```

    任务状态说明：

    * `STATUS = 0`：PREPARE，任务等待执行。
    * `STATUS = 1`：RUNNING，任务正在执行中。
    * `STATUS = 3`：FINISHED，任务已完成。

    任务类型说明：

    * `TASK_TYPE = 2`：IVF 缓存预热任务。
    * `TASK_TYPE = 3`：IVF 失效缓存清理任务。

2. 查看历史任务记录

    已完成的任务（`STATUS = 3`）无论成功与否都会被自动转存到历史表，每 10 秒转存一次。通过 `DBA_OB_VECTOR_INDEX_TASKS_HISTORY` 视图查看历史记录：

    ```sql
    -- 查询指定任务 ID 的历史记录
    SELECT * FROM oceanbase.DBA_OB_VECTOR_INDEX_TASKS_HISTORY WHERE TASK_ID=2002281;
    ```

    返回结果示例：

    ```shell
    +----------+---------------------+---------+----------------------------+----------------------------+--------------+----------+-----------+------------------+----------+------------------------------------+
    | TABLE_ID | TABLET_ID           | TASK_ID | START_TIME                 | MODIFY_TIME                | TRIGGER_TYPE | STATUS   | TASK_TYPE | TASK_SCN         | RET_CODE | TRACE_ID                           |
    +----------+---------------------+---------+----------------------------+----------------------------+--------------+----------+-----------+------------------+----------+------------------------------------+
    |   500020 | 1152921504606846990 | 2002281 | 1970-08-23 17:10:23.174127 | 1970-08-23 17:10:23.174137 | AUTO         | FINISHED |         2 | 1750671687770026 |        0 | YAFF00B9E4D97-00063839E6BD9BBC-0-1 |
    +----------+---------------------+---------+----------------------------+----------------------------+--------------+----------+-----------+------------------+----------+------------------------------------+
    1 row in set
    ```

### 取消优化任务

通过以下命令可以取消指定任务。

```sql
-- trace_id 从上文 DBA_OB_VECTOR_INDEX_TASKS_HISTORY 视图获取
ALTER SYSTEM CANCEL TASK <trace_id>;
```

<main id="notice" type='notice'>
  <h4>注意</h4>
  <p>只有在任务的失败重试阶段，且执行 <code>ALTER SYSTEM CANCEL TASK</code> 命令的情况下，才能取消任务。如果后台任务卡在某一次执行阶段，无法通过此命令取消后台任务。</p>
</main>

示例如下：

```sql
-- 登陆 SYS 系统租户，获取指定任务的 trace_id
SELECT * FROM oceanbase.DBA_OB_VECTOR_INDEX_TASK_HISTORY WHERE TASK_ID=2037736;
+----------+---------------------+---------+----------------------------+----------------------------+--------------+----------+-----------+------------------+----------+------------------------------------+
| TABLE_ID | TABLET_ID           | TASK_ID | START_TIME                 | MODIFY_TIME                | TRIGGER_TYPE | STATUS   | TASK_TYPE | TASK_SCN         | RET_CODE | TRACE_ID                           |
+----------+---------------------+---------+----------------------------+----------------------------+--------------+----------+-----------+------------------+----------+------------------------------------+
|   500041 | 1152921504606847008 | 2037736 | 1970-08-23 17:10:23.203821 | 1970-08-23 17:10:23.203821 | USER         | PREPARED |         2 | 1750682301145225 |       -1 | YAFF00B9E4D97-00063839E6BDDEE0-0-1 |
+----------+---------------------+---------+----------------------------+----------------------------+--------------+----------+-----------+------------------+----------+------------------------------------+
1 row in set
```

```sql
-- 取消任务
ALTER SYSTEM CANCEL TASK "YAFF00B9E4D97-00063839E6BDDEE0-0-1";
```

取消任务后，任务状态会变为 `CANCELLED`。

```sql
-- 登陆用户租户，查询任务状态
SELECT * FROM oceanbase.DBA_OB_VECTOR_INDEX_TASK_HISTORY;
+----------+---------------------+---------+----------------------------+----------------------------+--------------+----------+-----------+------------------+----------+------------------------------------+
| TABLE_ID | TABLET_ID           | TASK_ID | START_TIME                 | MODIFY_TIME                | TRIGGER_TYPE | STATUS   | TASK_TYPE | TASK_SCN         | RET_CODE | TRACE_ID                           |
+----------+---------------------+---------+----------------------------+----------------------------+--------------+----------+-----------+------------------+----------+------------------------------------+
|   500041 | 1152921504606847008 | 2037736 | 1970-08-23 17:10:23.203821 | 1970-08-23 17:10:23.203821 | USER         | FINISHED |         2 | 1750682301145225 |    -4072 | YAFF00B9E4D97-00063839E6BDDEE0-0-1 |
+----------+---------------------+---------+----------------------------+----------------------------+--------------+----------+-----------+------------------+----------+------------------------------------+
1 row in set
```

## 相关文档

* [使用 SQL 函数](250.ob-vector-function.md)
