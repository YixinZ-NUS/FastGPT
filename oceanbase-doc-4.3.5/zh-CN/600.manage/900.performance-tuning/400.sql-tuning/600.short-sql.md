| Description   |                 |
|---------------|-----------------|
| keywords      |                 |
| dir-name      |                 |
| dir-name-en   |                 |
| tenant-type   |                 |

# 定位和分析高频短查询

在 TP 业务场景中，SQL 执行时间通常极短（毫秒级），但高频执行可能导致整体资源消耗激增。这类查询的“慢”不体现在单次执行时间，而体现在 **总读行量** 或 **资源累积消耗** 上。例如，一个高频查询若每次全表扫描，即使单次耗时 10ms，但每秒执行 1000 次，总资源消耗可能远超低频长查询。

## 示例场景

以下 SQL 在选择索引 `IDX_C1` 时，每次仅读取少量行（百微秒级）；但若选择全表扫描，则每次读取大量数据（数十毫秒级）。虽然单次执行时间不长，但若查询频次极高（如每秒数千次），全表扫描可能导致 CPU 资源耗尽。

```sql
CREATE TABLE T1 (C1 INT, C2 INT);
CREATE INDEX IDX_C1 ON T1 (C1);

-- 插入 10K 行数据，且 C1 值几乎唯一
INSERT INTO T1 VALUES (1, 1), (2, 2), ... (10000, 10000);

-- 高频查询：单次执行时间短，但读行量可能差异巨大
SELECT * FROM T1 WHERE C1 = 1;
```


## 分步诊断流程

### 步骤 1：通过 `GV$OB_SQL_AUDIT` 统计高频查询的资源消耗

OceanBase 提供 `GV$OB_SQL_AUDIT` 系统视图，可按 **读行量**、**CPU 时间** 等维度统计 SQL 的累积影响。以下 SQL 会按总读行量排序，找出前 10 个高频短查询：

```sql
SELECT /*+READ_CONSISTENCY(WEAK), QUERY_TIMEOUT(100000000)*/  svr_ip, sql_id,
    tenant_id, tenant_name, user_name, db_name, plan_id,
    count(*) exections,
    max(event) event,
    max(table_scan) table_scan,
    sum(case when ret_code = 0 then 0 else 1 end) fail_times,
    sum(rpc_count) rpc_count,
    sum(retry_cnt) retry_cnt,
    sum(case when plan_type = 2 then 1 else 0 end)
    remote_plans,
    sum(case when is_hit_plan = 1 then 0 else 1 end) miss_plans,
    round(avg(elapsed_time)) elapsed_time,
    round(max(elapsed_time)) max_elapsed_time,
    round(avg(execute_time)) execute_time,
    round(avg(( execute_time - total_wait_time_micro + get_plan_time ))) cpu_time,
    round(max(( execute_time - total_wait_time_micro + get_plan_time ))) max_cpu_time,
    round(avg(queue_time)) queue_time,
    round(avg(net_wait_time)) netwait_time,
    round(avg(user_io_wait_time)) iowait_time,
    round(avg(get_plan_time)) getplan_time,
    round(avg(decode_time)) decode_time,
    round(avg(total_wait_time_micro)) total_wait_time,
    round(avg(application_wait_time)) app_wait_time,
    round(avg(concurrency_wait_time)) concurrency_wait_time,
    round(avg(schedule_time)) schedule_time,
    round(avg(return_rows)) return_rows,
    round(avg(affected_rows)) affected_rows,
    round(avg(row_cache_hit * 2 + bloom_filter_cache_hit * 2 + block_cache_hit +
    disk_reads)) logical_reads,
    round(avg(row_cache_hit)) row_cache_hit,
    round(avg(bloom_filter_cache_hit)) bloom_filter_cache_hit,
    round(avg(block_cache_hit)) block_cache_hit,
    round(avg(disk_reads)) disk_reads,
    round(avg(memstore_read_row_count)) memstore_read_row_count,
    round(avg(ssstore_read_row_count)) ssstore_read_row_count,
    sum(memstore_read_row_count + ssstore_read_row_count) as total_row_count
    from   gv$ob_sql_audit
    where  is_inner_sql = 0
    group  by svr_ip, sql_id order by total_row_count desc limit 10;

```

**关键字段说明**：

- **`total_row_count`**：该 SQL 所有执行的累计读行量，是判定高频短查询的关键指标。
- **`avg_cpu_time`**：平均 CPU 消耗时间，辅助判断资源密集型查询。
- **`rpc_count` 和 `retry_cnt`**：高值可能表示网络延迟或重试问题。

如果发现排在最前的几个请求整体读行量明显高出了 1~2 个数量级。那么这些请求优化的价值就会非常高。如果可以优化这些请求的执行计划，整体可以得到非常大的收益。

在实际诊断的过程中，读行量不是唯一会导致 CPU 飙高的指标，诊断过程中还可以尝试按照其他字段进行排序分析，例如，按照总的 CPU 时间排序；观察重试的次数（retry_cnt）；观察 RPC 的次数（rpc_count）等等。综合分析多个维度找出潜在的慢查询。

### 步骤 2：定位问题 SQL 的执行计划

根据**步骤 1** 的结果（如 `sql_id`、`tenant_id`、`svr_ip`），通过 `GV$OB_PLAN_CACHE_PLAN_STAT` 查看执行计划的元数据：

```sql
SELECT tenant_id,
   svr_ip,
   svr_port,
   sql_id,
   plan_id,
   last_active_time,
   first_load_time,
   outline_data
FROM GV$OB_PLAN_CACHE_PLAN_STAT
WHERE TENANT_ID = 1002
AND SQL_ID = '3310A1D1D81D4BA92CEEF42538136DD1'
AND SVR_IP = '11.xxx.x.xx'
AND SVR_PORT = 35046;
```

**示例输出**：

```shell
*************************** 1. row ***************************
    tenant_id: 1002
        svr_ip: 11.xxx.x.xx
        svr_port: 35046
        sql_id: 3310A1D1D81D4BA92CEEF42538136DD1
        plan_id: 741
last_active_time: 2022-08-04 11:00:34.466037
first_load_time: 2022-08-04 11:00:34.466037
    outline_data: /*+ BEGIN_OUTLINE_DATA FULL(@"SEL$1" "test.t1"@"SEL$1") END_OUTLINE_DATA*/
```

**输出字段分析**：

| **字段**          | **作用**                                                                 |
|-------------------|-------------------------------------------------------------------------|
| `trace_id`        | 查询的唯一追踪标识。 |
| `plan_id`         | 查询的执行计划的编号。    |
| `last_active_time`| 计划最后一次被使用的时间，通常对应慢查询发起时间。对跑批来说，last_active_time 大概率就是慢查询发起的时间。                       |
| `first_load_time`| 执行计划第一次生成的时间。                       |
| `outline_data`    | 记录优化器生成的 hint，帮助分析计划生成逻辑。                              |


### 步骤 3：分析执行计划细节

通过**步骤 2** 的 `plan_id`，查询 `GV$PLAN_CACHE_PLAN_EXPLAIN` 获取物理执行计划：

```sql
SELECT OPERATOR,  -- 算子类型
       NAME,      -- 操作对象
       ROWS,      -- 预估行数
       COST       -- 预估成本
FROM GV$PLAN_CACHE_PLAN_EXPLAIN
WHERE TENANT_ID = 1002
AND SVR_IP = '11.xxx.x.xx'
AND SVR_PORT = 35046
AND PLAN_ID = 741;
```

**物理计划输出**：

```shell
+----------------+------+------+------+
| OPERATOR       | NAME | ROWS | COST |
+----------------+------+------+------+
| PHY_TABLE_SCAN | t1   |    1 |   45 |
+----------------+------+------+------+
```

**补充逻辑计划分析**：

直接对 SQL 执行 `EXPLAIN` 可查看逻辑计划：

```sql
EXPLAIN SELECT * FROM T1 WHERE C1 = 1;
```

**逻辑计划输出**：

```shell
Query Plan: ===================================
|ID|OPERATOR  |NAME|EST. ROWS|COST|
-----------------------------------
|0 |TABLE SCAN|t1  |10000     |46  |  -- 若未命中索引，预估行数可能远高于实际
==================================

Outputs & filters:
-------------------------------------
0 - output([t1.*]), filter([t1.c1 = 1]),
    access([t1.__pk_increment]), partitions(p0)
```

## 关键分析维度

以下指标可辅助定位问题：

1. **读行量（`total_row_count`）**：
   - 若某个 SQL 的读行量远高于其他查询（如高 1~2 个数量级），需优先优化其执行计划。
2. **CPU 时间（`avg_cpu_time`）**：
   - 高频 SQL 的平均 CPU 消耗若持续增长，可能引发系统负载问题。
3. **执行计划异常**：
   - 若物理计划为 `TABLE_SCAN`，但实际应命中索引 `IDX_C1`，说明优化器选择了低效计划。
