| Description   |                 |
|---------------|-----------------|
| keywords      |                 |
| dir-name      |                 |
| dir-name-en   |                 |
| tenant-type   |                 |

# 存储层估行

在数据库优化中，统计信息的收集通常在查询计划生成之前进行。这意味着如果在统计信息收集后，有大量的增删改操作发生，但没有及时重新收集统计信息，可能会导致计划生成时使用过时的统计信息，从而无法准确估算行数，进而无法选择最优的执行计划。为了解决这类问题，OceanBase 数据库优化器引入了实时的存储层估行机制，以获取更加实时和准确的统计信息。

## 存储层估行机制

在生成查询计划时，优化器基于表的索引生成多个基表的扫描路径，简称“基表路径”。OceanBase 数据库存储层以树形结构存储这些索引，因此在计划生成过程中，针对每个基表路径，优化器会基于表的谓词条件生成多个查询范围区域（简称“QUERY RANGE”）。这样设计的目的是为了快速扫描获取指定的数据区域，避免无效的数据扫描。
优化器将在生成计划时，将基表路径上的相关 QUERY RANGE 提前发送给存储层，以便存储层快速估算这些 QUERY RANGE 的总行数，然后将结果返回给优化器。通过这一过程，优化器能够获得实时和准确的行数估算，这一过程即为存储层估行。

存储层收集实时统计信息，通过隐藏配置项 `_enable_filter_reordering` 控制是否在存储层开启过滤器的重排序功能，默认是开启的，用于提升查询性能。

### 估行限制

然而，并非所有的 QUERY RANGE 和分区都会被用于存储层估行。由于存储层估行是一项时间成本较高的操作，为了避免影响计划生成的整体性能，有以下两个限制：

* **QUERY RANGE 限制**：在基表路径上的 QUERY RANGE 数量不得过多。如果数量超过系统变量 `range_index_dive_limit` 的设定，则随机选择该数量的 QUERY RANGE 进行存储层估行。同样，当 QUERY RANGE 的数量小于该变量时，会选择所有的 QUERY RANGE 进行估行。如果这个变量为 0，系统将始终选择所有 QUERY RANGE 而不做限制。

* **分区限制**：对于分区表，如果经裁剪后的分区数量超过系统变量 `partition_index_dive_limit` 的限制，则将随机选择该数量的分区进行存储层估行。当分区个数小于该变量时，将总是选择所有分区进行估行。如果该变量为 0，同样会选择所有分区。

需要注意的是，存储层估行仅适用于基表路径，不适用于其他算子，例如 JOIN、GROUP BY 等。
以往版本中，多列 IN 谓词会被识别为非精确谓词的问题，当前版本放开存储层估行，使得在处理多列 IN 谓词时，即使在存在多个 QUERY RANGE 的情况下，也能进行准确的行数估算，从而提高查询计划的优化效果。
