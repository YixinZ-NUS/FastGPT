| Description   |                 |
|---------------|-----------------|
| keywords      |                 |
| dir-name      |                 |
| dir-name-en   |                 |
| tenant-type   |                 |

# 联接简介

JOIN 操作合并来自两个数据源（例如表或视图）的输出，并返回一个数据源。多表 JOIN 的类型定义在 SQL 语句的 `WHERE`（非 ANSI）或 `FROM ... JOIN` (ANSI) 子句中。只要 FROM 子句中存在多个表，数据库就会执行联接。

联接条件用于定义表之间的关联关系，如果该语句未指定联接条件，则数据库执行笛卡尔联接，将一个表中的每一行与另一个表中的每一行进行匹配。

## 联接树

一棵联接树一般表示为翻转的树状结构，如下图所示，`T1` 是联接左侧的表，也称之为驱动表，一般是维度表，`T2` 是联接右侧的表，一般是事实表。优化器一般自左向右处理联接的表。

![联接树1](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.1/manage/join1.png)

联接的数据源也可以来自于另外一个联接的结果，如果左侧数据源来自于另一个联接的结果，右侧数据源来自于基表，我们称之为左深树，大部分的业务计划都是左深树。如下图所示。

![联接树2](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.1/manage/join2.png)

如果右侧数据源来自于另外一个联接的结果，左侧数据源来自于基表，我们称之为右深树，如下图所示。

![联接树3](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.1/manage/join3.png)

如果有任何一个联接节点与其他联接节点的形态不同，我们称之为浓密联接树，如下图所示。

![联接树4](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.1/manage/join4.png)

## 优化器如何优化联接

当 FROM 子句中存在多个表时，优化器必须确定每一对表的最高效联接操作，优化器从以下几个方面决策。

|维度	|说明  |
|---|---|
|基表路径	|对于每个基表，优化器需要选择最佳的扫描方式，例如主表扫描或者索引扫描。|
|联接算法	|为了联接两个数据源，优化器需要决策如何关联两个数据源，可选的联接算法有：nested loop join、merge join、hash join，每种联接算法都有其高效的场景，优化器需要根据统计信息选择最优的联接算法。|
|联接类型	|优化器支持的联接类型有：inner join、left join、right join、full join、left semi join、right semi join、left anti join、right anti join、connect by join。后五种联接是优化器改写出来的联接类型，SQL无法通过语法指定这几种联接类型。|
|联接次序	|当联接表的数量超过两张时，优化器需要决策最优的联接次序。例如：FROM T1, T2, T3，可能的联接次序有：T1 JOIN T2 JOIN T3、T1 JOIN T3 JOIN T2等等，优化器需要从可能的联接次序中决策出执行性能最优的联接次序。|

## 优化器如何决策联接计划

在决策联接顺序和方法时，优化器的目标是尽早减少联接数据量，以便在 SQL 语句的整个执行过程中执行较少的工作。优化器根据可能的联接顺序、联接方法和可用的访问路径生成一组执行计划，然后估计每个计划的成本并选择成本最低的一个计划。

优化器通过计算 I/O 、网络和 CPU 开销来估计查询计划的成本。不同的数据分发方式有不同的网络开销，此外，不同的函数和表达式有不同的CPU开销。优化器使用这些指标确定查询计划的总成本。这些指标可能会在编译时受到许多初始化参数和会话设置的影响，例如 PARALLEL、ENABLE_ROWSETS、系统统计信息等。

例如，优化器通过以下方式估算成本：

* nested loop join 的成本取决于将外部表的每一行及其内部表的每个匹配行读入内存的成本。优化器使用内部表的统计信息来估计这些成本。
* merge join 的成本在很大程度上取决于将所有源读入内存并对它们进行排序的成本。
* hash join 的成本在很大程度上取决于在联接的输入端之一构建哈希表并使用联接另一端的行来探测它的成本。
