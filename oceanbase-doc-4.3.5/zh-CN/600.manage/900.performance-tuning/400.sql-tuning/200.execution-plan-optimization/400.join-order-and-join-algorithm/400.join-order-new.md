| Description   |                 |
|---------------|-----------------|
| keywords      |                 |
| dir-name      |                 |
| dir-name-en   |                 |
| tenant-type   |                 |

# 联接次序

## 什么是联接次序

对于多表联接，由于数据库每次只能联接两个数据源，所以优化器必须要按照两两一组指定联接次序。同时，一条查询可能有多种联接次序，例如 `select * from t1, t2, t3 where t1.c1 = t2.c1 and t2.c1 = t3.c1;` 这条联接查询有多个可选的联接次序，其中两个可选的联接次序如下。

```
Plan 1:
==============================================
|ID|OPERATOR    |NAME|EST. ROWS  |COST       |
----------------------------------------------
|0 |HASH JOIN   |    |96059601000|22771533844|
|1 | HASH JOIN  |    |98010000   |23334667   |
|2 |  TABLE SCAN|T1  |100000     |42605      |
|3 |  TABLE SCAN|T2  |100000     |42605      |
|4 | TABLE SCAN |T3  |100000     |42605      |
==============================================

Plan 2:
==============================================
|ID|OPERATOR    |NAME|EST. ROWS  |COST       |
----------------------------------------------
|0 |HASH JOIN   |    |96059601000|22771533844|
|1 | HASH JOIN  |    |98010000   |23334667   |
|2 |  TABLE SCAN|T3  |100000     |42605      |
|3 |  TABLE SCAN|T2  |100000     |42605      |
|4 | TABLE SCAN |T1  |100000     |42605      |
==============================================
```

对于更复杂的查询，例如 `select 1 from t1, t2, t3, t4 where t1.c1 = t2.c1 and t1.c1 = t3.c1 and t1.c1 = t4.c1;` 有更多的可选联接次序，并且对于不同的联接次序执行成本差异可能非常大，优化器需要根据一定的策略选择最优的联接次序。

## 优化器如何决策联接次序

优化器每次选择两个数据源联接，直到所有的数据源都参与联接，得到所有可能的联接次序，最后再计算每个联接次序的执行成本，基于计算的成本选择最优的联接次序。

影响优化器决策联接次序的因素非常多，例如：联接的数据量、表的列访问量、数据分布情况、联接算法以及数据表的索引。其中最容易影响优化器选择联接次序的因素是联接数据量，这个因素取决于统计信息的准确度以及优化器的行数估计。

## 如何控制优化器使用特定的联接次序

有两种 hint 控制优化器的联接次序选择。

一是 ORDERED，指示优化器不去考虑其他联接次序，选择查询定义的联接次序联接。例如 `select /*+ORDERED*/ 1 from t1, t2, t3 where t1.c1 = t2.c1 and t1.c1 = t3.c1;`，优化器只会选择 `t1 join t2 join t3` 这一种联接次序生成计划。

```
==============================================
|ID|OPERATOR    |NAME|EST. ROWS  |COST       |
----------------------------------------------
|0 |HASH JOIN   |    |96059601000|65343614674|
|1 | HASH JOIN  |    |98010000   |66674090   |
|2 |  TABLE SCAN|T1  |100000     |61860      |
|3 |  TABLE SCAN|T2  |100000     |61860      |
|4 | TABLE SCAN |T3  |100000     |61860      |
==============================================
```

另外一个是 LEADING，通过这个 hint 我们可以控制优化器确定全部或部分联接次序。例如 `select /*+leading(t1 t3 t4 t2)*/ 1 from t1, t2, t3, t4 where t1.c1 = t2.c1 and t1.c1 = t3.c1 and t1.c1 = t4.c1;`，通过 LEADING 指定完整的联接次序。

```
=====================================================
|ID|OPERATOR     |NAME|EST. ROWS     |COST          |
-----------------------------------------------------
|0 |HASH JOIN    |    |9.414801e+13  |6.412702e+13  |
|1 | HASH JOIN   |    |96059601000   |65343614674   |
|2 |  HASH JOIN  |    |98010000      |66674090      |
|3 |   TABLE SCAN|T1  |100000        |61860         |
|4 |   TABLE SCAN|T3  |100000        |61860         |
|5 |  TABLE SCAN |T4  |100000        |61860         |
|6 | TABLE SCAN  |T2  |100000        |61860         |
=====================================================
```

同时也可以指定部分联接次序，剩下的表由优化器决定联接次序。例如 `select /*+leading(t3 t1)*/ 1 from t1, t2, t3, t4 where t1.c1 = t2.c1 and t1.c1 = t3.c1 and t1.c1 = t4.c1;`，优化器可能考虑以下几个联接次序。

```
Query Plan1:
=====================================================
|ID|OPERATOR     |NAME|EST. ROWS     |COST          |
-----------------------------------------------------
|0 |HASH JOIN    |    |9.414801e+13  |6.412702e+13  |
|1 | HASH JOIN   |    |96059601000   |65343614674   |
|2 |  HASH JOIN  |    |98010000      |66674090      |
|3 |   TABLE SCAN|T3  |100000        |61860         |
|4 |   TABLE SCAN|T1  |100000        |61860         |
|5 |  TABLE SCAN |T4  |100000        |61860         |
|6 | TABLE SCAN  |T2  |100000        |61860         |
=====================================================

Query Plan2:
=====================================================
|ID|OPERATOR     |NAME|EST. ROWS     |COST          |
-----------------------------------------------------
|0 |HASH JOIN    |    |9.414801e+13  |6.412702e+13  |
|1 | HASH JOIN   |    |96059601000   |65343614674   |
|2 |  HASH JOIN  |    |98010000      |66674090      |
|3 |   TABLE SCAN|T3  |100000        |61860         |
|4 |   TABLE SCAN|T1  |100000        |61860         |
|5 |  TABLE SCAN |T2  |100000        |61860         |
|6 | TABLE SCAN  |T4  |100000        |61860         |
=====================================================
```

然后由优化器通过成本决策最优联接次序。

## 如何简单的判断优化器选择的联接次序不优

业务中遇到的联接次序不优问题基本上是统计信息不准确或者行数估计不准确，当遇到慢查询问题时，首先可以通过确认基表的行数估计是否准确，如果发现某张表的行数估计偏差较大，基本上优化器选择的联接次序成本不是最低的。例如 `select 1 from t1, t2, t3, t4 where t1.c1 = t2.c1 and t1.c1 = t3.c1 and t1.c1 = t4.c1 and t1.c2=2 and t4.c2=1` 的计划执行很慢。

```
=========================================
|ID|OPERATOR     |NAME|EST. ROWS|COST   |
-----------------------------------------
|0 |HASH JOIN    |    |9686572  |2563762|
|1 | HASH JOIN   |    |9884     |184590 |
|2 |  HASH JOIN  |    |11       |97710  |
|3 |   TABLE SCAN|T1  |10       |48849  |
|4 |   TABLE SCAN|T4  |10       |48849  |
|5 |  TABLE SCAN |T2  |100000   |42605  |
|6 | TABLE SCAN  |T3  |100000   |42605  |
=========================================
```

通过构造 SQL 确认基表行数信息，例如确认 T1 的行数 `select count(*) from t1 where t1.c2=2;`，发现真实的行数有 100w 行，说明在错误的行数估计下，优化器选择的联接次序不优，需要通过 leading hint 控制优化器选择的联接次序。例如 `leading(t3 (t2 (t4 t1)))`。
