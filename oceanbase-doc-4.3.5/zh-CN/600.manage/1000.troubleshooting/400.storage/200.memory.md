|description||
|---|---|
|keywords||
|dir-name||
|dir-name-en||
|tenant-type||

# 内存相关问题

内存相关的报错如下。

|内部错误码|信息展示|
|---------|--------|
|-4013    |`No memory or reach tenant memory limit`|
|-4030    |`Over tenant memory limits` |

## 错误码 4013 相关的内存问题

错误码 4013 表示各个模块内存不足，例如：Working Area 不足。出现该问题的可能原因是编译和执行模块内存不足。此时 MemStore 并没有占满，仅仅是各个模块的内存不足导致的报错。

OceanBase 数据库的内存管理方法禁止任何模块通过 glibc 库中的 malloc 与 free 接口申请和释放内存。OceanBase 数据库的内存除了节点预留内存（`system_memory`）和 `sys` 租户的内存之外，大部分都留给了普通租户，普通租户的内存限制是可以调节的。但是普通租户的内存限制了普通租户下的 CTX 内存，而 CTX 内存的是被多个 MOD 分配占用。因此，找到对应的 MOD 或者 CTX 就可以确定申请内存失败的操作类型。有关错误码 4013 的详细排查操作，参见 [4013 内存爆问题的排查](https://www.oceanbase.com/knowledge-base/oceanbase-database-1000000000704208?back=kb)。

## 错误码 4030 相关的内存问题

错误码 4030 表示 MemStore 内存不足，此类问题通常发生在 INSERT、UPDATE、DELETE 语句及 TABLE_SCAN 动作等涉及 MemStore 操作的场景。

当 MemStore 内存超限时，需要检查数据写入是否过量或未做限流。当遇到大量写入且数据转储跟不上写入速度的时候就会报这种错误。可以执行以下语句查看内存状态。

```shell
obclient(root@sys)[oceanbase]> SELECT /*+ READ_CONSISTENCY(WEAK),query_timeout(100000000) */ TENANT_ID, SVR_IP,
           round(ACTIVE_SPAN/1024/1024/1024,2) ACTIVE_GB,
           round(FREEZE_TRIGGER/1024/1024/1024,2) FREEZE_TRIGGER_GB,
           round(MEMSTORE_USED/1024/1024/1024,2) TOTAL_GB,
           round(MEMSTORE_USED/FREEZE_TRIGGER*100,2) percent_trigger,
           round(MEMSTORE_LIMIT/1024/1024/1024,2) MEM_LIMIT_GB
FROM oceanbase.GV$OB_MEMSTORE
WHERE TENANT_ID >1000 OR TENANT_ID=1
ORDER BY TENANT_ID, TOTAL_GB DESC;
```

更多内存相关的查询操作，参见 [查看内存的使用信息](../../../700.reference/200.system-management/700.memory-management/800.view-memory-usage.md)。

错误码 4030 的出现可能有以下几个原因：

* 内存模块超限。

  该问题的紧急应对措施是增加租户内存。

  问题解决之后需要分析原因，如果是因为未做限流引起，需要加上相应措施，然后回滚之前的租户内存修改。如果确实是因为业务规模增长而导致租户内存不足以支撑业务时，需要根据转储的频度设置合理的租户内存大小。如果 MemStore 内存并未超限，可以运行下述语句判断是哪个内存模块超限。

  ```shell
  obclient(root@sys)[oceanbase]> SELECT TENANT_ID, SVR_IP, SUM(HOLD) MODULE_SUM
  FROM oceanbase.GV$OB_MEMORY
  WHERE TENANT_ID > 1000 AND HOLD<>0 AND CTX_NAME NOT IN ('KVSTORE_CACHE_ID','MEMSTORE_CTX_ID')
  GROUP BY TENANT_ID, SVR_IP;
  ```

  内存模块超限的判断标准是：`MODULE_SUM` > 租户 min_memory - 租户 MemStore。模块的内存超限，可能需要先调整单个模块的内存，例如，修改 [ob_sql_work_area_percentage](../../../700.reference/800.configuration-items-and-system-variables/200.system-variable/300.global-system-variable/9100.ob_sql_work_area_percentage-global.md) 参数来调整工作区内存。如果租户内存过小，也需要加租户内存。

* PLANCACHE 的命中率低于 90%。

  OLTP 系统的 PLANCACHE 命中率应不低于 90%，执行以下语句查看 PLANCACHE 的命中率。

  * 查看命中率低于 90% 的 PLANCACHE。

    ```shell
    obclient(root@sys)[oceanbase]> SELECT PLAN_ID, HIT_COUNT, EXECUTIONS, (HIT_COUNT/EXECUTIONS) AS HIT_RATIO
    FROM oceanbase.V$OB_PLAN_CACHE_PLAN_STAT
    WHERE (HIT_COUNT/EXECUTIONS) < 0.9;
    ```

  * 查看执行次数超过 1000 次且命中率低于 90% 的 PLANCACHE。

    ```shell
    obclient(root@sys)[oceanbase]> SELECT PLAN_ID, HIT_COUNT, EXECUTIONS, (HIT_COUNT/EXECUTIONS) AS HIT_RATIO
    FROM oceanbase.V$OB_PLAN_CACHE_PLAN_STAT
    WHERE (HIT_COUNT/EXECUTIONS) < 0.9 AND EXECUTIONS > 1000;
    ```

    如果 PLANCACHE 的命中率低于 90%，需要确认是否有类似语句，例如：语句中 `in` 或 `not in` 后面的参数个数随机，从而导致大量浪费；如果不是，可能是业务量或会话激增导致的内存不足，需要调整租户的内存大小。

* 日志中有 `fail to alloc memory` 或 `allocate memory fail` 等错误信息。

  日志中包含了 `tenant_id` （租户编号）及 `context` （内存所属的 CTX 名称）信息，可以通过以下语句查询具体的内存模块信息。

  ```shell
  obclient(root@sys)[oceanbase]> SELECT * FROM oceanbase.GV$OB_MEMORY WHERE CTX_NAME = xxx and tenant_id = xxx;
  ```

  根据查询结果，如果是模块的内存超限，可能需要先调整单独模块的内存。如果是租户内存过小，也需要加租户内存。