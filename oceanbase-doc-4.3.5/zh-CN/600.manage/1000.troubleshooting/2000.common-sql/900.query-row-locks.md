|description||
|---|---|
|keywords||
|dir-name||
|dir-name-en||
|tenant-type||

# 查询行锁

在业务运行过程中，用户会经常遇到锁冲突的问题。对于行锁，有两个与其密切关系的对象：行锁的持有者和行锁的等待者，并且这两个对象在行锁的排查过程中起着重要的作用。从本质上来说，行锁冲突都是由事务引起，而这两个对象，均隶属于事务，故处理行锁问题时也需要对活跃事务进行监控。

## 查询持有锁和请求锁的事务相关信息

视图 `GV$OB_LOCKS` 中记录了当前用户中各表持有锁或请求锁的情况。该视图中主要展示以下 3 种类型的锁：

* 表锁（TM）：表或分区（Tablet）上的锁。通常 insert / update / delete 等 DML 操作会产生分区级表锁，而 DDL 操作会产生表级表锁。
* 行锁（TR）：写行时上的锁。
* 事务锁（TX）：最常见的锁，通常可以理解为在事务内做过写操作即会产生事务锁。

在 OceanBase 数据库中，如果一个事务持有行锁，则它一定持有自己的事务锁。

可以通过以下方式，查看持有锁和请求锁的事务相关信息。

* 系统租户

  系统租户下，可以通过以下语句进行查询。

  ```shell
  obclient> SELECT t.TENANT_ID, t.TRANS_ID, t.TYPE, t.ID1, t.ID2, t.LMODE, t.REQUEST, ROUND(t.CTIME / 1000000) CTIME_s, t.BLOCK
    FROM oceanbase.gv$ob_locks t
    WHERE t.BLOCK = 1 ORDER BY t.TRANS_ID;
  ```

* 用户租户

  MySQL 模式的用户租户下，可以通过以下语句进行查询。

  ```shell
  obclient> SELECT t.TRANS_ID, t.TYPE, t.ID1, t.ID2, t.LMODE, t.REQUEST, ROUND(t.CTIME / 1000000) CTIME_s, t.BLOCK
    FROM oceanbase.gv$ob_locks t
    WHERE t.BLOCK = 1 ORDER BY t.TRANS_ID;
  ```

  Oracle 模式的用户租户下，可以通过以下语句进行查询。

  ```shell
  obclient> SELECT t.TRANS_ID, t.TYPE, t.ID1, t.ID2, t.LMODE, t.REQUEST, ROUND(t.CTIME / 1000000) CTIME_s, t.BLOCK
    FROM SYS.gv$ob_locks t
    WHERE t.BLOCK = 1 ORDER BY t.TRANS_ID;
  ```

例如，系统租户下的查询结果如下：

```shell
+-----------+----------+------+----------+--------------------------------+-------+---------+---------+-------+
| TENANT_ID | TRANS_ID | TYPE | ID1      | ID2                            | LMODE | REQUEST | CTIME_s | BLOCK |
+-----------+----------+------+----------+--------------------------------+-------+---------+---------+-------+
|      1002 | 23723243 | TR   |   200051 | 23723237-{"BIGINT UNSIGNED":1} | NONE  | X       |      20 |     1 |
|      1002 | 23723243 | TX   | 23723237 | NULL                           | NONE  | X       |      20 |     1 |
+-----------+----------+------+----------+--------------------------------+-------+---------+---------+-------+
2 rows in set
```

从第一行结果可知，当前有一条行锁（TR）信息，请求锁的事务的 ID（字段 `TRANS_ID`）为 `23723243`，被锁的对象的 `tablet_id`（字段 `ID1`）为 `200051`；被锁的行信息（字段 `ID2`）为 `23723237-{"BIGINT UNSIGNED":1}`，并且等待锁的时间为 20 秒。

从第二行结果可知，当前有一条事务锁（TX）信息，请求锁的事务的 ID（字段 `TRANS_ID`）为 `23723243`；持有锁的事务的 ID（字段 `ID1`） 为 `23723237`。

## 根据 trans_id 查询事务对应的 session_id

视图 `GV$OB_TRANSACTION_PARTICIPANTS` 中记录了所有 OBServer 节点上活跃事务的参与者信息。

用户在获取到持有锁或请求锁的事务的 `trans_id` 后，可以通过查询视图 `GV$OB_TRANSACTION_PARTICIPANTS` 来获取事务对应的 `session_id`。

* 系统租户

  系统租户下，可以通过以下语句进行查询。

  ```shell
  obclient> SELECT ROUND(now() - t.CTX_CREATE_TIME) RUNNING_TIME_s, t.TENANT_ID, t.SVR_IP, t.SVR_PORT, t.SESSION_ID, t.TX_TYPE, t.TX_ID, t.STATE, t.ACTION, t.CTX_CREATE_TIME, t.LAST_REQUEST_TIME
    FROM oceanbase.GV$OB_TRANSACTION_PARTICIPANTS t
    WHERE t.TX_ID IN (holdlock_trans_id, requestlock_trans_id);
  ```

* 用户租户

  MySQL 模式的用户租户下，可以通过以下语句进行查询。

  ```shell
  obclient>SELECT ROUND(now() - t.CTX_CREATE_TIME) RUNNING_TIME_s, t.TENANT_ID, t.SVR_IP, t.SVR_PORT, t.SESSION_ID, t.TX_TYPE, t.TX_ID, t.STATE, t.ACTION, t.CTX_CREATE_TIME, t.LAST_REQUEST_TIME
    FROM oceanbase.GV$OB_TRANSACTION_PARTICIPANTS t
    WHERE t.TX_ID IN (holdlock_trans_id, requestlock_trans_id);
  ```

  Oracle 模式的用户租户下，可以通过以下语句进行查询。

  ```shell
  obclient>SELECT ROUND(now() - t.CTX_CREATE_TIME) RUNNING_TIME_s, t.TENANT_ID, t.SVR_IP, t.SVR_PORT, t.SESSION_ID, t.TX_TYPE, t.TX_ID, t.STATE, t.ACTION, t.CTX_CREATE_TIME, t.LAST_REQUEST_TIME
    FROM SYS.GV$OB_TRANSACTION_PARTICIPANTS t
    WHERE t.TX_ID IN (holdlock_trans_id, requestlock_trans_id);
  ```

语句中：

* `running_time_s`：事务执行的总时长。
* `holdlock_trans_id`：持有锁的事务的 ID。
* `requestlock_trans_id`：请求锁的事务的 ID。

获取到持有锁的事务对应的 session_id 后，就可以使用 `kill session_id` 回滚对应的事务了。

## 相关文档

* [行锁问题排查介绍](https://www.oceanbase.com/knowledge-base/oceanbase-database-1000000001012955?back=kb)

* [OceanBase 数据库 V4.2 版本，关于锁冲突问题的排查手册](https://www.oceanbase.com/knowledge-base/oceanbase-database-1000000000664387?back=kb)
