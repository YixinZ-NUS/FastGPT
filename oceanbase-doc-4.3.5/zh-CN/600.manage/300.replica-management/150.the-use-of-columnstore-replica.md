|description||
|---|---|
|keywords||
|dir-name||
|dir-name-en||
|tenant-type||

# 使用列存副本

为满足对 TP 增强混合负载（准实时决策分析）场景的支持，OceanBase 数据库提供了对列存副本（COLUMNSTORE，以下简称 C 副本）的支持。用户可以将 C 副本部署在独立的 Zone 上。在 C 副本上，所有的用户表（包括复制表、不包括索引表、内部表、系统表）均为列存格式存储。OLAP 业务通过独立的 proxy 入口访问 C 副本，并以弱读方式执行决策分析类业务。

## 注意事项

在使用 C 副本时，需要注意以下事项：

* 从 V4.3.5 BP1 版本开始，支持部署多个 C 副本，建议最多部署 3 个 C 副本。

* C 副本与 F 或 R 副本之间不支持相互转换。

* 由于访问 C 副本需要部署独立的 ODP，建议对存在 C 副本的 Zone 上只部署 C 副本。同时，部署 ODP 时，要求其版本必须为 ODP V4.3.2 及以上版本。

* F/R 副本上的查询不允许转发到 C 副本。反之，C 副本上的用户表查询也不允许转发到 F/R 副本，否则会报错。

* 部署了 C 副本的集群，在执行 DDL 操作时，会对 CPU、内存、磁盘以及 IO 等资源的使用产生影响。

* C 副本的合并比 F/R 副本的合并慢。如果 C 副本未合并完成，将无法发起新一轮的租户级合并。手动触发合并前，建议通过查看 [CDB_OB_ZONE_MAJOR_COMPACTION](../../700.reference/700.system-views/300.system-view-of-sys-tenant/200.dictionary-view-of-sys-tenant/12000.o-cdb_ob_zone_major_compaction-of-sys-tenant.md) 或 [DBA_OB_ZONE_MAJOR_COMPACTION](../../700.reference/700.system-views/400.system-view-of-mysql-mode/200.dictionary-view-of-mysql-mode/13000.o-dba_ob_zone_major_compaction-of-mysql-mode.md) 视图来确认上一轮所有副本是否都已完成合并。

  有关查看合并情况的详细操作，参见 [查看合并信息](../../700.reference/200.system-management/500.manage-data-storage/200.merge-management/500.view-merge-process.md)。

* 物理恢复不支持恢复 C 副本，指定租户的 Locality 时，如果指定了 C 副本，恢复操作将会执行失败。

* 如果主库未部署 C 副本，备库也不建议部署 C 副本。

## 部署 C 副本并配置 ODP

以下内容主要介绍如何在 OceanBase 集群中部署并配置 ODP，以访问 C 副本。

### 步骤一：部署 C 副本

要在集群中部署 C 副本，只需要在租户的 Locality 中指定 C 副本即可。主要有以下两种场景：

* 创建租户时指定 C 副本

* 通过修改租户的 Locality 来增加 C 副本

#### 创建租户时指定 C 副本

假设当前有一个已部署好的集群，且集群的部署模式为 2F1A（两副本+ 1 个仲裁服务）。集群中的 3 个 Zone 分别为 zone1、zone2、zone3，仲裁服务部署在 zone3 上。需要在该集群上创建一个含有 C 副本的租户，步骤如下：

1. 找到一台能够与当前集群网络互通的机器，并在该机器上部署 ODP。

   为防止资源争抢，建议 ODP 单独部署在一台机器上。部署 ODP 时，要求其版本必须为 ODP V4.3.2 及以上版本。有关部署 ODP 的详细操作，参见 [部署 ODP](https://www.oceanbase.com/docs/common-odp-doc-cn-1000000001600960)。

2. 为租户创建资源单元 `unit1`。

   ```shell
   obclient [oceanbase]> CREATE RESOURCE UNIT unit1, MAX_CPU=5, MIN_CPU=5, MEMORY_SIZE= '32G', MAX_IOPS=10000, MIN_IOPS=5000, LOG_DISK_SIZE=5301023539200;
   ```

3. 为租户创建资源池 `pool1`，指定资源单元为 `unit1`。

   ```shell
   obclient [oceanbase]> CREATE RESOURCE POOL pool1 UNIT='unit1', UNIT_NUM = 1, ZONE_LIST = ('zone1','zone2','zone3');
   ```

4. 创建一个租户 `tenant_c`，指定其 Locality 为 `F@zone1,F@zone2,C@zone3`。

   ```shell
   obclient [oceanbase]> CREATE TENANT tenant_c LOCALITY = 'F@zone1,F@zone2,C@zone3', primary_zone='zone1;zone2,zone3', RESOURCE_POOL_LIST=('pool1') SET ob_tcp_invited_nodes = '%';
   ```

   本示例中，创建的租户默认为 MySQL 兼容模式租户，如果需要创建 Oracle 兼容模式租户，需要通过系统变量 [ob_compatibility_mode](../../700.reference/800.configuration-items-and-system-variables/200.system-variable/300.global-system-variable/6100.ob_compatibility_mode-global.md) 显式指定 `ob_compatibility_mode='oracle'`。

#### 通过修改租户的 Locality 来增加 C 副本

假设当前集群中有一个名为 `tenant_c` 的租户，其 Locality 为 `F@zone1,F@zone2,F@zone3`，租户的资源池为 `pool1`，其 `ZONE_LIST` 范围为 `'zone1','zone2','zone3'`。现在需要为租户增加 C 副本，可以增加一个 `Zone4`，然后修改租户的 Locality 为 `F@zone1,F@zone2,F@zone3,C@zone4`，步骤如下：

1. 在集群中添加新的 Zone `zone4`。添加 Zone 的详细操作，参见 [添加 Zone](../100.cluster-management/300.common-cluster-operations/800.add-a-zone.md)。

2. 向 `zone4` 内增加节点。添加节点的详细操作，参见 [添加节点](../100.cluster-management/300.common-cluster-operations/400.add-a-node.md)。

3. 找到一台能够与当前集群网络互通的机器，并在该机器上部署 ODP。

   为防止资源争抢，建议 ODP 单独部署在一台机器上。部署 ODP 时，要求其版本必须为 ODP V4.3.2 及以上版本。有关部署 ODP 的详细操作，参见 [部署 ODP](https://www.oceanbase.com/docs/common-odp-doc-cn-1000000001600960)。

4. 创建资源单元 `unit2`。

   ```shell
   obclient [oceanbase]> CREATE RESOURCE UNIT unit2, MAX_CPU=5, MIN_CPU=5, MEMORY_SIZE= '32G', MAX_IOPS=10000, MIN_IOPS=5000, LOG_DISK_SIZE=5301023539200;
   ```

5. 创建资源池 `pool2`，指定资源单元为 `unit2`。

   ```shell
   obclient [oceanbase]> CREATE RESOURCE POOL pool2 UNIT = 'unit2', UNIT_NUM = 1, ZONE_LIST = ('zone4');
   ```

6. 为租户增加资源池 `pool2`。

   ```shell
   obclient [oceanbase]> ALTER TENANT tenant_c RESOURCE_POOL_LIST = ('pool1','pool2');
   ```

7. 修改租户的 Locality 为 `F@zone1,F@zone2,F@zone3,C@zone4`。

   ```shell
   obclient [oceanbase]> ALTER TENANT tenant_c LOCALITY = 'F@zone1,F@zone2,F@zone3,C@zone4';
   ```

### 步骤二：配置路由转发策略及弱读请求

部署 C 副本后，需要配置路由转发策略及弱读请求，以保证 OLAP 请求可以自动转为弱读请求并转发到相应的 C 副本上。

1. 使用 `root@proxysys` 用户登录到用于访问 C 副本的 ODP。

   连接示例如下：

   ```shell
   [admin@obtest ~]$ obclient -uroot@proxysys -h10.10.10.1 -P2883 -p
   ```

2. 执行以下语句，配置路由转发策略及弱读请求。

   支持以下两种配置项组合，选择任意一种进行设置即可。

   * 第一种

      * 配置 SQL 请求为只读类型。

         ```shell
         obclient> ALTER PROXYCONFIG SET obproxy_read_only = 0;
         ```

      * 配置 SQL 请求为弱一致性读。
   
         ```shell
         obclient> ALTER PROXYCONFIG SET obproxy_read_consistency = 1;
         ```

      * 配置弱读情况下，ODP 所有请求仅路由到 C 副本所在的 Zone，同时生成 C 副本的查询计划。

         例如， C 副本所在的 Zone 为 `zone4`。

         ```shell
         obclient> ALTER PROXYCONFIG SET proxy_primary_zone_name='zone4';
         ```

         ```shell
         obclient> ALTER PROXYCONFIG SET init_sql='set @@ob_route_policy = COLUMN_STORE_ONLY';
         ```

   * 第二种

      * 配置 SQL 请求为只读类型。

         ```shell
         obclient> ALTER PROXYCONFIG SET obproxy_read_only = 0;
         ```

      * 配置 SQL 请求为弱一致性读。
   
         ```shell
         obclient> ALTER PROXYCONFIG SET obproxy_read_consistency = 1;
         ```

      * 配置弱读情况下，所有请求仅路由到 C 副本，同时生成 C 副本的查询计划。

         ```shell
         obclient> ALTER PROXYCONFIG SET route_target_replica_type = 'ColumnStore';
         ```

         ```shell
         obclient> ALTER PROXYCONFIG SET init_sql='set @@ob_route_policy = COLUMN_STORE_ONLY';
         ```

      * 配置弱读情况下，所有请求仅选择从副本，当从副本都不可用时，断开和客户端的连接。

         ```shell
         obclient> ALTER PROXYCONFIG SET proxy_route_policy='TARGET_REPLICA_TYPE_FOLLOWER_ONLY';
         ```

3. 修改成功后，通过以下语句，确认修改结果。

   ```shell
   obclient> SHOW PROXYCONFIG ALL LIKE 'obproxy_read_only';
   ```

   ```shell
   obclient> SHOW PROXYCONFIG ALL LIKE 'obproxy_read_consistency';
   ```

   ```shell
   obclient> SHOW PROXYCONFIG ALL LIKE 'proxy_primary_zone_name';
   ```

   ```shell
   obclient> SHOW PROXYCONFIG ALL LIKE 'init_sql';
   ```

   ```shell
   obclient> SHOW PROXYCONFIG ALL LIKE 'route_target_replica_type';
   ```

   ```shell
   obclient> SHOW PROXYCONFIG ALL LIKE 'proxy_route_policy';
   ```

配置成功后，对于 OLAP 业务，用户可以通过该独立的 ODP 将查询请求定向到 C 副本，利用列存批量处理的优势加速查询，且不影响原有的 OLTP 业务。

## C 副本上暂为行存的几种场景

在 OceanBase 数据库中，如果一张表在被创建时为行存表，则系统会在 C 副本上创建对应的纯列存表；如果一张表在被创建时为列存表，则在 C 副本上的存储方式将与 F 副本保持一致。故，对于 C 副本而言，仅负责将 F 副本上行存的用户表的用户分区转换为列存存储，且该描述仅表示 “最终” 状态为列存。在 C 副本上，并非任意时刻分区均表现为列存形式，在以下场景中， C 副本上的用户表分区会暂时为行存，需要系统自发调度行转列任务，将最新的基线数据转换为列存。

| 场景             | 描述                                                          |
|-----------------|---------------------------------------------------------------|
| 补副本（增加副本）             | 以修改 Locality 使得 `F@z1, F@z2` 变更为 `F@z1, F@z2, C@z3` 为例：<ul><li>行存基线从源端（F 副本或者 R 副本）迁移到目的端（C 副本）时，会先拷贝行存到 C 副本上，并尝试为该 Tablet 发起行转列。</li> <li>由于行转列也是一类特殊的合并，如果多次尝试行转列失败（例如 DAG Scheduler 队列满或 I/O 压力大或磁盘空间不足等），系统就会提供基于行存的弱读查询。</li></ul>|
| 日志流 Rebuild                | 当触发 C 副本上日志流的 Rebuid 时，系统将会从源端拉取相应的基线到 C 副本。若基线数据为行存，则暂时为行存，待后台调度行转列任务后再转为列存。|
| 补副本与 Offline DDL 并发场景  | 当 C 副本在日志流成员列表中时，若执行 Offline DDL，系统将会直接在 C 副本上构建列存基线。然而，当补副本与 Offline DDL 并发时，C 副本对执行 DDL 任务的日志流 Leader 不可见，此时系统在 C 副本上将会先构建出行存的基线，待后台调度行转列任务后再转为列存。|
| 全量旁路导入                   | 全量旁路导入当前仅支持先向 C 副本上导入行存，待后台调度行转列任务后转为列存。|
| 表级恢复                       | 由于当前列存表暂不支持表级恢复，因此 C 副本上的表级恢复仅支持先恢复为行存，待后台调度行转列任务后再转为列存。|

上述场景下，在进行行存转列存的过程中，尽管当前优化器生成的是列存查询计划，但实际执行的仍然是对行存基线的查询。用户可以通过视图 [CDB_OB_CS_REPLICA_STATS](../../700.reference/700.system-views/300.system-view-of-sys-tenant/200.dictionary-view-of-sys-tenant/8120.o-cdb_ob_cs_replica_stats-of-sys-tenant.md)（系统租户）和 [DBA_OB_CS_REPLICA_STATS](../../700.reference/700.system-views/400.system-view-of-mysql-mode/200.dictionary-view-of-mysql-mode/8220.o-dba_ob_cs_replica_stats-of-mysql-mode.md)（用户租户）来查询 C 副本的可用信息及行转列的进度，待行转列任务完全结束后，再进行 C 副本上的查询。

sys 租户下，查询所有租户 C 副本日志流中 Tablet 行转列进度的示例如下：

```shell
obclient[oceanbase]> SELECT * FROM oceanbase.CDB_OB_CS_REPLICA_STATS;
```

查询结果如下：

```shell
+-----------+----------------+----------+-------+------------------+----------------------+-----------------------+---------------------------+-----------+
| TENANT_ID | SVR_IP         | SVR_PORT | LS_ID | TOTAL_TABLET_CNT | AVAILABLE_TABLET_CNT | TOTAL_MACRO_BLOCK_CNT | AVAILABLE_MACRO_BLOCK_CNT | AVAILABLE |
+-----------+----------------+----------+-------+------------------+----------------------+-----------------------+---------------------------+-----------+
|      1004 | xx.xxx.xxx.212 |    63000 |  1001 |             1019 |                 1019 |                 10706 |                     10706 | TRUE      |
|      1006 | xx.xxx.xxx.212 |    63000 |  1001 |              133 |                  133 |                   875 |                       875 | TRUE      |
+-----------+----------------+----------+-------+------------------+----------------------+-----------------------+---------------------------+-----------+
2 rows in set
```

从第一行查询结果可知，租户 ID 为 1004 的租户，其 C 副本所在的服务器为 `xx.xxx.xxx.212`，端口号为 `63000`； C 副本日志流的 ID 为 `1001`；当前需要转换为列存的分区总数为 `1019`，可用的分区总数为 `1019`；当前总的基线宏块数为 `10706`，可用的基线宏块数为 `10706`。用户可以通过 `AVAILABLE_TABLET_CNT / TOTAL_TABLET_CNT` 或者 `AVAILABLE_MACRO_BLOCK_CNT /TOTAL_MACRO_BLOCK_CNT` 来大致估算行转列的进度。仅当日志流上的所有 Tablet 均可用时，该日志流才完全可用。
