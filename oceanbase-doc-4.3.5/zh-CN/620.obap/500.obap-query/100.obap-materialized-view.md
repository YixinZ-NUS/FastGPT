# 物化视图查询加速

物化视图（Materialized View, MV）是一种数据库对象，与普通视图不同的是，物化视图存储了视图的查询结果。通过保存某些耗时操作（例如聚合、连接）的结果，以便在查询时直接复用，从而避免重复执行这些耗时耗资源的操作，最终实现加速查询的目的。尤其是在数据仓库和决策支持系统中，能够大幅减少计算时间和提高查询效率。

## 物化视图的特性

### 物化视图刷新方式

创建物化视图时，用户可以选择不同的刷新方式来确保物化视图的数据与基表保持同步。刷新方式的选择会直接影响到系统性能和查询结果的实时性。

#### 全量刷新与增量刷新

* **全量刷新（Complete Refresh）**：每次刷新时，物化视图都会重新执行查询语句，并将计算结果覆盖原有视图结果数据。适用于延时要求低、基表数据更新频率低、查询语句比较复杂或数据量较小的场景。

* **增量刷新（Incremental Refresh）**：又称快速刷新（Fast Refresh），只刷新增量变更的数据，对于大规模数据集尤其适用。增量刷新需要依赖于物化视图日志（Materialized View Log，Mlog），对查询语句有一定的要求，目前支持单表聚合、多表连接以及多表连接聚合的查询语句，且对聚合函数和连接方式有一些要求，详见：[MySQL 模式下刷新物化视图](../../700.reference/300.database-object-management/100.manage-object-of-mysql-mode/600.manage-views-of-mysql-mode/200.manage-materialized-views-of-mysql-mode/400.refresh-materialized-views-of-mysql-mode.md) 和 [Oracle 模式下刷新物化视图](../../700.reference/300.database-object-management/200.manage-object-of-oracle-mode/500.manage-views-of-oracle-mode/200.manage-materialized-views-of-oracle-mode/400.refresh-materialized-views-of-oracle-mode.md)。适用于延时要求高、数据量庞大且变更频繁的业务场景。

#### 自动刷新与手动刷新

* **自动刷新（Automatic Refresh）**：在创建物化视图时，可以指定物化视图的刷新间隔，系统会根据配置的刷新时间规则自动调度物化视图的刷新任务。
* **手动刷新（Manual Refresh）**：如果物化视图未配置自动刷新或自动刷新的间隔比较大时，可以手动执行物化视图的刷新命令，让物化视图的数据与基表数据保持同步状态。

### 实时物化视图

实时物化视图（Real-Time Materialized Views）顾名思义是可以通过查询物化视图获取实时的数据，查询结果与直接查询基表相同，且能利用物化视图预计算的结果来加速查询。它通过使用 Mlog 的机制来捕获和处理底层基表的更改，确保物化视图中的数据能及时反映最新状态。由于依赖 Mlog，实时物化视图查询语句的要求同增量刷新的物化视图，即只有满足增量刷新物化视图要求，对应的物化视图才可以定义为实时物化视图。

更多关于创建实时物化视图的详细信息，参见 [MySQL 模式下创建物化视图](../../700.reference/300.database-object-management/100.manage-object-of-mysql-mode/600.manage-views-of-mysql-mode/200.manage-materialized-views-of-mysql-mode/300.create-materialized-views-of-mysql-mode.md) 和 [Oracle 模式下创建物化视图](../../700.reference/300.database-object-management/200.manage-object-of-oracle-mode/500.manage-views-of-oracle-mode/200.manage-materialized-views-of-oracle-mode/300.create-materialized-views-of-oracle-mode.md)。

### 嵌套物化视图

嵌套物化视图是指一个物化视图被另一个物化视图引用依赖。这种方式在 ETL（提取、转换、加载）过程中非常有用，在 ETL 流程中，嵌套物化视图可以将不同阶段的数据聚合、转换结果存储为独立的视图，避免了多次重复计算，提高了整个 ETL 过程的效率。嵌套物化视图不支持自动级联刷新，使用嵌套物化视图前需要先了解嵌套物化视图的刷新注意事项，保证查询上层物化视图获取到的数据结果符合预期。

更多关于创建嵌套物化视图的详细信息，参见 [MySQL 模式下创建物化视图](../../700.reference/300.database-object-management/100.manage-object-of-mysql-mode/600.manage-views-of-mysql-mode/200.manage-materialized-views-of-mysql-mode/300.create-materialized-views-of-mysql-mode.md) 和 [Oracle 模式下创建物化视图](../../700.reference/300.database-object-management/200.manage-object-of-oracle-mode/500.manage-views-of-oracle-mode/200.manage-materialized-views-of-oracle-mode/300.create-materialized-views-of-oracle-mode.md)。

### 物化视图查询改写

当想利用物化视图加速查询，但不想修改原始查询语句时，可以利用物化视图的查询改写能力，系统能够自动将查询语句与物化视图的定义进行匹配，如果发现匹配的物化视图，则自动将查询重写为使用物化视图的查询，这样在业务不做变更的情况下可以大大提高查询性能和效率。

更多关于物化视图查询改写的详细信息，参见 [MySQL 模式下物化视图查询改写](../../700.reference/300.database-object-management/100.manage-object-of-mysql-mode/600.manage-views-of-mysql-mode/200.manage-materialized-views-of-mysql-mode/500.materialized-views-rewrite-of-mysql-mode.md) 和 [Oracle 模式下物化视图查询改写](../../700.reference/300.database-object-management/200.manage-object-of-oracle-mode/500.manage-views-of-oracle-mode/200.manage-materialized-views-of-oracle-mode/500.materialized-views-rewrite-of-oracle-mode.md)。

### 物化视图查询加速方式

物化视图是数据库中用于提高查询性能的重要手段，通过预计算和存储查询结果，减少实时计算带来的性能开销。为了进一步优化物化视图的查询性能，可以考虑以下几种方法：

#### 物化视图数据的存储格式

根据实际应用场景选择行存、列存物化视图，可以加速对物化视图的查询。

* **行存物化视图适用场景**：当物化视图中的数据已经经过聚合，查询更多的是访问整个数据行。
* **列存物化视图适用场景**：对于数据量大且包含大量列的宽表, 基于物化视图的查询更多的数据分析和聚合等操作。

#### 使用主键物化视图

主键能够确保物化视图中的数据唯一性，并允许更高效的查找和更新操作。

#### 基于物化视图创建索引

为物化视图创建索引可以大幅提升查询性能。索引允许快速定位所需数据，减少全表扫描的需求。

物化视图是提高查询性能的重要工具，但在处理大规模数据时，查询性能可能会受到影响。为优化物化视图的查询性能，可通过调整物化视图的定义、添加索引或调整刷新策略等方式进一步加速查询。

## 创建物化视图示例

<main id="notice" type='notice'>
  <h4>注意</h4>
  <p>以下示例均是在 MySQL 模式下运行。</p>
</main>

### 创建源表

首先，我们需要创建源表，用于存储原始数据。在这个例子中，我们创建一个 `sales` 表和 `items` 表，其中包含了销售数据和商品信息。

1. 创建销售数据表 `sales`。

    ```sql
    CREATE TABLE sales (
    order_id   INT PRIMARY KEY,
    user_id    INT,
    item_id    INT,
    item_count INT,
    region     VARCHAR(100)
    );
    ```

2. 创建商品信息表 `items`。

    ```sql
    CREATE TABLE items (
    order_id       INT,
    product_id     INT,
    quantity       INT,
    price_per_item DECIMAL(10, 2) NOT NULL,
    pic_url        VARCHAR(1000),
    PRIMARY KEY (order_id, product_id)
    );
    ```

### 创建全量刷新物化视图

我们将创建一个基于 `sales` 表的物化视图。这个物化视图会按产品和地区汇总销售量，以便加速查询。

创建按产品和地区汇总销售量的物化视图 `mv_sales_summary`。

```sql
CREATE MATERIALIZED VIEW mv_sales_summary(PRIMARY KEY(item_id))
    REFRESH COMPLETE
    START WITH sysdate()
        NEXT sysdate() + interval 1 hour
    AS SELECT item_id, region, SUM(item_count) AS total_count
        FROM sales
        GROUP BY item_id, region;
```

在这个创建物化视图的示例中，我们指定了以下特性：

* PRIMARY KEY：为物化视图指定了主键。
* `REFRESH COMPLETE`：表示采用全量刷新方式。
* `START WITH sysdate() NEXT sysdate() + interval 1 hour`：定时刷新，每小时刷新一次。

### 创建增量刷新物化视图

对于一些数据变动较频繁的场景，可以使用增量刷新来提高刷新效率。在创建增量刷新的物化视图前，我们需要基于物化视图的基表创建物化视图日志（Mlog），然后才能成功创建增量刷新的物化视图。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>对于 V4.3.5 版本，从 V4.3.5 BP4 版本开始支持物化视图日志自动管理功能。如果开启自动管理 mlog，那么在创建增量刷新物化视图前，用户无需创建基表的 mlog，OceanBase 数据库会自动创建对应的 mlog 或更新已存在的 mlog 表定义使其包含新建物化视图依赖的列。详细信息，参见 <a href="../../700.reference/300.database-object-management/100.manage-object-of-mysql-mode/600.manage-views-of-mysql-mode/200.manage-materialized-views-of-mysql-mode/250.automatic-management-materialized-views-log-of-mysql-mode.md">物化视图日志自动管理（MySQL 模式）</a> 和 <a href="../../700.reference/300.database-object-management/200.manage-object-of-oracle-mode/500.manage-views-of-oracle-mode/200.manage-materialized-views-of-oracle-mode/250.automatic-management-materialized-views-log-of-oracle-mode.md">物化视图日志自动管理（Oracle 模式）</a>。</p>
</main>

更多关于物化视图日志的详细信息，参见 [MySQL 模式下物化视图日志](../../700.reference/300.database-object-management/100.manage-object-of-mysql-mode/600.manage-views-of-mysql-mode/200.manage-materialized-views-of-mysql-mode/200.materialized-views-log-of-mysql-mode.md) 和 [Oracle 模式下物化视图日志](../../700.reference/300.database-object-management/200.manage-object-of-oracle-mode/500.manage-views-of-oracle-mode/200.manage-materialized-views-of-oracle-mode/200.materialized-views-log-of-oracle-mode.md)。

接下来将展示增量刷新物化视图支持的三种查询场景示例：

#### 单表聚合

1. 在 `sales` 表上创建物化视图日志。

    ```sql
    CREATE MATERIALIZED VIEW LOG ON sales
        WITH PRIMARY KEY (item_id, item_count, region) INCLUDING NEW VALUES;
    ```

2. 创建单表聚合的增量刷新物化视图 `mv_sales_summary_fast`。

    ```sql
    CREATE MATERIALIZED VIEW mv_sales_summary_fast
        REFRESH FAST
        START WITH sysdate() NEXT sysdate() + interval 1 hour
        AS SELECT item_id, region, SUM(item_count) AS total_count, count(*)  as c, count(item_count) as count
            FROM sales
            GROUP BY item_id, region;
    ```

#### 多表连接

1. 在 `sales` 表上创建物化视图日志。

   1. （可选）删除 `sales` 表上的物化视图日志。

       如果没有在 `sales` 表上创建过物化视图日志，请跳过此步骤。

       ```sql
       DROP MATERIALIZED VIEW LOG ON sales;
       ```

   2. 在 `sales` 表上创建物化视图日志。

       ```sql
       CREATE MATERIALIZED VIEW LOG ON sales
           WITH PRIMARY KEY (user_id, item_id, item_count, region) INCLUDING NEW VALUES;
       ```

2. 在 `items` 表上创建物化视图日志。

    ```sql
    CREATE MATERIALIZED VIEW LOG ON items
        WITH PRIMARY KEY (price_per_item, pic_url) INCLUDING NEW VALUES;
    ```

3. 创建多表连接的增量刷新物化视图 `mv_sales_items_join`。

    ```sql
    CREATE MATERIALIZED VIEW mv_sales_items_join
        PARTITION BY HASH(order_id)
            PARTITIONS 10
        REFRESH FAST
        START WITH sysdate()
            NEXT sysdate() + interval 1 hour
        AS SELECT s.order_id AS order_id,
                s.user_id AS customer_id,
                s.item_id AS item_id,
                s.item_count AS quantity,
                s.region AS region,
                i.order_id AS i_id,
                i.product_id AS i_item_id,
                i.price_per_item AS price_per_item,
                i.pic_url AS pic_url
            FROM sales s JOIN items i
                ON s.order_id = i.order_id;
    ```

#### 多表连接聚合

1. 在 `sales` 表上创建物化视图日志。

   1. （可选）删除 `sales` 表上的物化视图日志。

       如果没有在 `sales` 表上创建过物化视图日志，请跳过此步骤。

       ```sql
       DROP MATERIALIZED VIEW LOG ON sales;
       ```

   2. 在 `sales` 表上创建物化视图日志。

       ```sql
       CREATE MATERIALIZED VIEW LOG ON sales
           WITH PRIMARY KEY (item_id, item_count, region) INCLUDING NEW VALUES;
       ```

2. 在 `items` 表上创建物化视图日志。

   1. （可选）删除 `items` 表上的物化视图日志。

       如果没有在 `items` 表上创建过物化视图日志，请跳过此步骤。

       ```sql
       DROP MATERIALIZED VIEW LOG ON items;
       ```

   2. 在 `items` 表上创建物化视图日志。

       ```sql
       CREATE MATERIALIZED VIEW LOG ON items
           WITH PRIMARY KEY (price_per_item) INCLUDING NEW VALUES;
       ```

3. 创建多表连接聚合的增量刷新物化视图 `mv_sales_item_join_group`。

    ```sql
    CREATE MATERIALIZED VIEW mv_sales_item_join_group
        REFRESH FAST
        START WITH sysdate()
            NEXT sysdate() + interval 1 hour
        AS SELECT s.item_id AS item_id,
                s.region AS region,
                SUM(s.item_count * i.price_per_item) AS sum_price,
                count(*) AS c,
                count(s.item_count * i.price_per_item) AS count
            FROM sales s JOIN items i
                ON s.order_id = i.order_id
            GROUP BY item_id, region;
    ```

### 创建实时物化视图

实时物化视图能够在数据变动时保证物化视图的查询结果与基表同步。由于实时物化视图依赖物化视图日志，所以同增量刷新的物化视图，在创建物化视图前需要先创建物化视图日志。

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>对于 V4.3.5 版本，从 V4.3.5 BP4 版本开始支持物化视图日志自动管理功能。如果开启自动管理 mlog，那么在创建实时物化视图前，用户无需创建基表的 mlog，OceanBase 数据库会自动创建对应的 mlog 或更新已存在的 mlog 表定义使其包含新建物化视图依赖的列。详细信息，参见 <a href="../../700.reference/300.database-object-management/100.manage-object-of-mysql-mode/600.manage-views-of-mysql-mode/200.manage-materialized-views-of-mysql-mode/250.automatic-management-materialized-views-log-of-mysql-mode.md">物化视图日志自动管理（MySQL 模式）</a> 和 <a href="../../700.reference/300.database-object-management/200.manage-object-of-oracle-mode/500.manage-views-of-oracle-mode/200.manage-materialized-views-of-oracle-mode/250.automatic-management-materialized-views-log-of-oracle-mode.md">物化视图日志自动管理（Oracle 模式）</a>。</p>
</main>

1. 在 `sales` 表上创建物化视图日志。

   1. （可选）删除 `sales` 表上的物化视图日志。

       如果没有在 `sales` 表上创建过物化视图日志，请跳过此步骤。

       ```sql
       DROP MATERIALIZED VIEW LOG ON sales;
       ```

   2. 在 `sales` 表上创建物化视图日志。

       ```sql
       CREATE MATERIALIZED VIEW LOG ON sales
           WITH PRIMARY KEY (item_id, item_count, region) INCLUDING NEW VALUES;
       ```

2. 创建实时物化视图 `mv_sales_summary_com`。

    ```sql
    CREATE MATERIALIZED VIEW mv_sales_summary_com
        REFRESH FORCE
        START WITH sysdate()
            NEXT sysdate() + interval 1 hour
        ENABLE ON QUERY COMPUTATION
        AS SELECT item_id,
                region,
                SUM(item_count) AS total_count,
                count(*) as c,
                count(item_count) as count
            FROM sales
            GROUP BY item_id, region;
    ```

在这个示例中，我们启用了 `ENABLE ON QUERY COMPUTATION`，使得物化视图在查询时实时更新，以确保获取到最新的数据，且物化视图的查询语句满足增量刷新物化视图的创建要求。

### 创建嵌套物化视图

在 ETL 过程中，嵌套物化视图用于将多个物化视图组合成一个更复杂的数据处理流程。这里，我们将创建两个物化视图：一个将销售信息与商品信息关联，另一个基于第一个物化视图进行更多的聚合。

1. 在 `sales` 表上创建物化视图日志。

   1. （可选）删除 `sales` 表上的物化视图日志。

       如果没有在 `sales` 表上创建过物化视图日志，请跳过此步骤。

       ```sql
       DROP MATERIALIZED VIEW LOG ON sales;
       ```

   2. 在 `sales` 表上创建物化视图日志。

       ```sql
       CREATE MATERIALIZED VIEW LOG ON sales
           WITH PRIMARY KEY (user_id, item_id, item_count, region) INCLUDING NEW VALUES;
       ```

2. 在 `items` 表上创建物化视图日志。

   1. （可选）删除 `items` 表上的物化视图日志。

       如果没有在 `items` 表上创建过物化视图日志，请跳过此步骤。

       ```sql
       DROP MATERIALIZED VIEW LOG ON items;
       ```

   2. 在 `items` 表上创建物化视图日志。

       ```sql
       CREATE MATERIALIZED VIEW LOG ON items
           WITH PRIMARY KEY (price_per_item,pic_url) INCLUDING NEW VALUES;
       ```

3. 创建销售信息与商品信息关联的物化视图 `mv1_sales_items_join`。

    ```sql
    CREATE MATERIALIZED VIEW mv1_sales_items_join
        REFRESH FAST
        START WITH sysdate()
            NEXT sysdate() + interval 1 hour
        AS SELECT
                s.order_id AS order_id,
                s.user_id AS customer_id,
                s.item_id AS item_id,
                s.item_count AS quantity,
                s.region AS region,
                i.order_id AS i_id,
                i.product_id AS i_item_id,
                i.price_per_item AS price_per_item,
                i.pic_url
            FROM sales s JOIN items i
                ON s.order_id = i.order_id;
    ```

4. 在物化视图 `mv1_sales_items_join` 上创建物化视图日志。

    ```sql
    CREATE MATERIALIZED VIEW LOG ON mv1_sales_items_join
        WITH PRIMARY KEY (region,quantity,price_per_item) INCLUDING NEW VALUES;
    ```

5. 基于物化视图 `mv1_sales_items_join` 创建物化视图 `mv2_join_sum`。

    ```sql
    CREATE MATERIALIZED VIEW mv2_join_sum
        REFRESH FAST
        START WITH sysdate()
            NEXT sysdate() + interval 1 hour
        AS SELECT
                region,
                sum(quantity * price_per_item) AS sum_price,
                count(*) as c,
                count(quantity * price_per_item) as count
            FROM mv1_sales_items_join
            GROUP BY region;
    ```

### 创建列存物化视图

假设我们希望在大数据量分析场景中提高查询效率，可以创建一个列存物化视图。通过列存储的方式，查询时只读取需要的列，显著减少磁盘 I/O。

1. 在 `sales` 表上创建物化视图日志。

   1. （可选）删除 `sales` 表上的物化视图日志。

       如果没有在 `sales` 表上创建过物化视图日志，请跳过此步骤。

       ```sql
       DROP MATERIALIZED VIEW LOG ON sales;
       ```

   2. 在 `sales` 表上创建物化视图日志。

       ```sql
       CREATE MATERIALIZED VIEW LOG ON sales
           WITH PRIMARY KEY (user_id, item_id, item_count, region) INCLUDING NEW VALUES;
       ```

2. 在 `items` 表上创建物化视图日志。

   1. （可选）删除 `items` 表上的物化视图日志。

       如果没有在 `items` 表上创建过物化视图日志，请跳过此步骤。

       ```sql
       DROP MATERIALIZED VIEW LOG ON items;
       ```

   2. 在 `items` 表上创建物化视图日志。

       ```sql
       CREATE MATERIALIZED VIEW LOG ON items
           WITH PRIMARY KEY (price_per_item,pic_url) INCLUDING NEW VALUES;
       ```

3. 创建列存物化视图 `wide_sales_column`。

    ```sql
    CREATE MATERIALIZED VIEW wide_sales_column
        WITH COLUMN GROUP(each column)
        REFRESH FAST
        START WITH sysdate()
            NEXT sysdate() + interval 1 hour
        AS SELECT
                s.order_id AS order_id,
                s.user_id AS customer_id,
                s.item_id AS item_id,
                s.item_count AS quantity,
                s.region AS region,
                i.order_id AS i_id,
                i.product_id AS i_item_id,
                i.price_per_item AS price_per_item,
                i.pic_url
            FROM sales s JOIN items i
                ON s.order_id = i.order_id;
    ```

在这个创建列存物化视图的示例中，我们指定了 `WITH COLUMN GROUP(each column)`，使得物化视图使用列存储格式。这对于 OLAP 场景非常有用，尤其是在大数据量和宽表查询中。

### 创建查询改写的物化视图

在这个示例中，指定 `ENABLE QUERY REWRITE` 创建了一个可以查询改写的全量刷新物化视图。

```sql
CREATE MATERIALIZED VIEW mv_sales_summary_select
    REFRESH COMPLETE
    START WITH sysdate()
        NEXT sysdate() + interval 1 hour
    ENABLE QUERY REWRITE
    AS SELECT item_id, region, SUM(item_count) AS total_count
        FROM sales
        GROUP BY item_id, region;
```

在这个示例中，指定 `ENABLE QUERY REWRITE` 以及 `ENABLE ON QUERY COMPUTATION` 创建了一个可以查询改写的实时物化视图。

1. 在 `sales` 表上创建物化视图日志。

   1. （可选）删除 `sales` 表上的物化视图日志。

       如果没有在 `sales` 表上创建过物化视图日志，请跳过此步骤。

       ```sql
       DROP MATERIALIZED VIEW LOG ON sales;
       ```

   2. 在 `sales` 表上创建物化视图日志。

       ```sql
       CREATE MATERIALIZED VIEW LOG ON sales
           WITH PRIMARY KEY (item_id, item_count, region) INCLUDING NEW VALUES;
       ```

2. 创建可以查询改写的实时物化视图 `mv_sales_summary_com_select`。

    ```sql
    CREATE MATERIALIZED VIEW mv_sales_summary_com_select
        REFRESH FAST
        START WITH sysdate() NEXT sysdate() + interval 1 hour
        ENABLE ON QUERY COMPUTATION
        ENABLE QUERY REWRITE
        AS SELECT
                item_id,
                region,
                SUM(item_count) AS total_sales,
                count(*)  as c,
                count(item_count) as count
            FROM sales
            GROUP BY item_id, region;
    ```

### 创建物化视图索引

为了进一步优化查询性能，可以在物化视图上创建索引。物化视图索引有助于加速对物化视图的查询，尤其是在涉及大量数据的情况下。

1. （可选）创建按产品和地区汇总销售量的物化视图 `mv_sales_summary`。

    如果已根据 **创建全量刷新物化视图** 中示例创建物化视图 `mv_sales_summary`，请跳过此步骤。

    ```sql
    CREATE MATERIALIZED VIEW mv_sales_summary(PRIMARY KEY(item_id))
        REFRESH COMPLETE
        START WITH sysdate()
            NEXT sysdate() + interval 1 hour
        AS SELECT item_id, region, SUM(item_count) AS total_count
            FROM sales
            GROUP BY item_id, region;
    ```

2. 在物化视图 `mv_sales_summary` 的 `region` 列上创建索引 `idx_mv_sales_summary`。

    ```sql
    CREATE INDEX idx_mv_sales_summary ON mv_sales_summary (region);
    ```

    这个索引可以加速在 `mv_sales_summary` 物化视图上的查询，尤其是基于 `region` 列的查询。

## 相关文档

* 有关物化视图的详细介绍和使用指导，参见 [物化视图概述（MySQL 模式）](../../700.reference/300.database-object-management/100.manage-object-of-mysql-mode/600.manage-views-of-mysql-mode/200.manage-materialized-views-of-mysql-mode/100.materialized-views-overview-of-mysql-mode.md) 和 [物化视图概述（Oracle 模式）](../../700.reference/300.database-object-management/200.manage-object-of-oracle-mode/500.manage-views-of-oracle-mode/200.manage-materialized-views-of-oracle-mode/100.materialized-views-overview-of-oracle-mode.md)。
* 有关刷新物化视图的详细介绍和使用指导，参见 [刷新物化视图（MySQL 模式）](../../700.reference/300.database-object-management/100.manage-object-of-mysql-mode/600.manage-views-of-mysql-mode/200.manage-materialized-views-of-mysql-mode/400.refresh-materialized-views-of-mysql-mode.md) 和 [刷新物化视图（Oracle 模式）](../../700.reference/300.database-object-management/200.manage-object-of-oracle-mode/500.manage-views-of-oracle-mode/200.manage-materialized-views-of-oracle-mode/400.refresh-materialized-views-of-oracle-mode.md)。
* 有关删除物化视图日志的详细介绍和使用指导，参见 [物化视图日志（MySQL 模式）](../../700.reference/300.database-object-management/100.manage-object-of-mysql-mode/600.manage-views-of-mysql-mode/200.manage-materialized-views-of-mysql-mode/200.materialized-views-log-of-mysql-mode.md) 和 [物化视图日志（Oracle 模式）](../../700.reference/300.database-object-management/200.manage-object-of-oracle-mode/500.manage-views-of-oracle-mode/200.manage-materialized-views-of-oracle-mode/200.materialized-views-log-of-oracle-mode.md)。
* 有关删除物化视图的详细介绍和使用指导，参见 [删除物化视图（MySQL 模式）](../../700.reference/300.database-object-management/100.manage-object-of-mysql-mode/600.manage-views-of-mysql-mode/200.manage-materialized-views-of-mysql-mode/700.delete-materialized-views-of-mysql-mode.md) 和 [删除物化视图（Oracle 模式）](../../700.reference/300.database-object-management/200.manage-object-of-oracle-mode/500.manage-views-of-oracle-mode/200.manage-materialized-views-of-oracle-mode/700.delete-materialized-views-of-oracle-mode.md)。
