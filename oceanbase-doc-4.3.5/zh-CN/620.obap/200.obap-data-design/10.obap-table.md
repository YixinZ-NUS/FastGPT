# 数据表概述

在 **OceanBase** 数据库中，表是最基础的数据存储单元。表包含了所有用户可以访问的数据，每个表由多行记录组成，而每行记录则包含多个列。每个表的设计和使用都需要依据业务需求进行合理规划，以确保系统的高效性和可扩展性。

## 表类型

OceanBase 数据库支持的表类型有分区表、复制表、主键表和无主键表、外部表等等。

* 分区表：OceanBase 数据库可以把普通的表的数据按照一定的规则划分到不同的区块内，将同一区块的数据物理上存储在一起。这种划分区块的表叫做分区表。OceanBase 数据库的基本分区策略包括范围（Range）分区、列表（List）分区和哈希（Hash）分区。
* 复制表：复制表是 OceanBase 数据库中的一种特殊表。这种表可以在任意一个“健康”的副本上读取到数据的最新修改。
* 主键表和无主键表：有主键表即表中包含主键的表；表中未指定主键的表称为无主键表。
* 外部表：数据库中的表数据存放在数据库的存储空间中，而外表的数据存储在外部存储服务中。
* 堆表：堆组织表模式，主键用于唯一性约束，而查询则依赖于主表，当用户数据按时间排序时，能够更有效地利用 Skip Index 提高查询效率。

在 **AP 场景** 下，OceanBase 支持多种表类型，除了 **TP 场景** 中常见的 **复制表**、**分区表**、**主键表** 和 **无主键表**，根据数据的存储方式，按行存储还是按列存储，还引入新维度的表类型：**列存表、行列混存表。**

* **列存表**：列存表将数据按列而非按行存储，能够显著提高分析型查询的性能，尤其适用于大数据量和频繁进行聚合分析的场景。详情请参见：[列存表架构](../../700.reference/100.oceanbase-database-concepts/900.storage-architecture/200.data-storage/320.columnstore-engine.md)。

* **行列混存表**：按行存储和按列存储的数据都分别存储了一份，系统会自动根据查询语句判断选择行存还是列存查询性能更优，适用于交易类业务和分析类业务兼顾的场景。

## 表更新模式

OceanBase 数据库支持建表时指定数据的写入和查询模式。建表时，通过 `CREATE TABLE` 语句中的参数 `merge_engine` 选择 **delete_insert 更新模式** 和 **partial_update 更新模式** ，这两种模式是针对不同业务场景设计的数据更新策略。

+ **delete_insert（全列更新模式）**

  以 **查询性能优先**，通过“Merge-On-Write”机制将 `UPDATE` 操作转化为全列的 `DELETE` 和 `INSERT` 记录，确保每行数据包含完整的列值。这种模式显著提升了复杂查询和批处理的效率（如分析型任务），但增量数据需要额外存储空间，适用于 **增量数据频繁且需要快速分析** 的场景。

+ **partial_update（部分更新模式）**

  仅记录修改的列的值，避免冗余存储。查询时需合并多份数据以获取最新值，性能相对较低，但更适合 **高频更新但查询需求低** 的场景（如 OLTP 类业务），或对存储成本敏感的环境。

| **特性类别** | **delete_insert 更新模式** | **partial_update 更新模式** |
| --- | --- | --- |
| **存储方式** | 每次更新在 SSTable 中写入两行（`DELETE`和`INSERT`），包含全列数据。 | 每次更新仅记录修改的列的值，存储空间更节省。 |
| **查询效率** | <ul><li>查询时提前在memtable/sstable中计算下压过滤算子。</ul></li><ul><li>若增量数据过滤结果不包含对基线数据更新，则可以分别批处理基线与增量数据；如果过滤结果包含对基线数据更新，合并增量/基线的记录获取最新值进行投影。</ul></li> | 查询时需合并多个 Memtable/SSTable 的记录，以获取主键的最新值，可能影响性能。  <br/> 适用于对存储成本敏感且更新操作频繁的场景。 |
| **适用场景** | 增量数据比例较高，需要频繁执行复杂查询或批处理分析的场景。    | 高频更新但查询需求较低的场景。   |

更多内容，参见 [MySQL 模式下的创建表](../../700.reference/300.database-object-management/100.manage-object-of-mysql-mode/200.manage-tables-of-mysql-mode/200.create-a-table-for-mysql-tenant-of-mysql-mode.md)和 [Oracle 模式下的创建表](../../700.reference/300.database-object-management/200.manage-object-of-oracle-mode/100.manage-tables-of-oracle-mode/200.create-a-table-for-oracle-tenant-of-oracle-mode.md)。

## 数据分布

OceanBase 数据库通过创建分区表将数据分布在不同的分区，不同分区数据可以分布到不同的机器，查询时利用分区裁剪能够减少数据的扫描量，且能利用多机的资源提升查询性能。默认情况下，不同表之间的数据是随机分布的，没有直接关系，通过负载均衡可以将一个表的数据比较均匀的分布在整个集群。

在分布式 AP 系统中，表的数据量通常比较多。不同表的数据随机分布的情况下，表连接时数据传输的开销往往不可忽视。利用[表组](../../700.reference/300.database-object-management/100.manage-object-of-mysql-mode/400.manage-table-groups-of-mysql-mode/100.about-table-groups-of-mysql-mode.md)（Table Group）可以让分区方式相同的分区表数据按照特定的规则对齐，让具有关联关系的数据聚集在同一台机器上，使得这些表连接时能够使用 Partition Wise Join 的方式执行，能够有效降低连接场景下的数据传输的开销，提升性能。

![](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer/ap/table-group.png)

OceanBase支持一级分区表和二级分区表，支持 RANGE 分区、LIST 分区、HASH 分区这三种分区类型。

OceanBase提供三种属性的表组：

1. NONE：表组内的所有表的所有分区均聚集在同一台机器上。

2. PARTITION：表组内每一张表的数据按一级分区打散，如果是二级分区表，则一级分区下的所有二级分区聚集在一起。

3. ADAPTIVE：表组内每一张表的数据根据自适应方式打散，如果表组内的表是一级分区表，则按一级分区打散；如果表组内的表是二级分区表，则按每个一级分区下的二级分区打散。

更多信息，参见[数据分布](../../600.manage/300.replica-management/400.data-distribution.md)、[MySQL 模式下的表组](../../700.reference/300.database-object-management/100.manage-object-of-mysql-mode/400.manage-table-groups-of-mysql-mode/100.about-table-groups-of-mysql-mode.md)和 [Oracle 模式下的表组](../../700.reference/300.database-object-management/200.manage-object-of-oracle-mode/300.manage-table-groups-of-oracle-mode/100.about-table-groups-of-oracle-mode.md)。

## 索引类型

索引是提高查询性能的关键组件。OceanBase 在 AP 场景中通过支持多种索引类型，为用户提供了灵活且高效的数据检索方式。以下是一些常见的索引类型及其应用场景：

* **局部索引**：局部索引是针对单一分区建立的索引，适用于需要进行数据局部查询的场景。当数据被严格划分为多个分区时，局部索引能够显著减少查询时的数据扫描范围，从而提高查询效率。
* **唯一索引**：唯一索引确保数据列中的每个值都是唯一的。通过在某些列上创建唯一索引，数据库能够有效防止数据重复，并加速查询过程。
* **非唯一索引**：非唯一索引与唯一索引不同，它不要求列中的所有值都必须唯一。主要用于加速数据查询，尤其在查找符合特定条件的多条记录时，能够显著提高检索效率。
* **全文索引**：OceanBase 支持了兼容 MySQL 的全文搜索能力，通过预先处理文本内容，建立关键词索引，有效提升全文搜索效率。更多有关全文索引的详细信息，请参见 [全文索引](../../700.reference/100.oceanbase-database-concepts/400.database-objects/200.database-objects-of-mysql-mode/300.index-of-oracle-mode/320.full-text-indexes-of-mysql-mode-in-concepts.md)。
* **JSON 多值索引**：OceanBase数据库的 MySQL 模式支持多值索引功能，这对于 JSON 文档和其他集合数据类型特别有用。利用这项功能可以在数组或集合上创建索引，从而提高基于 JSON 数组元素进行搜索的查询效率。更多有关多值索引的详细信息，请参见 [多值索引](../../700.reference/300.database-object-management/100.manage-object-of-mysql-mode/500.manage-indexes-of-mysql-mode/200.create-an-index-of-mysql-mode.md)。
* **空间索引**：空间索引用于优化地理空间数据的查询效率，广泛应用于地理信息系统（GIS）和位置相关的服务。在这些应用中，空间索引可以快速检索地理坐标范围内的数据信息，为位置服务提供强有力的支持。
* **列存索引**：在 HTAP（Hybrid Transactional and Analytical Processing）场景中，OceanBase 数据库从 V4.3.0 版本开始支持创建表时指定表的存储格式为列存，索引和数据表一样都是一张表，所以也支持设置索引表中的数据以列存形式存储。列存索引依据列而非行进行存储，能够显著提升分析类查询的性能，特别是在处理大规模数据时，能够大幅缩短数据检索和分析的时间，从而实现实时分析。更多有关列存的详细信息，请参见 [列存](../../700.reference/100.oceanbase-database-concepts/900.storage-architecture/200.data-storage/320.columnstore-engine.md)。

更多关于索引的详细信息，参见[MySQL 模式选的索引简介](../../700.reference/100.oceanbase-database-concepts/400.database-objects/200.database-objects-of-mysql-mode/300.index-of-oracle-mode/100.index-overview-of-mysql-mode.md)和[Oracle 模式选的索引简介](../../700.reference/100.oceanbase-database-concepts/400.database-objects/100.database-objects-of-oracle-mode/300.index-of-oracle-mode/100.the-index-overview-of-oracle-mode.md)。

## 数据类型

在创建和使用表之前，数据库管理员需要根据业务需求合理规划表结构和数据类型。为确保数据存储的高效性和查询的优化，管理员应遵循以下原则：

* **规范化表结构**：通过合理设计表结构，确保数据冗余最小化，提升查询效率。
* **选择合适的 SQL 数据类型**：为每个列选择最适合的 SQL 数据类型，以减少存储空间并提高查询速度。

常见的 SQL 数据类型包括：

* **基础数据类型**：如 `INT`、`VARCHAR`、`DATE` 等。
* **复杂数据类型**：如 `JSON`、`ARRAY`、`BITMAP` 等，适用于存储更复杂的数据结构。

详细的 SQL 数据类型描述，请参见：

* [MySQL 模式数据类型](../../700.reference/100.oceanbase-database-concepts/400.database-objects/200.database-objects-of-mysql-mode/200.table-of-mysql-mode/200.data-type-of-mysql-mode/100.data-types-overview-of-mysql-mode.md)
* [Oracle 模式数据类型](../../700.reference/100.oceanbase-database-concepts/400.database-objects/100.database-objects-of-oracle-mode/200.table-of-oracle-mode/200.data-type-of-oracle-mode/100.data-type-overview-of-oracle-mode.md)

## 视图

OceanBase 数据库支持普通视图和物化视图。

* 普通视图（Standard Views）：普通视图也叫非物化视图，是最常见的视图类型。它们仅仅存储定义视图的 SQL 查询，而不存储查询结果。
* 物化视图（Materialized Views）：物化视图与普通视图不同，它们在物理存储上保留了查询的结果。OceanBase 数据库支持异步物化视图，即基础表数据变动时，并不会立即更新物化视图，保证了基表 DML 操作的执行性能。参见 [MySQL 模式下的物化视图](../../700.reference/300.database-object-management/100.manage-object-of-mysql-mode/600.manage-views-of-mysql-mode/200.manage-materialized-views-of-mysql-mode/100.materialized-views-overview-of-mysql-mode.md) 和  [Oracle 模式下的物化视图](../../700.reference/300.database-object-management/200.manage-object-of-oracle-mode/500.manage-views-of-oracle-mode/200.manage-materialized-views-of-oracle-mode/100.materialized-views-overview-of-oracle-mode.md)。

## 创建数据表示例

创建包含分区、列存和行存索引的表

```sql
CREATE TABLE salesdata (
    sale_id INT,
    product_id INT NOT NULL,
    saledate DATE NOT NULL,
    saledate_int INT, -- 定义为普通列
    quantity INT,
    price DECIMAL(10, 2),
    customer_id INT,
    PRIMARY KEY (sale_id, saledate_int) -- 主键可以包括普通列
)
PARTITION BY RANGE COLUMNS (saledate_int) (
    PARTITION p2023_q1 VALUES LESS THAN (202304),
    PARTITION p2023_q2 VALUES LESS THAN (202307),
    PARTITION p2023_q3 VALUES LESS THAN (202310),
    PARTITION p2023_q4 VALUES LESS THAN (202401)
)
WITH COLUMN GROUP(each column);

CREATE INDEX idx_product_id ON salesdata(product_id);
CREATE INDEX idx_customer_id ON salesdata(customer_id);
```

1. **分区**：`salesdata` 表使用 **范围分区**（RANGE）。

   * `PARTITION BY RANGE COLUMNS (saledate_int)`：通过 `saledate_int` 列进行分区。

   * 定义了四个分区：

     - `p2023_q1` 分区包含 `202304` 之前的所有数据（即 2023 年第一季度）。
     - `p2023_q2`、`p2023_q3` 和 `p2023_q4` 分区涵盖了 2023 年的第二、第三和第四季度的数据。

2. **列存**：通过 `WITH COLUMN GROUP(each column);` 指定了 **列存存储**。这些列的数据将采用列存储方式，适合大规模的数据分析场景。

3. **行存索引**：分别在 `product_id` 和 `customer_id` 列上，创建了两个索引 `idx_product_id` 和 `idx_customer_id`。行存索引可以加速基于具体列的查询，尤其是用于高频次的小查询。

当创建并使用列存储表时，如果你导入了大量数据，那么需要注意执行一次 合并操作 以改善读取性能，并且进行 统计信息收集，调整执行策略。

* **合并操作**：在批量导入数据之后，建议进行一次合并操作。这有助于改善读取性能，因为合并操作会整理片段化数据，使其在物理存储上更连续，从而减少读取时的磁盘 I/O。导入数据后，在租户内触发一次合并操作，以确保所有数据都被合并到基线层，操作请参考 [MAJOR 和 MINOR（MySQL 模式）](../../700.reference/500.sql-reference/100.sql-syntax/200.common-tenant-of-mysql-mode/600.sql-statement-of-mysql-mode/1500.alter-system-freeze-of-mysql-mode.md) 和 [MAJOR 和 MINOR（Oracle 模式）](../../700.reference/500.sql-reference/100.sql-syntax/300.common-tenant-of-oracle-mode/900.sql-statement-of-oracle-mode/100.ddl-of-oracle-mode/4600.alter-system-major-freeze-of-oracle-mode.md)。

* **统计信息收集**：合并操作完成之后，推荐进行统计信息的收集。这对于优化器生成有效的查询计划和执行策略是非常重要的。执行 [GATHER_SCHEMA_STATS（MySQL 模式)](../../700.reference/600.pl-reference/200.pl-mysql/1000.pl-system-package-mysql/15900.dbms-stats-mysql/1800.gather-schema-stats-mysql.md) /[GATHER_SCHEMA_STATS（Oracle 模式)](../../700.reference/600.pl-reference/300.pl-oracle/1400.pl-system-package-oracle/15900.dbms-stats-oracle/1800.gather-schema-stats-oracle.md)查看对所有表收集统计信息，并可以通过视图 [GV$OB_OPT_STAT_GATHER_MONITOR（MySQL 模式）](../../700.reference/700.system-views/400.system-view-of-mysql-mode/300.performance-view-of-mysql-mode/6100.gv_ob_opt_stat_gather_monitor-of-mysql-mode.md) 和 [GV$OB_OPT_STAT_GATHER_MONITOR（Oracle 模式）](../../700.reference/700.system-views/500.system-view-of-oracle-mode/300.performance-view-of-oracle-mode/2000.gv-ob_opt_stat_gather_monitor-of-oracle-mode.md) 监控收集进度。

需要注意的是，随着列存表数据量的增加，合并操作的速度可能会下降。
