# 优化存储结构与查询性能的策略的最佳实践

在数据库系统的设计与优化中，数据表设计是一项至关重要的工作。合理的设计不仅能确保数据的完整性和一致性，还能大幅提升查询性能、存储效率以及系统的可扩展性。随着数据量的增长和查询模式的复杂化，如何科学地设计数据表，选择合适的存储结构和索引策略，成为了数据库优化的核心问题。

本文将结合选择表的存储格式、单表无主键列存表、分区设计、主键设计、HTAP 场景下如何使用索引等方面，向您介绍数据表设计的最佳实践。

## 选择表的存储格式

OceanBase支持表数据按列存储以及行存列存冗余存储，可以根据业务场景来选择合适的数据存储格式。

+ **列存适用场景**：业务只是单纯的 OLAP 分析类业务，选择列式存储即可。
+ **行存列存混存存储使用场景**：如果业务是 HTAP 类场景，既包含 OLAP 分析类业务，也包含 OLTP 事务型业务，在保证分析查询性能的情况下也期望对点查性能有所保证，可以设置行存列存冗余存储。

通过租户级配置项 [default_table_store_format](../../../700.reference/800.configuration-items-and-system-variables/100.system-configuration-items/400.tenant-level-configuration-items/2200.default_table_store_format.md) 配置表的默认存储格式。

```sql
-- 设置租户下表的默认存储格式为列存
ALTER SYSTEM SET default_table_store_format = "column";

-- 设置租户下表的默认存储格式为行存列存冗余
ALTER SYSTEM SET default_table_store_format = "compound";
```

## 选择单表无主键列存表

数据仓库或在线分析处理（OLAP）场景下，业务数据表中的数据量非常庞大，且大部分查询只涉及某些列，在业务没有特殊要求的情况下，如保证数据唯一性、避免数据重复写入或者需要进行事务性更新或插入操作等，创建无主键列存表会更高效：

+ 数据导入：由于数据不需要按照主键来排序，大数据的导入性能相比于有主键表更快速。
+ 减少主键的管理成本。

```sql
show parameters like "%store_format%";

  CREATE TABLE customer (
  user_id bigint NOT NULL,
  login_time timestamp NOT NULL,
  customer_name varchar(100) NOT NULL,    -- 假设客户名称最长为100个字符
  phone_num bigint NOT NULL,               -- 电话号码作为 bigint 存储
  city_name varchar(50) NOT NULL,          -- 假设城市名称最长为50个字符
  sex int NOT NULL,                        -- 性别使用 int 存储（例如 0 表示女，1 表示男）
  id_number varchar(18) NOT NULL,          -- 假设身份证号码最长为18个字符
  home_address varchar(255) NOT NULL,      -- 假设家庭住址最长为255个字符
  office_address varchar(255) NOT NULL,    -- 假设办公地址最长为255个字符
  age int NOT NULL                         -- 年龄使用 int 存储
);
```

## 选择数据表分区

分区技术通过将一个大表分割成多个更小、更易管理的子表，从而在查询和数据管理方面提供了巨大的优势。分区通常按照数据的某个字段进行，例如时间、地域等。

### 分区场景

+ **数据量过大**：当数据表的记录数达到亿级甚至更高时，单表操作会导致查询性能下降，甚至引发数据库的资源瓶颈。
+ **查询频繁依赖某些字段**：例如，时间字段是常用的查询条件之一，按时间分区能够提高时间相关查询的效率。

### 分区策略选择

+ **Range 分区**：适合按时间范围进行分区，尤其是当数据按时间生成，并且通常按时间过滤时。
+ **Hash 分区**：通过哈希算法将数据均匀分配到多个分区，适用于无明显查询模式的场景。
+ **List 分区**：适用于离散的数据，如按地区分区。

在 AP 场景里，通常涉及多个维度的分析查询，如果没有一个维度可以将数据进行分区且适用于各查询，而又需要分区将数打散分布到多台机器利用分布式节点计算的能力，此时可按如下方式选择分区键做 Hash 分区，尽量将用户数据均匀打散：

+ NDV 远大于分区数；
+ 此列数据没有倾斜，或只有少量倾斜，例如：交易ID、用户ID或者自增列等；
+ 优先选择整形列，时间列，再考虑 varchar/char；
+ 优先选择高频率出现查询条件的字段，方便分区裁剪；

```sql
CREATE TABLE customer (
    user_id BIGINT NOT NULL,
    login_time TIMESTAMP NOT NULL,
    customer_name VARCHAR(100) NOT NULL,
    phone_num BIGINT NOT NULL,
    city_name VARCHAR(50) NOT NULL,
    sex INT NOT NULL,
    id_number VARCHAR(18) NOT NULL,
    home_address VARCHAR(255) NOT NULL,
    office_address VARCHAR(255) NOT NULL,
    age INT NOT NULL
)
PARTITION BY HASH(user_id) PARTITIONS 128;
```

对于分布式数据库, 多个表由于划分分区使得数据可能会分布在不同的机器上, 这样在执行 Join 查询等复杂操作时就需要涉及跨机器的通信，可以利用表组的能力来避免跨机访问带来的查询性能不优的问题。

创建一个 sharding 属性为 ADAPTIVE 的表组 tg1，和两个一级分区表 customer、sales。当两个分区表连接且连接条件中包含分区键的连接条件时，可以使用 Partition Wise Join 的方式提升性能。

```sql
CREATE TABLEGROUP tg1 SHARDING = 'ADAPTIVE';

-- 顾客信息表
CREATE TABLE customer (
    user_id BIGINT NOT NULL,
    login_time TIMESTAMP NOT NULL,
    customer_name VARCHAR(100) NOT NULL,
    phone_num BIGINT NOT NULL,
    city_name VARCHAR(50) NOT NULL,
    sex INT NOT NULL,
    id_number VARCHAR(18) NOT NULL,
    home_address VARCHAR(255) NOT NULL,
    office_address VARCHAR(255) NOT NULL,
    age INT NOT NULL)
  TABLEGROUP = tg1
  PARTITION BY HASH(user_id) PARTITIONS 128;
-- 交易表
CREATE TABLE sales (
  order_id INT,
  user_id INT primary key,
  item_id INT,
  item_count INT)
  TABLEGROUP = tg1
  PARTITION BY HASH(user_id) PARTITIONS 128;


SELECT * FROM customer, sales where customer.user_id = sales.user_id;
```

如果业务数据量很大，且查询特点清晰，可以创建二级分区，来进一步利用分区裁剪的能力加速查询。AP的查询特点通常是查询最近一天或者一个月的数据，通常是带有时间属性的查询，所以二级分区键建议选择时间类型的字段或时间函数，并且选择range分区方便做范围查询。

```sql
CREATE TABLE customer (
    user_id BIGINT NOT NULL,
    login_time TIMESTAMP NOT NULL,
    customer_name VARCHAR(100) NOT NULL,
    phone_num BIGINT NOT NULL,
    city_name VARCHAR(50) NOT NULL,
    sex INT NOT NULL,
    id_number VARCHAR(18) NOT NULL,
    home_address VARCHAR(255) NOT NULL,
    office_address VARCHAR(255) NOT NULL,
    age INT NOT NULL,
    -- 主键包含所有分区键（user_id 和 age）
    PRIMARY KEY (user_id, age, login_time)
)
-- 主分区：按 user_id 哈希分布
PARTITION BY HASH(user_id)
PARTITIONS 128
SUBPARTITION BY RANGE(age)
SUBPARTITION TEMPLATE (
    -- 示例分区：按年龄段划分
    SUBPARTITION p_youth VALUES LESS THAN (25),      -- 年龄 <25
    SUBPARTITION p_adult VALUES LESS THAN (40),      -- 25 ≤ age <40
    SUBPARTITION p_middle_aged VALUES LESS THAN (60),-- 40 ≤ age <60
    SUBPARTITION p_senior VALUES LESS THAN (MAXVALUE)-- 60及以上
);
```

## 设计主键

主键设计是关系型数据库表设计中的核心部分，在OceanBase中主键不仅确保了数据的唯一性，由于数据是按主键排序，所以对于范围类的查询可以利用主键优化性能。不同的主键设计方案适用于不同的业务场景。

### 加主键的场景

+ **保证数据唯一性**：当表中的数据需要确保每条记录的唯一性时，必须设计主键。
+ **提高查询效率**：主键能够帮助优化器生成更高效的查询计划，尤其是当数据查询依赖于主键时，建议将查询一定会携带的字段作为主键字段，这样可以利用主键来提升查询性能；

```sql
CREATE TABLE customer (
    user_id BIGINT NOT NULL,
    login_time TIMESTAMP NOT NULL,
    customer_name VARCHAR(100) NOT NULL,
    phone_num BIGINT NOT NULL,
    city_name VARCHAR(50) NOT NULL,
    sex INT NOT NULL,
    id_number VARCHAR(18) NOT NULL,
    home_address VARCHAR(255) NOT NULL,
    office_address VARCHAR(255) NOT NULL,
    age INT NOT NULL,
    -- 主键包含所有分区键（user_id 和 age）
    PRIMARY KEY (user_id, age, login_time)
)
-- 主分区：按 user_id 哈希分布
PARTITION BY HASH(user_id)
PARTITIONS 128
SUBPARTITION BY RANGE(age)
SUBPARTITION TEMPLATE (
    -- 示例分区：按年龄段划分
    SUBPARTITION p_youth VALUES LESS THAN (25),      -- 年龄 <25
    SUBPARTITION p_adult VALUES LESS THAN (40),      -- 25 ≤ age <40
    SUBPARTITION p_middle_aged VALUES LESS THAN (60),-- 40 ≤ age <60
    SUBPARTITION p_senior VALUES LESS THAN (MAXVALUE)-- 60及以上
);
```

说明：

1. 有主键表的数据导入性能劣于无主键表，因为表数据会根据主键来进行排序。
2. 有主键分区表的主键需要包含所有的分区键。

## HTAP 场景下优化查询

OceanBase 提供多种手段支持 HTAP（混合事务与分析处理）场景，可同时满足事务型（TP）和分析型（AP）业务需求。OceanBase 除了数据表支持行存、列存以及行存列存冗余的存储格式，索引表也支持指定存储格式。我们可以结合行存和列存的优势来处理对应场景。

关于如何创建列存索引的操作说明，参见 [MySQL 模式下创建列存索引](../../../700.reference/300.database-object-management/100.manage-object-of-mysql-mode/500.manage-indexes-of-mysql-mode/200.create-an-index-of-mysql-mode.md) 和 [Oracle 模式下创建列存索引](../../../700.reference/300.database-object-management/200.manage-object-of-oracle-mode/400.manage-indexes-of-oracle-mode/200.create-an-index-of-oracle-mode.md)。

### 行存基表+列存索引

适用场景：以事务型业务为主，同时存在一定的分析型查询需求，且表为大宽表。  
优化策略：创建列存索引来提升分析类查询性能。

+ 优点：只对部分列进行冗余存储，且是列存格式。
+ 缺点：需要根据查询语句的情况识别合适的字段创建列存索引，且数据写入时需要维护索引表数据，写入性能相对差一点。

### 列存基线+行存索引

适用场景：以分析型业务为主，但需支持高效的简单查询（如点查）。  
优化策略：创建索引时为了避免回表可以创建覆盖索引。

+ 优点：只冗余存储部分列数据，目前不支持在线将列存表转换为行存表或行列冗余表，可以通过添加行存索引来达到优化查询的目的。
+ 缺点：需要根据查询语句的情况识别合适的字段创建行存索引，且数据写入时需要维护索引表数据，写入性能相对差一点。

### 行存列存冗余：行存基线+列存基线

适用场景：需要同时兼顾事务型和分析型查询，且查询方式多样化。  
优化策略：可以直接冗余存储两份基线数据，让系统根据查询特点生成合适的执行计划，查询逻辑默认范围扫描走列存模式,  点查回退到行存模式。

+ 优点：不需要分析业务的查询特点， 分析类查询结果是强一致的。
+ 缺点：会占用更多的磁盘空间，且执行计划容易出现不准的情况。

### 列存副本：2F1A1C

适用场景：典型的 HTAP 业务，不希望分析型查询影响事务型业务，同时可以接受分析查询的弱一致性读。  
优化策略：可以利用列存副本的隔离特点，做到 AP/TP 业务相互不影响的情况下执行业务的查询；

+ 优点：
    1. 不用多副本存储冗余的数据，节省磁盘空间占用。
    2. AP/TP业务相互隔离。
    3. 数据写入性能不受影响。
+ 缺点：
    1. 列存副本是弱一致性读。
    2. 需要有独立的访问入口。
