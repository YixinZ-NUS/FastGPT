# OceanBase 数据加工

数据加工是指对原始数据进行一系列处理和转换，使其更适合特定的分析、应用或展示的过程。通常包括数据清洗、数据转换、数据集成、数据聚合、数据富化、数据筛选、数据标注等操作，将原始的、杂乱无章的数据转化为结构化、高质量且易于使用的数据集，在此基础上可以提供更简单、更高性能的查询分析能力。

一条高效的数据加工任务的执行，依赖于高性能的原始数据读取、丰富的函数、高效的查询分析、高性能数据写入能力，也依赖于一些贴合业务特征的周边特性。

本文会重点介绍下 OceanBase 有哪些特性有助于数据加工类业务。

## `INSERT OVERWRITER SELECT` 操作

`INSERT OVERWRITER SELECT` 是一种用于将查询结果插入到目标表中的操作，同时覆盖目标表中的现有数据。它主要用于数据清洗和转换过程中，能够以高效的方式将加工后的数据批量插入到数据库。该操作保证原子性，即执行过程中遇到任何异常，操作会整体回滚。

### 使用场景

+ 在需要批量导入数据并覆盖目标表的情况下，`INSERT OVERWRITER SELECT` 提供了一种简便的方法。
+ 适用于清洗数据时，目标表已经存在数据，且希望用新数据替换旧数据。
+ 源表可以为数据库内部表，也可以为外部表。

### 语法示例

```sql
INSERT [/*+PARALLEL(N)*/] OVERWRITE table_name [(list_of_columns)] [PARTITION (partition_name, ...)] select_stmt;
```

### 注意事项

+ 使用此操作时需要谨慎，因为它会删除目标表或分区中的所有数据，确保业务已经备份数据以防误操作。
+ 确保 `SELECT` 查询返回的数据格式与目标表结构一致，以避免数据插入失败。
+ INSERT INTO SELECT 和 INSERT OVERWRITE SELECT 的区别在于，INSERT INTO SELECT 不会对目标表或分区做插入前的数据清除，加工后的数据会增量写入目标表。
+ 请勿同时通过`INSERT OVERWRITE SELECT`和实时写入方式（INSERT INTO、REPLACE INTO、DELETE、UPDATE）向同一个表中写入数据，否则实时写入的数据会被丢弃。

如果想要了解更多操作事项，参见[MySQL 模式下使用 INSERT OVERWRITE SELECT 语句插入数据](../../300.develop/100.application-development-of-mysql-mode/400.write-data-of-mysql-mode/100.insert-data-of-mysql-mode-in-develop.md)和 [Oracle 模式下使用 INSERT OVERWRITE SELECT 语句插入数据](../../300.develop/200.application-development-of-oracle-mode/400.write-data-of-oracle-mode/100.insert-data-of-oracle-mode-in-develop.md)。

## 作业提交 (`Submit Job`)

在 OceanBase 数据库中，作业提交功能允许用户提交并执行复杂的数据加工任务。这些任务可以是数据批处理、ETL（提取、转换、加载）作业或其他后台数据处理工作。在使用 `INSERT INTO` 或 `INSERT OVERWRITE SELECT` 导入数据时，默认是同步执行流程，当数据量较大时，可能需要会话长时间保活。因此，在数据量较大的场景，推荐通过异步方式提交数据导入任务。

### 使用场景

+ 定期执行复杂的数据处理操作，如批量数据导入、数据清洗、报表生成等。
+ 大规模数据迁移或转换任务的调度。

### 提交作业示例

```sql
-- 提交作业
SUBMIT JOB INSERT OVERWRITE test
SELECT ex1.c1,t2.c2,sum(ex1.c3)
FROM ex1,t2
WHERE ex1.id = t2.id
GROUP BY ex1.c1,t2,c2;
-- 查询异步任务状态
SHOW JOB STATUS WHERE job='job_id';
```

作业通常包括多个步骤，如数据的提取、转换和加载，确保整个数据处理流程的自动化执行。

## 定时任务

定时任务用于按照设定的时间表定期执行指定的作业。通过定时任务，可以自动化数据加工流程，减少人工维护成本。

### 使用场景

+ 定期清理过期数据、生成报表、同步数据等。
+ 在特定时间或周期性任务中自动执行数据处理作业。

### 创建定时任务示例

- **MySQL 模式**：通过 `Event Scheduler` 命令进行定时任务创建。

```sql
-- 创建定时任务
CREATE EVENT myevent
    ON SCHEDULE AT '2024-12-26 00:00:00' + INTERVAL 1 DAY
    DO
      INSERT INTO test SELECT * FROM ex_test WHERE date_key = curdate();

-- 查看定时任务
SELECT * FROM information_schema.events WHERE event_name='myevent';
```

- **Oracle 模式**：通过 `DBMS_SCHEDULER` 系统包进行定时任务创建。

```sql
-- 创建定时任务
BEGIN
    DBMS_SCHEDULER.CREATE_JOB(
        job_name         => 'myscheduler',                      -- 作业名称
        job_type         => 'STORED_PROCEDURE',                 -- 作业类型为存储过程
        job_action       => 'data_cleaning',                    -- 作业执行的存储过程
        number_of_argument => 0,                                -- 无需参数
        start_date       => SYSDATE,                            -- 作业开始执行的时间
        repeat_interval  => 'FREQ=DAILY; INTERVAL=1',           -- 每天执行一次
        end_date         => NULL,                               -- 不设置结束时间，作业会一直执行
        job_class        => 'DEFAULT_JOB_CLASS',                -- 作业类别为默认
        enabled          => TRUE,                               -- 启用作业
        auto_drop        => TRUE,                               -- 作业完成后自动删除
        comments         => '每日定时清洗并转换数据',               -- 作业注释
        credential_name  => NULL,                               -- 无凭证
        destination_name => NULL,                               -- 无目标数据库
        max_run_duration => 0                                   -- 无最大运行时长限制
    );
    COMMIT;
END;
/
-- 查看定时任务
SELECT * FROM DBA_SCHEDULER_JOBS WHERE job_name = 'myscheduler';
SELECT * from DBA_SCHEDULER_JOB_RUN_DETAILS WHERE job_name ='myscheduler';
```
