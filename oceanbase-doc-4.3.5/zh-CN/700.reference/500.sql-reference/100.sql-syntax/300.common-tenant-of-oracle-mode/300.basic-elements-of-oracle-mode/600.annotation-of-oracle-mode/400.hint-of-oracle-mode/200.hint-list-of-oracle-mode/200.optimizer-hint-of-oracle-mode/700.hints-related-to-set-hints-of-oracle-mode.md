| Description   |                 |
|---------------|-----------------|
| keywords      |                 |
| dir-name      |Set Hint         |
| dir-name-en   |                 |
| tenant-type   | Oracle Mode     |
|machine-translation||

# Optimized Hint 类型下的 Set Hint

控制集合操作相关行为的 Hint。

由于集合操作子句没有直接添加 hint 的位置，该篇介绍的 Hint 必须使用 qb name 指定其作用的集合操作对象，详细用法见各 hint 举例。

| Hint 类型                        | 描述                                                  |
|----------------------------------|-------------------------------------------------------|
|`PQ_SET`                          | 控制集合运算的分布式执行方式。                             |
|`USE_HASH_SET`                    | 启用优化器在集合运算中使用 HASH 方法。它的反向操作是 `NO_USE_HASH_SET`。   |
|`NO_USE_HASH_SET`                 | 禁止优化器在集合运算中使用 HASH 方法。它的反向操作是 `USE_HASH_SET`。     |

## `PQ_SET` Hint

`PQ_SET` Hint 指定分布式执行时集合运算的数据分发方式。

### 语法

```sql
PQ_SET ( [ @qb_name ] [left_branch_qb_name] method_list )
```

#### 参数解释

- `left_branch_qb_name`：用于确定 `UNION` 或 `INTERSECT` 集合运算的左支。

- `method_list` 控制具体的分布式执行方式。

具体方式说明与举例如下：

| 数据分发方式           |   outline data hint 描述      |    说明   |
|----------------------|------------------------------|-----------|
| DIST_BASIC_METHOD    | PQ_SET ( @SET$1 )，outline 中不添加 hint |           |
| DIST_PARTITION_WISE  |   PQ_SET ( @SET$1 NONE NONE)   |    |
|DIST_PULL_TO_LOCAL    |  PQ_SET ( @SET$1 LOCAL LOCAL)  |    |
|DIST_SET_RANDOM       |  PQ_SET ( @SET$1 RANDOM NONE)  | 仅限于 `UNION ALL`   |
|DIST_SET_RANDOM       |  PQ_SET ( @SET$1 NONE RANDOM)| 仅限于 `UNION ALL`   |
|DIST_SET_RANDOM       |  PQ_SET ( @SET$1 RANDOM NONE RANDOM)| 仅限于 `UNION ALL`   |
|DIST_HASH_HASH        | PQ_SET ( @SET$1 SEL$1 HASH HASH)|  仅限于两分支 union/intersect，以 SEL$1 为左支  |
|DIST_NONE_PARTITION   | PQ_SET ( @SET$1 SEL$2 NONE PARTITION )| 仅限于两分支 union/intersect，以 SEL$2 为左支|
|DIST_PARTITION_NONE   | PQ_SET ( @SET$1 SEL$1 PARTITION NONE )|仅限于两分支 union/intersect，以 SEL$1 为左支|

### 示例

下方的查询示例中，使用 `pq_set(@set$1 local local)` 指定将数据直接拉回本地的分布式执行方式，使用 `pq_set(@set$1 sel$2 hash hash)` 指定使用 `HASH` 方式重新分布数据进行集合运算，并使用 `sel$2` 作为集合运算左支。

```sql
-- 通过 PQ_SET Hint 指定集合运算使用特定的分布式执行方式
CREATE TABLE tp1(c1 INT, c2 INT, c3 INT) PARTITION BY HASH(c1) PARTITIONS 10;
EXPLAIN BASIC SELECT /*+ PQ_SET(@set$1 local local) */ c2, c3 FROM tp1 a UNION SELECT c2, c3 FROM tp1 b;
+------------------------------------------------------------------+
| Query Plan                                                       |
+------------------------------------------------------------------+
| =========================================                        |
| |ID|OPERATOR                   |NAME    |                        |
| -----------------------------------------                        |
| |0 |HASH UNION DISTINCT        |        |                        |
| |1 |├─PX COORDINATOR           |        |                        |
| |2 |│ └─EXCHANGE OUT DISTR     |:EX10000|                        |
| |3 |│   └─PX PARTITION ITERATOR|        |                        |
| |4 |│     └─TABLE FULL SCAN    |A       |                        |
| |5 |└─PX COORDINATOR           |        |                        |
| |6 |  └─EXCHANGE OUT DISTR     |:EX20000|                        |
| |7 |    └─PX PARTITION ITERATOR|        |                        |
| |8 |      └─TABLE FULL SCAN    |B       |                        |
| =========================================                        |
| Outputs & filters:                                               |
| -------------------------------------                            |
|   0 - output([UNION([1])], [UNION([2])]), filter(nil), rowset=16 |
|   1 - output([A.C2], [A.C3]), filter(nil), rowset=16             |
|   2 - output([A.C2], [A.C3]), filter(nil), rowset=16             |
|       dop=1                                                      |
|   3 - output([A.C2], [A.C3]), filter(nil), rowset=16             |
|       force partition granule                                    |
|   4 - output([A.C2], [A.C3]), filter(nil), rowset=16             |
|       access([A.C2], [A.C3]), partitions(p[0-9])                 |
|       is_index_back=false, is_global_index=false,                |
|       range_key([A.__pk_increment]), range(MIN ; MAX)always true |
|   5 - output([B.C2], [B.C3]), filter(nil), rowset=16             |
|   6 - output([B.C2], [B.C3]), filter(nil), rowset=16             |
|       dop=1                                                      |
|   7 - output([B.C2], [B.C3]), filter(nil), rowset=16             |
|       force partition granule                                    |
|   8 - output([B.C2], [B.C3]), filter(nil), rowset=16             |
|       access([B.C2], [B.C3]), partitions(p[0-9])                 |
|       is_index_back=false, is_global_index=false,                |
|       range_key([B.__pk_increment]), range(MIN ; MAX)always true |
+------------------------------------------------------------------+
34 rows in set

EXPLAIN BASIC
SELECT /*+ PQ_SET(@set$1 sel$2 hash hash) */ c2, c3 FROM tp1 a
UNION
SELECT c2, c3 FROM tp1 b;
+-----------------------------------------------------------------------------------+
| Query Plan                                                                        |
+-----------------------------------------------------------------------------------+
| ===============================================                                   |
| |ID|OPERATOR                         |NAME    |                                   |
| -----------------------------------------------                                   |
| |0 |PX COORDINATOR                   |        |                                   |
| |1 |└─EXCHANGE OUT DISTR             |:EX10002|                                   |
| |2 |  └─HASH UNION DISTINCT          |        |                                   |
| |3 |    ├─EXCHANGE IN DISTR          |        |                                   |
| |4 |    │ └─EXCHANGE OUT DISTR (HASH)|:EX10000|                                   |
| |5 |    │   └─PX PARTITION ITERATOR  |        |                                   |
| |6 |    │     └─TABLE FULL SCAN      |B       |                                   |
| |7 |    └─EXCHANGE IN DISTR          |        |                                   |
| |8 |      └─EXCHANGE OUT DISTR (HASH)|:EX10001|                                   |
| |9 |        └─PX PARTITION ITERATOR  |        |                                   |
| |10|          └─TABLE FULL SCAN      |A       |                                   |
| ===============================================                                   |
| Outputs & filters:                                                                |
| -------------------------------------                                             |
|   0 - output([INTERNAL_FUNCTION(UNION([1]), UNION([2]))]), filter(nil), rowset=16 |
|   1 - output([INTERNAL_FUNCTION(UNION([1]), UNION([2]))]), filter(nil), rowset=16 |
|       dop=1                                                                       |
|   2 - output([UNION([1])], [UNION([2])]), filter(nil), rowset=16                  |
|   3 - output([B.C2], [B.C3]), filter(nil), rowset=16                              |
|   4 - output([B.C2], [B.C3]), filter(nil), rowset=16                              |
|       (#keys=2, [B.C2], [B.C3]), dop=1                                            |
|   5 - output([B.C2], [B.C3]), filter(nil), rowset=16                              |
|       force partition granule                                                     |
|   6 - output([B.C2], [B.C3]), filter(nil), rowset=16                              |
|       access([B.C2], [B.C3]), partitions(p[0-9])                                  |
|       is_index_back=false, is_global_index=false,                                 |
|       range_key([B.__pk_increment]), range(MIN ; MAX)always true                  |
|   7 - output([A.C2], [A.C3]), filter(nil), rowset=16                              |
|   8 - output([A.C2], [A.C3]), filter(nil), rowset=16                              |
|       (#keys=2, [A.C2], [A.C3]), dop=1                                            |
|   9 - output([A.C2], [A.C3]), filter(nil), rowset=16                              |
|       force partition granule                                                     |
|  10 - output([A.C2], [A.C3]), filter(nil), rowset=16                              |
|       access([A.C2], [A.C3]), partitions(p[0-9])                                  |
|       is_index_back=false, is_global_index=false,                                 |
|       range_key([A.__pk_increment]), range(MIN ; MAX)always true                  |
+-----------------------------------------------------------------------------------+
39 rows in set
```

## `USE_HASH_SET` Hint

`USE_HASH_SET` Hint 控制集合运算使用的具体算法。它的反向操作为 `NO_USE_HASH_SET`。

### 语法

```sql
/*+ USE_HASH_SET [ ( [ @ qb_name ] ) ] */
```

### 示例

下方的查询示例中，使用 `USE_HASH_SET` 控制启用 `HASH` 算法。

```sql
-- 使用 USE_HASH_SET Hint 强制集合运算使用 HASH 方法
EXPLAIN BASIC
SELECT /*+ USE_HASH_SET(@set$1) */ c1, c2, c3 FROM t1
UNION
SELECT c1, c2, c3 FROM t1;
+--------------------------------------------------------------------------------+
| Query Plan                                                                     |
+--------------------------------------------------------------------------------+
| =============================                                                  |
| |ID|OPERATOR           |NAME|                                                  |
| -----------------------------                                                  |
| |0 |HASH UNION DISTINCT|    |                                                  |
| |1 |├─TABLE FULL SCAN  |T1  |                                                  |
| |2 |└─TABLE FULL SCAN  |T1  |                                                  |
| =============================                                                  |
| Outputs & filters:                                                             |
| -------------------------------------                                          |
|   0 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=16 |
|   1 - output([T1.C1], [T1.C2], [T1.C3]), filter(nil), rowset=16                |
|       access([T1.C1], [T1.C2], [T1.C3]), partitions(p0)                        |
|       is_index_back=false, is_global_index=false,                              |
|       range_key([T1.__pk_increment]), range(MIN ; MAX)always true              |
|   2 - output([T1.C1], [T1.C2], [T1.C3]), filter(nil), rowset=16                |
|       access([T1.C1], [T1.C2], [T1.C3]), partitions(p0)                        |
|       is_index_back=false, is_global_index=false,                              |
|       range_key([T1.__pk_increment]), range(MIN ; MAX)always true              |
+--------------------------------------------------------------------------------+
18 rows in set
```

## `NO_USE_HASH_SET` Hint

`NO_USE_HASH_SET` Hint 控制集合运算使用的具体算法。它的反向操作为 `USE_HASH_SET`。

### 语法

```sql
/*+ NO_USE_HASH_SET [ ( [ @ qb_name ] ) ] */
```

### 示例

下方的查询示例中，使用 `NO_USE_HASH_SET` 禁止 HASH 算法。由于 Oceanbase 支持 HASH 和 MERGE 两种集合运算算法， 使用 `NO_USE_HASH_SET` Hint 后实际效果为对集合操作使用 `MERGE` 算法。`UNION ALL` 集合操作不具备去重语义，不受该 Hint 控制。

```sql
-- 通过 NO_USE_HASH_SET Hint 指导优化器在集合运算中避免使用 HASH 方法
EXPLAIN BASIC
SELECT /*+ NO_USE_HASH_SET(@set$1) */ c1, c2, c3 FROM t1
UNION
SELECT c1, c2, c3 FROM t1;
+--------------------------------------------------------------------------------+
| Query Plan                                                                     |
+--------------------------------------------------------------------------------+
| ==============================                                                 |
| |ID|OPERATOR            |NAME|                                                 |
| ------------------------------                                                 |
| |0 |MERGE UNION DISTINCT|    |                                                 |
| |1 |├─SORT              |    |                                                 |
| |2 |│ └─TABLE FULL SCAN |T1  |                                                 |
| |3 |└─SORT              |    |                                                 |
| |4 |  └─TABLE FULL SCAN |T1  |                                                 |
| ==============================                                                 |
| Outputs & filters:                                                             |
| -------------------------------------                                          |
|   0 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=16 |
|   1 - output([T1.C1], [T1.C2], [T1.C3]), filter(nil), rowset=16                |
|       sort_keys([T1.C1, ASC], [T1.C2, ASC], [T1.C3, ASC])                      |
|   2 - output([T1.C1], [T1.C2], [T1.C3]), filter(nil), rowset=16                |
|       access([T1.C1], [T1.C2], [T1.C3]), partitions(p0)                        |
|       is_index_back=false, is_global_index=false,                              |
|       range_key([T1.__pk_increment]), range(MIN ; MAX)always true              |
|   3 - output([T1.C1], [T1.C2], [T1.C3]), filter(nil), rowset=16                |
|       sort_keys([T1.C1, ASC], [T1.C2, ASC], [T1.C3, ASC])                      |
|   4 - output([T1.C1], [T1.C2], [T1.C3]), filter(nil), rowset=16                |
|       access([T1.C1], [T1.C2], [T1.C3]), partitions(p0)                        |
|       is_index_back=false, is_global_index=false,                              |
|       range_key([T1.__pk_increment]), range(MIN ; MAX)always true              |
+--------------------------------------------------------------------------------+
24 rows in set
```