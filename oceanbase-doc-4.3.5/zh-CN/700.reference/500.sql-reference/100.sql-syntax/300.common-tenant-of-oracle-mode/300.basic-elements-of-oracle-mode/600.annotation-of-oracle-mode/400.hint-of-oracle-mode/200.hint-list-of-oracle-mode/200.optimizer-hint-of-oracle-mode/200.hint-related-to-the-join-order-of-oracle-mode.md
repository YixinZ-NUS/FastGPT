| Description   |                 |
|---------------|-----------------|
| keywords      |                 |
| dir-name      | Join Order Hint |
| dir-name-en   |                 |
| tenant-type   | Oracle Mode     |
|machine-translation||

# Optimized Hint 类型下的 Join Order Hint

在 SQL 查询中，与联接顺序相关的 Hint 包括 `ORDERED` Hint 和 `LEADING` Hint。

| Hint 类型 | 描述                                             |
|-----------|-------------------------------------------------|
| `LEADING`   | 按 hint 中指定的表顺序进行联接。当仅指定 `FROM` 子句中的部分表时，指定的表作为驱动表与其它联接。    |
| `ORDERED`   | 按 `FROM` 子句的顺序进行表联接。                 |

<main id="notice" type='notice'>
  <h4>注意</h4>
  <p>建议使用 <code>LEADING</code> Hint 直接显式指定期望的联接顺序。因为 <code>ORDERED</code> Hint 仅能指定特定的联接顺序，并且联接顺序受改写影响。</p>
</main>

## `LEADING` Hint

`LEADING` Hint 指示优化器按照指定的顺序联接表，比 `ORDERED` Hint 灵活性更高，`LEADING` Hint 可以显式定义任意合法的预期联接顺序。而 `ORDERED` Hint 仅能指定特定的联接顺序，并且联接顺序受改写影响。建议使用 `LEADING` Hint 直接显式指定期望的联接顺序。

### 语法

```sql
/*+ LEADING ( [ @queryblock ] tablespec [ tablespec ]...  ) */
```

### 使用说明和注意事项

`LEADING` Hint 仅在其指定的表名与查询中出现的表名完全匹配时才会生效。

* 如果发现 Hint 指定的 `table_name` 不存在，则 `LEADING` Hint 失效。

* 如果发现 Hint 中存在重复表，则 `LEADING` Hint 失效。

* 如果在优化器联接期间，无法找到对应的表，那么该表及后面的表指定的联接顺序失效，该表前面指定的顺序依然有效。

* 如果由于联接图中的依赖关系，无法首先按照指定的顺序联接指定的表，则 `LEADING` Hint 失效。

* 如果指定两个或多个相互冲突的 `LEADING` Hint，则 `LEADING` Hint 失效。

* 如果您指定了 `ORDERED` Hint，它将覆盖所有的 `LEADING` Hint。

### 示例

```SQL
SELECT /*+ LEADING(e j) */ *
FROM employees e, departments d, job_history j
WHERE e.department_id = d.department_id
  AND e.hire_date = j.start_date;

-- 查看执行计划
EXPLAIN SELECT /*+ LEADING(e j) */ *
FROM employees e, departments d, job_history j
WHERE e.department_id = d.department_id
  AND e.hire_date = j.start_date;

+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Query Plan                                                                                                                                                                        |
+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ===================================================                                                                                                                               |
| |ID|OPERATOR           |NAME|EST.ROWS|EST.TIME(us)|                                                                                                                               |
| ---------------------------------------------------                                                                                                                               |
| |0 |HASH JOIN          |    |3       |16          |                                                                                                                               |
| |1 |├─HASH JOIN        |    |3       |10          |                                                                                                                               |
| |2 |│ ├─TABLE FULL SCAN|E   |3       |5           |                                                                                                                               |
| |3 |│ └─TABLE FULL SCAN|J   |3       |4           |                                                                                                                               |
| |4 |└─TABLE FULL SCAN  |D   |3       |4           |                                                                                                                               |
| ===================================================                                                                                                                               |
| Outputs & filters:                                                                                                                                                                |
| -------------------------------------                                                                                                                                             |
|   0 - output([E.EMPLOYEE_ID], [E.FIRST_NAME], [E.LAST_NAME], [E.HIRE_DATE], [E.DEPARTMENT_ID], [D.DEPARTMENT_ID], [D.DEPARTMENT_NAME], [J.EMPLOYEE_ID],                           |
|       [J.START_DATE], [J.END_DATE], [J.JOB_ID]), filter(nil), rowset=16                                                                                                           |
|       equal_conds([E.DEPARTMENT_ID = D.DEPARTMENT_ID]), other_conds(nil)                                                                                                          |
|   1 - output([E.EMPLOYEE_ID], [E.FIRST_NAME], [E.LAST_NAME], [E.HIRE_DATE], [E.DEPARTMENT_ID], [J.EMPLOYEE_ID], [J.START_DATE], [J.END_DATE], [J.JOB_ID]), filter(nil), rowset=16 |
|       equal_conds([E.HIRE_DATE = J.START_DATE]), other_conds(nil)                                                                                                                 |
|   2 - output([E.EMPLOYEE_ID], [E.DEPARTMENT_ID], [E.HIRE_DATE], [E.FIRST_NAME], [E.LAST_NAME]), filter(nil), rowset=16                                                            |
|       access([E.EMPLOYEE_ID], [E.DEPARTMENT_ID], [E.HIRE_DATE], [E.FIRST_NAME], [E.LAST_NAME]), partitions(p0)                                                                    |
|       is_index_back=false, is_global_index=false,                                                                                                                                 |
|       range_key([E.EMPLOYEE_ID]), range(MIN ; MAX)always true                                                                                                                     |
|   3 - output([J.START_DATE], [J.EMPLOYEE_ID], [J.END_DATE], [J.JOB_ID]), filter(nil), rowset=16                                                                                   |
|       access([J.START_DATE], [J.EMPLOYEE_ID], [J.END_DATE], [J.JOB_ID]), partitions(p0)                                                                                           |
|       is_index_back=false, is_global_index=false,                                                                                                                                 |
|       range_key([J.__pk_increment]), range(MIN ; MAX)always true                                                                                                                  |
|   4 - output([D.DEPARTMENT_ID], [D.DEPARTMENT_NAME]), filter(nil), rowset=16                                                                                                      |
|       access([D.DEPARTMENT_ID], [D.DEPARTMENT_NAME]), partitions(p0)                                                                                                              |
|       is_index_back=false, is_global_index=false,                                                                                                                                 |
|       range_key([D.DEPARTMENT_ID]), range(MIN ; MAX)always true                                                                                                                   |
+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
28 rows in set
```

上面执行计划中，`LEADING(e j)` 指示优化器首先考虑表 `e (employees)`，然后考虑表 `j (job_history)`。

## `ORDERED` Hint

使用查询中默认的连接顺序。`ORDERED` Hint 优先级高于 `LEADING` Hint，存在 `ORDERED` Hint 时，`LEADING` Hint 失效。
使用 `ORDERED` Hint 时，OUTLINE DATA 中不显示 `ORDERED` Hint，而是打印完整的 `LEADING` Hint。

### 语法

```sql
/*+ ORDERED */
```

### 示例

假设我们有三个表 `employees`, `departments`, 和 `job_history` 需要联接：

```sql
SELECT /*+ ORDERED */ e.employee_id, d.department_name, j.job_id
FROM employees e, departments d, job_history j
WHERE e.department_id = d.department_id
  AND e.hire_date = j.start_date;
```

在这个例子中，数据库将按照 `employees`, `departments`, 和 `job_history` 的顺序来联接这三个表。