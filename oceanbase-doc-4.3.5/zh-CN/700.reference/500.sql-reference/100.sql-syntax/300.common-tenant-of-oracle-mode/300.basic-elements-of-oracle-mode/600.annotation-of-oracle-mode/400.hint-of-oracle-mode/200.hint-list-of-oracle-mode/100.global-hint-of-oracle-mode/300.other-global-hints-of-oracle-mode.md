| Description   |                 |
|---------------|-----------------|
| keywords      |                 |
| dir-name      | 全局 Hint 下的其他 Hint        |
| dir-name-en   |                 |
| tenant-type   | Oracle Mode     |
|machine-translation||

# 全局 Hint 类型下的其他 Hint

全局 Hint 类型下的其他 Hint 允许开发者和数据库管理员对 SQL 语句的执行进行细粒度的控制。所支持的其他类型 Hint 如下：

| Hint 名称                               | 解释                            |
|---------------------------------------|-------------------------------|
| `APPEND`                              |INSERT 的同时收集统计信息；`INSERT INTO SELECT` 中开启旁路模式（DIRECT INSERT）。  |
| `CURSOR_SHARING_EXACT`                | 控制查询是否参数化。                                                   |
| `DIRECT`                              | 在 `LOAD DATA` 和 `INSERT` 语句中可以指定启用旁路导入功能，提升数据导入的效率和性能。                  |
| `NO_DIRECT`                              | 在 `LOAD DATA` 语句、`INSERT INTO SELECT` 语句以及 `CREATE TABLE AS SELECT` 语句中禁用旁路导入功能。                 |
| `USE_PX`                 | 执行 SQL 语句时使用 PX 模式，PX 模式允许在执行语句时采用多线程方式。                             |
| `ENABLE_PARALLEL_DML`                 | 启用 并行 DML。                             |
| `DISABLE_PARALLEL_DML`                 | 禁用 并行 DML。                             |
| `ENABLE_PARALLEL_DAS_DML`                 | 指定当前 DML 语句强制开启使用 Distributed Data Access Service (DAS) 并发写优化。                             |
| `DISABLE_PARALLEL_DAS_DML`                 | 指定当前 DML 语句禁用 Distributed Data Access Service (DAS) 并发写优化。                             |
| `DYNAMIC_SAMPLING`                    | 开启动态采样。                              |
| `LOAD_BATCH_SIZE`                     | 用于指定每次插入的批量大小，且仅在 LOAD DATA 中使用。         |
| `LOG_LEVEL`                           | 用于指定当前查询在执行过程中记录的日志级别。                  |
| `MAX_CONCURRENT`                      | 设置查询允许最大并发数。                                           |
| `MONITOR`                             | 用于对查询开启捕获查询执行 SQL Plan Monitor 记录。                 |
| `MV_REWRITE`                             | 单独使用 `MV_REWRITE` Hint 时可以跳过物化视图查询改写的规则/代价检查，直接使用可以使用的改写。                 |
| `NO_MV_REWRITE`                             | 禁止物化视图查询改写，可以指定 query block。                 |
| `OPT_PARAM`                           | 设置查询级别优化器相关参数。                                    |
| `PARALLEL`                            | 设置查询级别并行度。它的反向操作为 `NO_PARALLEL`。       |
| `NO_PARALLEL`                         | 关闭查询并行 （即设置并行度为 1）。                                   |
| `QUERY_TIMEOUT`                       | 设置查询执行超时时间。                                       |
| `READ_CONSISTENCY`                    | 读一致性级别设置(强/弱)。                                        |
| `RESOURCE_GROUP`                    | 强制指定该条语句所使用的资源组。                                        |
| `STAT`                                | 追踪查询算子输出统计 。                                        |
| `TRANS_PARAM`                         | 设置查询级别事务相关变量值。                     |
| `TRACING`                             | 追踪查询执行算子输出。                      |
| `USE_PLAN_CACHE`                      | 用于指定当前查询的计划缓存（Plan Cache）使用策略。       |

## `APPEND` Hint

`APPEND` Hint 指定 `INSERT INTO SELECT` 开启旁路导入功能。更多信息，参见[使用 `INSERT INTO SELECT` 语句旁路导入数据](../../../../../../../../../620.obap/300.obap-data-collection/300.obap-import-data/20.bypass-import/100.overview-of-bypass-import.md)。

### 语法

```sql
/*+ APPEND */
```

### 示例

```sql
INSERT /*+ append enable_parallel_dml parallel(16) */ INTO t2
SELECT * FROM t1;
```

## `CURSOR_SHARING_EXACT` Hint

`CURSOR_SHARING_EXACT` Hint 用于指定查询级别禁止参数化。

OceanBase 数据库支持使用绑定变量替换 SQL 语句中的字面量，此功能由 `CURSOR_SHARING` 变量控制，即当`cursor_sharing='exact'` 时，不需要参数化。详细信息，请参见 [cursor_sharing](../../../../../../../../800.configuration-items-and-system-variables/200.system-variable/300.global-system-variable/1900.cursor_sharing-global.md)。

### 语法

```sql
/*+ CURSOR_SHARING_EXACT */
```

### 示例

下方的查询示例中，使用 `CURSOR_SHARING_EXACT` Hint 禁止参数化，使用两组参数执行 4 次后，PLAN CACHE 中对不同参数生成了两个查询计划。

```sql
alter system flush plan cache global;
SELECT /*+ CURSOR_SHARING_EXACT */ * FROM t1 WHERE c1=5;
SELECT /*+ CURSOR_SHARING_EXACT */ * FROM t1 WHERE c1=5;
SELECT /*+ CURSOR_SHARING_EXACT */ * FROM t1 WHERE c1=6;
SELECT /*+ CURSOR_SHARING_EXACT */ * FROM t1 WHERE c1=6;

SELECT sql_id, plan_id, statement FROM oceanbase.gv$ob_plan_cache_plan_stat where query_sql like "SELECT /*+ CURSOR_SHARING_EXACT */ * FROM t1 WHERE c1=%";
+----------------------------------+---------+---------------------------------------------------------+
| sql_id                           | plan_id | statement                                               |
+----------------------------------+---------+---------------------------------------------------------+
| E024EB33213BF501D4CA7ABB81A195B5 |   13249 | SELECT /*+ CURSOR_SHARING_EXACT */ * FROM t1 WHERE c1=5 |
| E024EB33213BF501D4CA7ABB81A195B5 |   13250 | SELECT /*+ CURSOR_SHARING_EXACT */ * FROM t1 WHERE c1=6 |
+----------------------------------+---------+---------------------------------------------------------+
```

## `DIRECT` Hint

`DIRECT` Hint 在 `LOAD DATA` 和 `INSERT` 语句中可以指定启用旁路导入功能，提升数据导入的效率和性能。

### 语法

`DIRECT` Hint 的语法格式如下：

```sql
/*+ DIRECT (/*+ direct(need_sort, max_errors_allowed, load_mode) */)*/
```

#### 参数解释

- `need_sort`：表示是否需要将导入数据进行排序。`true` 表示需要排序，`false` 表示不需要排序。

- `max_errors_allowed`：指定最大允许的错误行数，超过此数目则导入过程将失败。

- `load_mode`：指定导入模式，参数选项包括：

  + `full`：默认值，表示全量导入。
  + `inc`：表示增量导入，支持 `INSERT` 和 `IGNORE` 语义。
  + `inc_replace`：表示增量导入，但不检查主键是否重复，相当于 `REPLACE` 语义的增量导入。

### 示例

#### `LOAD DATA` 中的 `DIRECT` Hint 示例

**启用增量旁路导入**

```sql
LOAD DATA /*+ DIRECT(true, 0, inc) */
INFILE 'datafile.txt'
INTO TABLE mytable
FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
LINES TERMINATED BY '\n';
```

在这个示例中，`DIRECT(true, 0, inc)` 表示启用增量旁路导入，进行排序，并且允许最多 0 行错误。

**启用全量旁路导入**

```sql
LOAD DATA
/*+ PARALLEL(4) DIRECT(true, 0, full) */
REMOTE_OSS INFILE 'oss://example.com/datafile.csv'
INTO TABLE my_table
FIELDS TERMINATED BY ',' ENCLOSED BY '"'
LINES TERMINATED BY '\n';
```

在这个示例中，`PARALLEL(4)` 指定并行度为 4，`DIRECT(true, 0, full)` 表示启用全量旁路导入，进行排序，并且允许最多 0 行错误。

更多信息，参见 [旁路导入](../../../../../../../../../620.obap/300.obap-data-collection/300.obap-import-data/20.bypass-import/100.overview-of-bypass-import.md)。

#### `INSERT INTO SELECT` 中的 `DIRECT` Hint 示例

在 `INSERT INTO SELECT` 语句，开启旁路导入需要配合 `enable_parallel_dml` 使用，格式为：`/*+ direct(bool, int, load_mode)} enable_parallel_dml PARALLEL(N) */`。

**启用增量旁路导入**

```sql
-- 启用增量旁路导入和并行 DML，将 old_table 的数据增量导入到 new_table
INSERT /*+ direct(true, 0, 'inc') enable_parallel_dml PARALLEL(4) */ INTO new_table (id, name, value)
SELECT id, name, value
FROM old_table;
```

在这个示例中，`direct(true, 0, 'inc')` 启用增量旁路导入，并对数据进行排序，允许最多 0 行错误；`enable_parallel_dml` 启用并行 DML；`PARALLEL(4)` 设置并行度为 4。

**启用全量旁路导入**

```sql
-- 启用全量旁路导入和并行 DML，将 old_table 的数据插入到 new_table
INSERT /*+ direct(true, 0, 'full') enable_parallel_dml PARALLEL(4) */ INTO new_table (id, name, value)
SELECT id, name, value
FROM old_table;
```

在这个示例中，`direct(true, 0, 'full')` 启用全量旁路导入，并对数据进行排序，允许最多 0 行错误；`enable_parallel_dml` 启用并行 DML；`PARALLEL(4)` 设置并行度为 4。

更多信息，参见[使用 INSERT INTO SELECT 语句旁路导入数据](../../../../../../../../../620.obap/300.obap-data-collection/300.obap-import-data/20.bypass-import/100.overview-of-bypass-import.md)。

## `NO_DIRECT` Hint

`NO_DIRECT` Hint 在 `LOAD DATA` 语句、`INSERT INTO SELECT` 语句以及 `CREATE TABLE AS SELECT` 语句中禁用旁路导入功能。

### 语法

`NO_DIRECT` Hint 的语法格式如下：

```sql
/*+ NO_DIRECT */
```

### 参数解释

`NO_DIRECT`：控制单条 SQL 强制不走旁路导入，只要输入的 SQL 带有该 Hint，则整个语句忽略其他旁路导入的 Hint，执行普通导入。

### 示例

* **在 LOAD DATA 语句中使用 NO_DIRECT**

  ```sql
  LOAD DATA /*+ NO_DIRECT */ [REMOTE_OSS | LOCAL] INFILE 'file_name' INTO TABLE table_name [COMPRESSION]...
  ```

* **在 INSERT INTO SELECT 语句中使用 NO_DIRECT**

  ```sql
  INSERT /*+ NO_DIRECT */ INTO  table_name select_sentence
  ```

* **在 CREATE TABLE AS SELECT 语句中使用 NO_DIRECT**

  ```sql
  CREATE /*+ NO_DIRECT */ TABLE table_name [AS] select_sentence
  ```

## `DYNAMIC_SAMPLING` Hint

`DYNAMIC_SAMPLING` Hint 指定查询是否开启动态采样。

### 语法

```sql
/*+ DYNAMIC_SAMPLING ( 0 | 1 ) */
```

#### 参数解释

`DYNAMIC_SAMPLING` Hint 中的参数释义如下：：

- 参数为 0 时禁止动态采样。
- 参数为 1 时开启动态采样。

### 示例

下方的查询示例中，使用 `DYNAMIC_SAMPLING` Hint 开启动态采样。

```sql
SELECT /*+ dynamic_sampling(1) */ *
FROM t1 WHERE c1 LIKE "%abc%" AND c2 LIKE "%abc%";
```

## `USE_PX` Hint

`USE_PX` Hint 强制服务器在执行 SQL 语句时采用 PX（并行执行）模式。PX 模式允许通过多线程方式执行 SQL 语句，从而提高查询性能。通常情况下，`USE_PX` Hint 和 `PARALLEL` Hint 一起使用，以指定并行执行的线程数量。默认情况下，系统使用 `USE_PX` Hint。

### 语法

`USE_PX` Hint 的语法如下：

```sql
/*+ USE_PX */
```

### 示例

`USE_PX` Hint 的示例如下：

```sql
SELECT /*+ USE_PX PARALLEL(4)*/ e.dept_id, sum(e.salary)
FROM emp e
WHERE e.dept_id = 1001 GROUP BY e.dept_id;
```

## `ENABLE_PARALLEL_DML` Hint

`ENABLE_PARALLEL_DML` Hint 指定当前查询开启并行 DML，其反向 Hint 为 `DISABLE_PARALLEL_DML`，用于禁止并行 DML。

详细信息，参见 [并行 DML](../../../../../../../../1000.performance-tuning-guide/500.sql-optimization/300.distributed-execution-plan/1000.parallel-dml.md)。

### 注意事项

- 使用 `/*+ENABLE_PARALLEL_DML PARALLEL(n)*/` 时，系统会优先考虑使用分布式并行 DML（PDML）。如果当前环境不支持 PDML，系统会回退到 DAS 并发写作为性能优化手段。

- 当在会话（session）级别设置了强制并行度，其执行行为将与上述行为保持一致。

- 即使在当前环境不支持并行 DML (PDML) 的情况下，如果系统参数 `_enable_parallel_das_dml` 被通过 `ALTER SYSTEM SET` 命令设置为 `true`（其默认值为 `false`），则即使使用了 Hint `/*+ENABLE_PARALLEL_DML PARALLEL(n)*/`，系统也不会启用 DAS（分布式活动存储）的并行写操作。

- 当通过 `ALTER SYSTEM SET` 命令将 `_enable_parallel_das_dml` 设置为 `true`（默认为 `false`），并且在会话级别已经设置了强制并行度，那么即使当前环境不支持 PDML，使用 Hint `/*+ENABLE_PARALLEL_DML PARALLEL(n)*/` 也不会启用 DAS 的并行写功能。

### 语法

```sql
/*+ ENABLE_PARALLEL_DML */
```

### 示例

```sql
insert /*+ enable_parallel_dml parallel(8) */ into t2 select * from t1;
```

## `DISABLE_PARALLEL_DML` Hint

`DISABLE_PARALLEL_DML` Hint 指定当前查询禁用并行 DML，其反向 Hint 为 `ENABLE_PARALLEL_DML`，用于开启并行 DML。

详细信息，参见 [并行 DML](../../../../../../../../1000.performance-tuning-guide/500.sql-optimization/300.distributed-execution-plan/1000.parallel-dml.md)。

### 语法

```sql
/*+ DISABLE_PARALLEL_DML */
```

### 示例

```sql
insert /*+ disable_parallel_dml parallel(8) */ into t2 select * from t1;
```

## `ENABLE_PARALLEL_DAS_DML` Hint

`ENABLE_PARALLEL_DAS_DML` Hint 用于指定当前 DML 语句强制开启使用 Distributed Data Access Service (DAS) 并发写优化。其反向 Hint 为 `DISABLE_PARALLEL_DAS_DML`。

### 注意事项

- `ENABLE_PARALLEL_DAS_DML` 需要配合 `ENABLE_PARALLEL_DML` 一起使用。

- 在 Hint `/*+ENABLE_PARALLEL_DAS_DML ENABLE_PARALLEL_DML PARALLEL(n)*/` 的作用下，系统会将 DAS 并发写作为强制选项，并根据 `PARALLEL(n)` 指定的并行度来执行操作。

- 将系统参数 `_enable_parallel_das_dml` 通过 `ALTER SYSTEM SET` 语句设置为 `true`（默认为 `false`）将会导致 Hint `/*+ENABLE_PARALLEL_DAS_DML ENABLE_PARALLEL_DML PARALLEL(n)*/` 无效。此时，系统将不会执行 DAS 的并行写操作。

### 语法

```sql
/*+ ENABLE_PARALLEL_DAS_DML */
```

### 示例

```sql
insert /*+ ENABLE_PARALLEL_DAS_DML ENABLE_PARALLEL_DML PARALLEL(10)*/
into t1 select * from t2;
```

## `DISABLE_PARALLEL_DAS_DML` Hint

`DISABLE_PARALLEL_DAS_DML` Hint 用于指定当前 DML 语句强制关闭使用 Distributed Data Access Service (DAS) 并发写优化。其反向 Hint 为 `ENABLE_PARALLEL_DAS_DML`。

### 注意事项

- `DISABLE_PARALLEL_DAS_DML` 需要配合 `ENABLE_PARALLEL_DML` 一起使用。

- 使用 Hint `/*+DISABLE_PARALLEL_DAS_DML ENABLE_PARALLEL_DML PARALLEL(n)*/`，系统会禁用 DAS 并发写，即使其他并发写优化选项如 PDML 被启用。

### 语法

```sql
/*+ DISABLE_PARALLEL_DAS_DML */
```

### 示例

```sql
insert /*+ DISABLE_PARALLEL_DAS_DML ENABLE_PARALLEL_DML PARALLEL(10)*/
into t1 select * from t2;
```

## `LOAD_BATCH_SIZE` Hint

`LOAD_BATCH_SIZE` Hint 在 `LOAD DATA` 中用于指定每次插入的批量记录的大小。

`LOAD_BATCH_SIZE` Hint 中 `batch_size` 指定每次插入批量记录的大小。 `LOAD DATA` 相关介绍可以查看 [LOAD DATA 介绍](../../../../../900.sql-statement-of-oracle-mode/300.dcl-of-oracle-mode/1900.load-data-of-oracle-mode.md)。

### 语法

```sql
/*+ LOAD_BATCH_SIZE ( batch_size ) */
```

### 示例

```sql
-- 使用 4 个并行进程来导入数据，将新数据追加到表的末尾，并且通过 `LOAD_BATCH_SIZE` Hint 设定每个批次处理 1000 条记录
LOAD DATA /*+ PARALLEL(4) APPEND LOAD_BATCH_SIZE(1000) */
INFILE '/home/admin/test.csv' INTO TABLE t1;
```

## `LOG_LEVEL` Hint

`LOG_LEVEL` Hint 用于指定当前查询在执行过程中记录的日志级别。

LOG_LEVEL Hint 参数中 `log_level`指定日志级别, 常用的日志级别包括 `ERROR`/`WARN`/`INFO`/`TRACE`/`DEBUG`。

更多关于日志级别的释义，参见[日志级别](../../../../../../../../../600.manage/800.logging/200.log-level.md)。

### 语法

```sql
/*+ LOG_LEVEL ( [']log_level['] ) */
```

### 示例

```sql
--使用 LOG_LEVEL Hint 指定使用 `TRACE` 级别日志。
SELECT /*+ LOG_LEVEL(TRACE) */ *
FROM employees e
WHERE e.department_id = 1001;
```

## `MAX_CONCURRENT` Hint

`MAX_CONCURRENT` Hint 用于指定查询执行的最大并发数。

`MAX_CONCURRENT` Hint 中参数 `intnum` 为指定的查询允许的最大并发数。当查询并发数超出允许的最大并发数时，查询执行会报错到达最大并发数。当 `intnum` 指定为 0 时，查询执行总是报错。

需要注意的是，目前 `MAX_CONCURRENT` Hint 无法直接使用在查询中，只能够创建仅包含 `MAX_CONCURRENT` Hint 的 outline 用于查询限流，对特定 SQL_ID 使用 `MAX_CONCURRENT` 进行限流。

### 语法

```sql
/*+ MAX_CONCURRENT ( intnum ) */
```

### 示例

```sql
-- 此查询创建了 Outline otl1 关联到标识符为 'EC102CB006383D732BC98797601D9B3B' 的查询，并且指定了对应查询的最大并发执行数为 10
CREATE OUTLINE otl1 ON 'EC102CB006383D732BC98797601D9B3B'
USING HINT /*+ max_concurrent(10) */;
```

## `MONITOR` Hint

`MONITOR` Hint 用于对查询开启捕获查询执行 SQL Plan Monitor 记录，您可以使用 `MONITOR` Hint 将其执行过程记录在 SQL Plan Monitor 中。

对于没有开启并行执行的查询，OceanBase 则不会将其执行过程记录在 SQL Plan Monitor 中。

SQL Plan Monitor 相关介绍见 [实时执行计划展示](../../../../../../../../1000.performance-tuning-guide/500.sql-optimization/200.sql-execution-plan/500.real-time-execution-plan-display.md) 中**实时 SQL Plan Monitor** 章节。

### 语法

```sql
/*+ MONITOR */
```

### 示例

```sql
-- 使用 MONITOR Hint 开启 SQL Plan Monitor 记录。
SELECT /*+monitor*/ c1, SUM(distinct c2) FROM t1 GROUP BY c1;
```

## 物化视图查询改写 Hint

物化视图查询改写控制包括 `MV_REWRITE`、`NO_MV_REWRITE` 两个 Hint，并且这两个 Hint 的优先级高于系统变量 `query_rewrite_enabled`。

### `MV_REWRITE` Hint

`MV_REWRITE` 语法如下：

```sql
/*+ MV_REWRITE (@ queryblock [mv_name_list]) */

mv_name_list:
    mv_name [, mv_name ...]
```

单独使用 `MV_REWRITE` Hint 时可以跳过物化视图查询改写的规则/代价检查，直接使用可以使用的改写。Hint 后指定一个或多个物化视图的情况，除了跳过规则/代价检查外，物化视图查询改写将只使用指定的物化视图尝试改写，忽略所有没被指定的物化视图。

使用 `MV_REWRITE` Hint 指定物化视图时，无法强制使用没有 `ENABLE QUERY REWRITE`（开启当前物化视图的自动改写） 子句的物化视图，无法在系统变量 `query_rewrite_integrity` 设置为 `enforced` 的情况下强制使用非实时物化视图。

### `NO_MV_REWRITE` Hint

`NO_MV_REWRITE` 语法如下：

```sql
/*+ NO_MV_REWRITE (@ queryblock) */
```

禁止物化视图查询改写，可以指定 query block。

### 物化视图查询改写控制 Hint 使用示例

1. 创建基表 `tbl2`。

   ```sql
   CREATE TABLE tbl2 (col1 INT, col2 INT);
   ```

2. 向基表 `tbl2` 中插入两条数据。

   ```sql
   INSERT INTO tbl2 VALUES (1,2),(3,4);
   ```

   返回结果如下：

   ```shell
   Query OK, 2 rows affected
   Records: 2  Duplicates: 0  Warnings: 0
   ```

3. 创建物化视图 `mv1_tbl2`，并开启当前物化视图的自动改写。

   ```sql
   CREATE MATERIALIZED VIEW mv1_tbl2 NEVER REFRESH ENABLE QUERY REWRITE AS SELECT * FROM tbl2;
   ```

4. 创建物化视图 `mv2_tbl2`，并开启当前物化视图的自动改写。

   ```sql
   CREATE MATERIALIZED VIEW mv2_tbl2 NEVER REFRESH ENABLE QUERY REWRITE AS SELECT * FROM tbl2 WHERE tbl2.col1 > 1;
   ```

5. 设置系统变量 `query_rewrite_integrity` 为 `stale_tolerated`。

    <main id="notice" type='explain'>
      <h4>说明</h4>
      <p><code>MV_REWRITE</code> 和 <code>NO_MV_REWRITE</code> Hint 的优先级高于系统变量 <code>query_rewrite_enabled</code>，因此不需要设置 <code>query_rewrite_enabled</code>。但是需要设置 <code>query_rewrite_integrity</code> 为 <code>stale_tolerated</code> 才可以使用非实时物化视图进行改写。</p>
    </main>

   ```sql
   SET query_rewrite_integrity = 'stale_tolerated';
   ```

6. 使用 `MV_REWRITE` Hint 用物化视图尝试进行改写，并跳过改写代价/规则检查。下面两条查询都将使用物化视图 `mv1_tbl2` 进行改写。

   * `/*+mv_rewrite*/` 将尝试使用符合改写条件的物化视图进行改写，一旦找到了符合改写要求的物化视图，后续的物化视图将不再被考虑，并跳过改写代价/规则检查。

     ```sql
     EXPLAIN SELECT /*+mv_rewrite*/ count(*), col1 FROM tbl2 WHERE tbl2.col1 > 1 GROUP BY col1;
     ```

     返回结果如下：

     ```shell
     +----------------------------------------------------------------------------------------------+
     | Query Plan                                                                                   |
     +----------------------------------------------------------------------------------------------+
     | =====================================================                                        |
     | |ID|OPERATOR         |NAME    |EST.ROWS|EST.TIME(us)|                                        |
     | -----------------------------------------------------                                        |
     | |0 |HASH GROUP BY    |        |1       |3           |                                        |
     | |1 |└─TABLE FULL SCAN|MV1_TBL2|1       |3           |                                        |
     | =====================================================                                        |
     | Outputs & filters:                                                                           |
     | -------------------------------------                                                        |
     |   0 - output([T_FUN_COUNT(*)], [MV1_TBL2.COL1]), filter(nil), rowset=16                      |
     |       group([MV1_TBL2.COL1]), agg_func([T_FUN_COUNT(*)])                                     |
     |   1 - output([MV1_TBL2.COL1]), filter([MV1_TBL2.COL1 > cast(1, NUMBER(-1, -85))]), rowset=16 |
     |       access([MV1_TBL2.COL1]), partitions(p0)                                                |
     |       is_index_back=false, is_global_index=false, filter_before_indexback[false],            |
     |       range_key([MV1_TBL2.__pk_increment]), range(MIN ; MAX)always true                      |
     +----------------------------------------------------------------------------------------------+
     14 rows in set
     ```

   * `/*+mv_rewrite(mv1_tbl2)*/` 将尝试使用 `mv2_tbl2` 进行改写，并跳过改写代价/规则检查。

     ```sql
     EXPLAIN SELECT /*+mv_rewrite(mv2_tbl2)*/ count(*), col1 FROM tbl2 WHERE tbl2.col1 > 1 GROUP BY col1;
     ```

     返回结果如下：

     ```shell
     +-------------------------------------------------------------------------+
     | Query Plan                                                              |
     +-------------------------------------------------------------------------+
     | =====================================================                   |
     | |ID|OPERATOR         |NAME    |EST.ROWS|EST.TIME(us)|                   |
     | -----------------------------------------------------                   |
     | |0 |HASH GROUP BY    |        |1       |3           |                   |
     | |1 |└─TABLE FULL SCAN|MV2_TBL2|1       |3           |                   |
     | =====================================================                   |
     | Outputs & filters:                                                      |
     | -------------------------------------                                   |
     |   0 - output([T_FUN_COUNT(*)], [MV2_TBL2.COL1]), filter(nil), rowset=16 |
     |       group([MV2_TBL2.COL1]), agg_func([T_FUN_COUNT(*)])                |
     |   1 - output([MV2_TBL2.COL1]), filter(nil), rowset=16                   |
     |       access([MV2_TBL2.COL1]), partitions(p0)                           |
     |       is_index_back=false, is_global_index=false,                       |
     |       range_key([MV2_TBL2.__pk_increment]), range(MIN ; MAX)always true |
     +-------------------------------------------------------------------------+
     14 rows in set
     ```

7. 虽然查询指定使用 `mv2_tbl2` 来查询改写，由于查询语句的 `WHERE` 条件不满足要求，`mv2_tbl2` 无法用于查询改写，所以此查询不会进行物化视图查询改写。

   ```sql
   EXPLAIN SELECT /*+mv_rewrite(mv2_tbl2)*/ count(*), col1 FROM tbl2 WHERE tbl2.col1 < 1 GROUP BY col1;
   ```

   返回结果如下：

   ```shell
   +--------------------------------------------------------------------------------------+
   | Query Plan                                                                           |
   +--------------------------------------------------------------------------------------+
   | =================================================                                    |
   | |ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|                                    |
   | -------------------------------------------------                                    |
   | |0 |HASH GROUP BY    |    |1       |3           |                                    |
   | |1 |└─TABLE FULL SCAN|TBL2|1       |3           |                                    |
   | =================================================                                    |
   | Outputs & filters:                                                                   |
   | -------------------------------------                                                |
   |   0 - output([T_FUN_COUNT(*)], [TBL2.COL1]), filter(nil), rowset=16                  |
   |       group([TBL2.COL1]), agg_func([T_FUN_COUNT(*)])                                 |
   |   1 - output([TBL2.COL1]), filter([TBL2.COL1 < cast(1, NUMBER(-1, -85))]), rowset=16 |
   |       access([TBL2.COL1]), partitions(p0)                                            |
   |       is_index_back=false, is_global_index=false, filter_before_indexback[false],    |
   |       range_key([TBL2.__pk_increment]), range(MIN ; MAX)always true                  |
   +--------------------------------------------------------------------------------------+
   14 rows in set
   ```

8. 使用 `/*+ no_mv_rewrite*/` Hint，不会进行物化视图查询改写。

   ```sql
   EXPLAIN SELECT /*+no_mv_rewrite*/ count(*), col1 FROM tbl2 WHERE tbl2.col1 > 1 GROUP BY col1;
   ```

   返回结果如下：

   ```shell
   +--------------------------------------------------------------------------------------+
   | Query Plan                                                                           |
   +--------------------------------------------------------------------------------------+
   | =================================================                                    |
   | |ID|OPERATOR         |NAME|EST.ROWS|EST.TIME(us)|                                    |
   | -------------------------------------------------                                    |
   | |0 |HASH GROUP BY    |    |1       |3           |                                    |
   | |1 |└─TABLE FULL SCAN|TBL2|1       |3           |                                    |
   | =================================================                                    |
   | Outputs & filters:                                                                   |
   | -------------------------------------                                                |
   |   0 - output([T_FUN_COUNT(*)], [TBL2.COL1]), filter(nil), rowset=16                  |
   |       group([TBL2.COL1]), agg_func([T_FUN_COUNT(*)])                                 |
   |   1 - output([TBL2.COL1]), filter([TBL2.COL1 > cast(1, NUMBER(-1, -85))]), rowset=16 |
   |       access([TBL2.COL1]), partitions(p0)                                            |
   |       is_index_back=false, is_global_index=false, filter_before_indexback[false],    |
   |       range_key([TBL2.__pk_increment]), range(MIN ; MAX)always true                  |
   +--------------------------------------------------------------------------------------+
   14 rows in set
   ```

## `NO_PARALLEL` Hint

`NO_PARALLEL` Hint 指定关闭查询并行 （即设置并行度为 1）。其反向 Hint 是 `PARALLEL` Hint。

`NO_PARALLEL` Hint 与 `/*+ parallel(1)*/` 等价。

### 语法

```sql
/*+ NO_PARALLEL */
```

### 示例

下方的查询示例中，使用 `NO_PARALLEL` Hint 关闭查询并行。

```sql
SELECT /*+ no_parallel */ c1, sum(distinct c2) FROM t1 GROUP BY c1;
```

## `NO_QUERY_TRANSFORMATION` Hint

`NO_QUERY_TRANSFORMATION` Hint 禁止对当前查询进行任何查询改写。

需要注意的是，区别于 Query Block Hint 中的 `NO_REWRITE` Hint，使用 `NO_QUERY_TRANSFORMATION` 无法使用 Query Block Hint 开启一些改写。

有关查询改写，参见[查询改写概述](../../../../../../../../1000.performance-tuning-guide/500.sql-optimization/400.sql-optimization/500.query-rewrite/100.query-rewrite-overview.md)。

### 语法

```sql
/*+ NO_QUERY_TRANSFORMATION */
```

### 示例

下方的查询示例中，使用 `NO_QUERY_TRANSFORMATION` Hint 禁止任何查询改写。

```sql
SELECT /*+ NO_QUERY_TRANSFORMATION */ *
FROM (SELECT * FROM t1) v WHERE v.c1 = 3;
```

## `OPT_PARAM` Hint

`OPT_PARAM` Hint 指定在查询级别更新一些优化器相关的配置项/系统变量。

### 语法

```sql
/*+ OPT_PARAM ( parameter_name [,] parameter_value ) */
```

#### 参数解释

* `parameter_name`：指配置项或系统变量名。
* `parameter_value`：指需要指定的变量值。
`OPT_PARAM` Hint 对如下参数有效：
* `rowsets_enabled`: 开启/关闭向量化，数据类型是 `VARCHAR`，取值范围为 `'TRUE'` 和 `'FALSE'`，取值需要用单引号（''）包裹。
* `rowsets_max_rows`: 设置批量返回行数 `batch_size` 大小，数据类型是 `INT`，取值范围为 `[0, 65535]`，取值不能用单引号（''）包裹。
* `enable_newsort`: 允许查询中开启/关闭 newsort 优化，数据类型是 `VARCHAR`，取值范围为 `'TRUE'` 和 `'FALSE'`，取值需要用单引号（''）包裹。
* `use_part_sort_mgb`: 允许查询中开启/关闭 part sort merge group by，数据类型是 `VARCHAR`，取值范围为 `'TRUE'` 和 `'FALSE'`，取值需要用单引号（''）包裹。
* `enable_in_range_optimization`: 允许查询中开启/关闭 in 优化，数据类型是 `VARCHAR`，取值范围为 `'TRUE'` 和 `'FALSE'`，取值需要用单引号（''）包裹。
* `xsolapi_generate_with_clause`: 允许查询中开启/关闭 cte 抽取改写，数据类型是 `VARCHAR`，取值范围为 `'TRUE'` 和 `'FALSE'`，取值需要用单引号（''）包裹。
* `preserve_order_for_pagination`: 运行为分页查询添加 `order by` 保序/禁止添加 `order by`，数据类型是 `VARCHAR`，取值范围为 `'TRUE'` 和 `'FALSE'`，取值需要用单引号（''）包裹。
* `storage_card_estimation`: 是否使用存储层估行，数据类型是 `VARCHAR`，取值范围为 `'TRUE'` 和 `'FALSE'`，取值需要用单引号（''）包裹。
* `workarea_size_policy`: 用于设置手动或者自动调整 SQL 工作区大小的策略。，数据类型是 `VARCHAR`，取值范围为 `'MANUAL'` 表示手动调整和 `'AUTO'` 表示自动调整，取值需要用单引号（''）包裹。
* `enable_rich_vector_format`: 用于开关向量化 2.0（session 级别参数），数据类型是 `VARCHAR`，取值范围为 `'TRUE'` 和 `'FALSE'`，取值需要用单引号（''）包裹。
* `spill_compression_codec`: 用于指定需要临时物化的算子选用的压缩算法，数据类型是 `VARCHAR`，取值为`NONE`、`LZ4`、`SNAPPY`、`ZLIB`、`ZSTD` ,代表不同的压缩算法。默认为 `NONE`，表示不进行压缩。
* `inlist_rewrite_threshold`: 允许触发 `inlist` 改写成 `values statement` 的常量个数阈值，数据类型是 `INT64`，取值范围为 `[1, 2147483647]`。

### 示例

对下方查询，使用 `OPT_PARAM` Hint 指定 `enable_in_range_optimization` 值对当前查询开启 IN 优化。

```shell
SELECT /*+ opt_param('enable_in_range_optimization', 'true') */ *
from t1
where c1 in (1,2,3,4,5,...,1000)
and c2 in (1,2,3,4,5,...,1000);
```

## `PARALLEL` Hint

`PARALLEL` Hint 作为全局 Hint 时可以指定当前查询使用的并行度或并行开启策略。

`PARALLEL` Hint 除了作为全局 Hint 外，还可以作为查询块 Hint 指定表级别的并行度，详见 [Access Path Hints](../200.optimizer-hint-of-oracle-mode/100.the-hint-related-to-the-access-path-of-oracle-mode.md) 中 `Parallel` hint 相关内容。

### 语法

```sql
/*+ PARALLEL ( AUTO | MANUAL | parallel_degree) */
```

#### 参数解释

- `AUTO` 或 `MANUAL`：`PARALLEL` Hint 中使用 `AUTO`或 `MANUAL` 作为参数时，仅指定并行执行开启策略，详见[并行开启方式及优先级](../../../../../../../../1000.performance-tuning-guide/500.sql-optimization/300.distributed-execution-plan/500.parallel-execution.md)。

- `parallel_degree`：`PARALLEL` Hint 中使用 `parallel_degree` 作为参数时，可以直接指定并行度时。

### 示例

下方的查询示例中，使用 `PARALLEL` Hint 指定使用并行度 DOP = 8 或指定开启 Auto DOP。

```sql
SELECT /*+parallel(8)*/ c1, SUM(distinct c2) FROM t1 GROUP BY c1;

SELECT /*+parallel(auto)*/ c1, SUM(distinct c2) FROM t1 GROUP BY c1;
```

> 注意：一些场景不支持并行执行，即使通过 PARALLEL 指定开启并行，执行计划仍可能禁用并行执行。

## `QUERY_TIMEOUT` Hint

`QUERY_TIMEOUT` Hint 指定当前查询的执行超时时间。

### 语法

```sql
/*+ QUERY_TIMEOUT ( time_usec ) */
```

#### 参数解释

- `time_usec`：指查询超时时间，单位为微秒。

### 示例

```sql
--指定查询超时时间为 1 秒，该查询在指定超时时间内未执行完成将返回超时错误。
SELECT /*+ QUERY_TIMEOUT(1000000) */ *
FROM employees e
WHERE e.department_id = 1001;
```

## `READ_CONSISTENCY` Hint

`READ_CONSISTENCY` Hint 指定当前查询的读一致性级别。

### 语法

```sql
/*+ READ_CONSISTENCY(WEAK[STRONG]) */
```

#### 参数解释

- `WEAK`：开启使用弱一致性，即开启弱读。

- `STRONG`：开启使用强一致性，即关闭弱读。

### 示例

```sql
--使用 READ_CONSISTENCY Hint 并设置为 WEAK，指定查询开启弱读。
SELECT /*+ READ_CONSISTENCY(WEAK) */ *
FROM employees
WHERE employees.department_id = 1001;
```

## `RESOURCE_GROUP` Hint

`RESOURCE_GROUP` Hint 强制指定该条语句所使用的资源组。

### 语法

`RESOURCE_GROUP` Hint 的语法如下：

```sql
/*+ RESOURCE_GROUP ('resource_group_name') */
```

#### 参数解释

- `resource_group_name` 表示待指定的资源组名。

### 示例

使用 RESOURCE_GROUP Hint 的示例如下：

```shell
obclient> SELECT /*+ RESOURCE_GROUP('big_group') */ * FROM t1;
```

该示例中，如果资源组 `big_group` 不存在，则使用当前默认的资源组。

## `STAT` Hint

`STAT` Hint 指定对查询计划中特定算子输出进行追踪。

添加 `STAT` Hint 后，查询计划中会分配 `MONITORING DUMP` 算子，该算子直接输出子节点算子的所有数据，并在执行结束后将算子执行时间、输出行数等信息打印在 observer 日志中。

### 语法

```sql
/*+ STAT(TRACING_NUM_LIST) */
```

#### 参数解释

- `TRACING_NUM_LIST`：为需要追踪算子的 ID 列表。

### 示例

```sql
-- 添加 Hint `/*+ STAT(0, 2) */` 前后执行计划变化情况
explain basic
SELECT /*+leading(t1) use_hash(t2)*/ * FROM t1, t2 WHERE t1.c1 = t2.c1;

Query Plan
===========================
|ID|OPERATOR         |NAME|
---------------------------
|0 |HASH JOIN        |    |
|1 |├─TABLE FULL SCAN|T1  |
|2 |└─TABLE FULL SCAN|T2  |
===========================

explain basic
SELECT /*+leading(t1) use_hash(t2) stat(0, 2)*/ *
FROM t1, t2 where t1.c1 = t2.c1;
Query Plan
===============================
|ID|OPERATOR             |NAME|
-------------------------------
|0 |MONITORING DUMP      |    |
|1 |└─HASH JOIN          |    |
|2 |  ├─TABLE FULL SCAN  |T1  |
|3 |  └─MONITORING DUMP  |    |
|4 |    └─TABLE FULL SCAN|T2  |
===============================
```

## `TRANS_PARAM` Hint

`TRANS_PARAM` Hint 用于在查询级别指定事务相关的参数。

### 语法

```sql
/*+ TRANS_PARAM ['FORCE_EARLY_LOCK_FREE' , 'TRUE'] */
```

#### 参数解释

现在支持的参数只有事务层面的提前解行锁 `FORCE_EARLY_LOCK_FREE` 参数。

- `FORCE_EARLY_LOCK_FREE`：取值为 **TRUE** 时，表示支持， **FALSE** 表示不支持。

**注意**：这里的参数名和参数值要用单引号（' '）引起来，当参数的值为数值型时可以不用引号引起来。

### 示例

```sql
-- 使用 TRANS_PARAM Hint 并设置参数 'FORCE_EARLY_LOCK_FREE' 为 'TRUE'，指定事务层面提前解行锁。
SELECT /*+ TRANS_PARAM('FORCE_EARLY_LOCK_FREE' 'TRUE') */ *
FROM employees e
WHERE e.department_id = 1001;
```

## `TRACING` Hint

`TRACING` Hint 指定对查询计划中特定算子输出进行追踪。

`TRACING` Hint 的使用方式、添加 Hint 后的计划形态和使用 `STAT` Hint 时完全相同。

与使用 `STAT` Hint 的区别在于，使用 `TRACING` Hint 时 `MONITORING DUMP` 算子会将其所有输出数据打印在 observer 日志中。

### 语法

```sql
/*+ TRACING(TRACING_NUM_LIST)*/
```

#### 参数解释

- `TRACING_NUM_LIST`：为需要追踪算子的 ID 列表。

### 示例

```sql
-- 使用 TRACING Hint 并设置级别为 1，启用对当前查询的跟踪
SELECT /*+ TRACING(1) */ *
FROM employees e
WHERE e.department_id = 1001;
```

## `USE_PLAN_CACHE` Hint

`USE_PLAN_CACHE` Hint 用于指定当前查询的计划缓存（Plan Cache）使用策略，更多有关计划缓存的信息，参见[执行计划缓存](../../../../../../../../1000.performance-tuning-guide/500.sql-optimization/200.sql-execution-plan/300.execution-plan-cache.md)。

### 语法

```sql
/*+ USE_PLAN_CACHE ( NONE | DEFAULT ) */
```

#### 参数解释

- `NONE`：指定查询不使用计划缓存。

- `DEFAULT`：指定当前查询使用系统变量 [`ob_enable_plan_cache`](../../../../../../../../800.configuration-items-and-system-variables/200.system-variable/300.global-system-variable/7200.ob_enable_plan_cache-global.md) 控制计划缓存策略。

### 示例

```sql
-- 使用参数 `NONE`时指定查询不使用计划缓存，使用参数 `DEFAULT`时指定当前查询使用系统变量 `ob_enable_plan_cache` 控制计划缓存策略。
SELECT /*+ USE_PLAN_CACHE(NONE) */ *
FROM employees e
WHERE e.department_id = 1001;

SELECT /*+ USE_PLAN_CACHE(DEFAULT) */ *
FROM employees e
WHERE e.department_id = 1001;
```