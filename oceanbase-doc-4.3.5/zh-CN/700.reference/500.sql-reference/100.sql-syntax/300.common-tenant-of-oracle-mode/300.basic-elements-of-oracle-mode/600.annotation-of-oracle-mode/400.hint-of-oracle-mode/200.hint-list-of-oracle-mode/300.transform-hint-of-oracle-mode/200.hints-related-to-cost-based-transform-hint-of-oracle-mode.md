| Description   |                 |
|---------------|-----------------|
| keywords      |                 |
| dir-name      |Cost Based Transform Hint |
| dir-name-en   |                 |
| tenant-type   | Oracle Mode     |
|machine-translation||

# Transform Hint 类型下的 Cost Based Transform Hint

在 SQL 查询中，与成本估算相关的 Hint 指定优化器在某些情况下采用或避免特定的查询转换，如改写查询结构、合并或不合并视图等。

| Hint 类型          | 描述                                                                                                                    |
|--------------------|-------------------------------------------------------------------------------------------------------------------------|
| `COALESCE_SQ`        | 指定对查询中的子查询进行合并改写。它的反向操作为 `NO_COALESCE_SQ`。            |
| `NO_COALESCE_SQ`     | 禁止子查询合并查询改写。它的反向操作为 `COALESCE_SQ`。          |
| `MERGE`              | 允许合并视图。它的反向操作为 `NO_MERGE`。    |
| `NO_MERGE`           | 不允许将外部查询和任何内联视图查询合并到单个查询中。它的反向操作为 `MERGE`。    |
| `NO_EXPAND`          | 禁止对包含 `OR` 条件的 `WHERE` 子句进行查询展开改写。它的反向操作为 `USE_CONCAT`。      |
| `USE_CONCAT`         | 启用对包含 `OR` 条件的 `WHERE` 子句进行查询展开改写。它的反向操作为 `NO_EXPAND`。|
| `PLACE_GROUP_BY`     | 启用 `Group By` 下压查询改写。它的反向操作为 `NO_PLACE_GROUP_BY`。                     |
| `NO_PLACE_GROUP_BY`  | 禁用 `Group By` 下压查询改写。它的反向操作为 `PLACE_GROUP_BY`。            |
| `SEMI_TO_INNER`      | 优化含有 EXISTS 或 IN 的半连接查询，将它们转化为内连接查询。它的反向操作为 `NO_SEMI_TO_INNER`。     |
| `NO_SEMI_TO_INNER`   | 阻止优化器不要将半连接查询转化为内连接查询。它的反向操作为`SEMI_TO_INNER`。               |
| `WIN_MAGIC`          | 启用 `WIN MAGIC` 查询改写，将满足特定场景的聚合、自连接查询消除连接后使用窗口函数进行优化。使用此 Hint 可以指导优化器去除不必要的连接，并用窗口函数替代。它的反向操作为 `NO_WIN_MAGIC`。     |
| `NO_WIN_MAGIC`       | 禁用 `WIN MAGIC` 查询改写。它的反向操作为 `WIN_MAGIC`。                    |

## `COALESCE_SQ` Hint

`COALESCE_SQ` Hint 指定对查询中的子查询进行合并改写。它的反向操作是 `NO_COALESCE_SQ` Hint。

### 语法

```sql
/*+ COALESCE_SQ [ ( [ @ qb_name ] [ qb_name_list ] ) ] */
```

#### 参数解释

- `qb_name_list`：可选，代表一个或多个 Query Block 的名称列表，可以指定对特定的 Query Block 进行子查询合并，当参数缺省时，Hint 指定对所有可能合并的子查询进行合并。

### 示例

下方的查询示例中，`COALESCE_SQ(("SEL1", "SEL2"))` 指定仅对 `SEL1`, `SEL2` 两个 Query Block 进行合并。

```sql
UPDATE /*+ COALESCE_SQ(("SEL1", "SEL2")) */ t1
SET c1 = (SELECT /*+ QB_NAME(SEL1) */ c1 FROM t2 A),
    c2 = (SELECT /*+ QB_NAME(SEL2) */ c2 FROM t2 B),
    c3 = (SELECT /*+ QB_NAME(SEL3) */ c3 FROM t2 C),
    c4 = (SELECT /*+ QB_NAME(SEL4) */ c4 FROM t2 D);
```

## `NO_COALESCE_SQ` Hint

`NO_COALESCE_SQ` Hint 禁止子查询合并查询改写。它的反向操作是 `COALESCE_SQ` Hint。

### 语法

```sql
/*+ NO_COALESCE_SQ [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `qb_name`：可选，可以指定对特定的 Query Block 禁用子查询合并，当参数缺省时，Hint 指定对所有可能合并的子查询禁用合并。

### 示例

下方的查询示例中，使用 `NO_COALESCE_SQ` Hint 来避免任何子查询合并，维持原始的查询结构：

```sql
UPDATE /*+ NO_COALESCE_SQ */ t1
SET c1 = (SELECT /*+ QB_NAME(SEL1) */ c1 FROM t2 A),
    c2 = (SELECT /*+ QB_NAME(SEL2) */ c2 FROM t2 B),
    c3 = (SELECT /*+ QB_NAME(SEL3) */ c3 FROM t2 C),
    c4 = (SELECT /*+ QB_NAME(SEL4) */ c4 FROM t2 D);
```

## `MERGE` Hint

`MERGE` Hint 启用视图合并查询改写，涉及简单视图合并和复杂视图合并。它的反向操作是 `NO_MERGE` Hint。

### 语法

```sql
/*+ MERGE [ ( [ @ qb_name ] [ > upper_qb_name ] ) ] */
```

#### 参数解释

- `upper_qb_name`：为指定视图合并改写的具体形式，建议使用缺省值。

### 示例

下方的查询示例中，使用 `MERGE` Hint 来启用子查询的视图合并改写，`MERGE` Hint 和 `NO_REWRITE` Hint 结合使用，强制优化器合并视图，同时禁用其他类型的查询改写：

```sql
SELECT * FROM (SELECT /*+ MERGE NO_REWRITE */ * FROM t1);
```

## `NO_MERGE` Hint

`NO_MERGE` Hint 禁止视图合并查询改写。它的反向操作是 `MERGE` Hint。

### 语法

```sql
/*+ NO_MERGE [ ( [ @ qb_name ] ) ] */
```

### 示例

下方的查询示例中，使用 `NO_MERGE` Hint 禁用了子查询的视图合并改写：

```sql
SELECT * FROM (SELECT /*+ NO_MERGE */ * FROM t1);
```

## `NO_EXPAND` Hint

`NO_EXPAND` Hint 禁止对包含 `OR` 条件的 `WHERE` 子句进行查询展开改写。它的反向操作为 `USE_CONCAT` Hint。

### 语法

```sql
/*+ NO_EXPAND [ ( [ @ qb_name ] ) ] */
```

### 示例

```sql
-- 使用 NO_EXPAND Hint 来指示优化器不对包含 OR 条件的查询进行 OR 展开
SELECT /*+ NO_EXPAND */ *
  FROM employees e, departments d
  WHERE e.manager_id = 108
     OR d.department_id = 110;
```

## `USE_CONCAT` Hint

`USE_CONCAT` Hint 启用对包含 `OR` 条件的 `WHERE` 子句进行查询展开改写。它的反向操作为 `NO_EXPAND` Hint。

### 语法

```sql
/*+ USE_CONCAT [ ( [ @ qb_name ] [ expand_cond_str ] ) ] */
```

#### 参数解释

- `expand_cond_str`：可选，指定只对特定的 OR 条件进行查询展开改写。当参数缺省时，Hint 指定对所有 `OR` 条件进行查询改写。

### 示例

- 示例 1：使用 `USE_CONCAT` Hint 应用于第一个 `OR` 条件

```sql
SELECT /*+ USE_CONCAT('b.c1 = c.c1 OR b.c2 = c.c2') */ a.c1, b.c1, c.c1
FROM t1 a
LEFT JOIN (t1 b LEFT JOIN t1 c ON b.c3 = 4 AND (b.c1 = c.c1 OR b.c2 = c.c2))
ON a.c1 = b.c1
WHERE (a.c2 = 3 OR a.c3 = 4)
  AND EXISTS (SELECT * FROM t1 d WHERE a.c1 = d.c1 OR a.c2 = d.c2);
```

- 示例 2：使用 `USE_CONCAT` Hint 来改写第二个 `OR` 条件

```sql
SELECT /*+ USE_CONCAT('a.c2 = 3 OR a.c3 = 4') */ a.c1, b.c1, c.c1
FROM t1 a
LEFT JOIN (t1 b LEFT JOIN t1 c ON b.c3 = 4 AND (b.c1 = c.c1 OR b.c2 = c.c2))
ON a.c1 = b.c1
WHERE (a.c2 = 3 OR a.c3 = 4)
  AND EXISTS (SELECT * FROM t1 d WHERE a.c1 = d.c1 OR a.c2 = d.c2);
```

- 示例 3：使用 `USE_CONCAT` Hint 对 `EXISTS` 子句中的 `OR` 条件进行改写

```sql
SELECT /*+ USE_CONCAT('a.c1 = VIEW1.d.c1 OR a.c2 = VIEW1.d.c2') */ a.c1, b.c1, c.c1
FROM t1 a
LEFT JOIN (t1 b LEFT JOIN t1 c ON b.c3 = 4 AND (b.c1 = c.c1 OR b.c2 = c.c2))
ON a.c1 = b.c1
WHERE (a.c2 = 3 OR a.c3 = 4)
  AND EXISTS (SELECT * FROM t1 d WHERE a.c1 = d.c1 OR a.c2 = d.c2);
```

## `PLACE_GROUP_BY` Hint

`PLACE_GROUP_BY` Hint 启用 `Group By` 下压查询改写，在某些情况下可以减少需要分组和聚合的数据量。它的反向操作为 `NO_PLACE_GROUP_BY` Hint。

### 语法

```sql
/*+ PLACE_GROUP_BY [ ( [ @ qb_name ] [ ( table_list ) ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定应用 Hint 的查询块。
- `table_list`：可选，可以指定对特定连接表进行 `Group By` 下压，当参数缺省时，Hint 指定对所有连接表尝试进行 `Group By` 下压。

### 示例

下方查询示例中，`PLACE_GROUP_BY` Hint 指示优化器尝试在执行计划中更优的位置处理 `GROUP BY` 子句。

```sql
SELECT /*+ PLACE_GROUP_BY */ SUM(t2.c3)
FROM t1
JOIN t2 ON t1.c2 = t2.c2
GROUP BY t1.c2;
```

## `NO_PLACE_GROUP_BY` Hint

`NO_PLACE_GROUP_BY` Hint 禁用 `Group By` 下压查询改写。它的反向操作为 `PLACE_GROUP_BY` Hint。

### 语法

```sql
/*+ NO_PLACE_GROUP_BY [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定应用 Hint 的查询块。

### 示例

下方查询示例中，`NO_PLACE_GROUP_BY` Hint 确保 `GROUP BY` 操作发生在原始的查询层次上，不进行任何改写。

```sql
SELECT /*+ NO_PLACE_GROUP_BY */ SUM(t2.c3)
FROM t1
JOIN t2 ON t1.c2 = t2.c2
GROUP BY t1.c2;
```

## `SEMI_TO_INNER` Hint

`SEMI_TO_INNER` Hint 启用含有 `EXISTS` 或 `IN` 的半连接查询，将它们转化为内连接查询。它的反向操作为 `NO_SEMI_TO_INNER` Hint。

### 语法

```sql
/*+ SEMI_TO_INNER [ ( [ @ qb_name ] [ table ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定应用 Hint 的查询块。
- `table`：可选，可以指定半连接右表，对特定半连接进行查询改写。当参数缺省时，Hint 指定对所有半连接进行查询改写，使用 Hint 时推荐不指定该参数。

### 示例

下方查询示例中，`SEMI_TO_INNER(t2)` Hint 提示优化器尝试将 t1 和 t2 之间的半连接转化成更高效的内连接。

```sql
SELECT /*+ SEMI_TO_INNER(t2) */ *
FROM t1
WHERE EXISTS (SELECT 1 FROM t2 WHERE t1.c1 = t2.c2);
```

## `NO_SEMI_TO_INNER` Hint

`NO_SEMI_TO_INNER` Hint 禁用将半连接查询转化为内连接查询。它的反向操作为 `SEMI_TO_INNER` Hint。

### 语法

```sql
/*+ NO_SEMI_TO_INNER [ ( [ @ qb_name ]  ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定应用 Hint 的查询块。

### 示例

下方查询示例中，使用 `NO_SEMI_TO_INNER` Hint 确保了在推导结果集时，优化器不会尝试将 `EXISTS` 子句的半连接转化为内连接。

```sql
SELECT /*+ NO_SEMI_TO_INNER */ *
FROM t1
WHERE EXISTS (SELECT 1 FROM t2 WHERE t1.c1 = t2.c2);
```

## `WIN_MAGIC` Hint

`WIN_MAGIC` Hint 用于启用 `WIN MAGIC` 查询改写，将满足特定场景的聚合、自连接查询消除连接后使用窗口函数进行优化。使用此 Hint 可以指导优化器去除不必要的连接，并用窗口函数替代，从而改善查询执行效率。它的反向操作为 `NO_WIN_MAGIC` Hint。

### 语法

```sql
/*+ WIN_MAGIC [ ( [ @ qb_name ] [ table_list ] ) ] */
```

#### 参数解释

- `table_list`：可选，指定哪些表应该参与 `WIN_MAGIC` 查询改写操作。当参数缺省时，Hint 指定对所有表尝试进行查询改写。

### 示例

下方查询示例中，`WIN_MAGIC(t1 v)` 指示优化器针对 t1 表和衍生表 v 尝试应用窗口函数来优化处理。

```sql
SELECT /*+ WIN_MAGIC(t1 v) */ *
FROM t1
JOIN (SELECT AVG(c1), c2 FROM t1 GROUP BY c2) v ON t1.c2 = v.c2
ORDER BY t1.pk;
```

## `NO_WIN_MAGIC` Hint

`NO_WIN_MAGIC` Hint 用于禁用 `WIN MAGIC` 查询改写。它的反向操作为 `WIN_MAGIC` Hint。

### 语法

```sql
/*+ NO_WIN_MAGIC [ ( [ @ qb_name ] ) ] */
```

### 示例

下方查询示例中，使用 `NO_WIN_MAGIC` Hint 保持查询原样不变，避免通过窗口函数进行改写。

```sql
SELECT /*+ NO_WIN_MAGIC */ *
FROM t1
JOIN (SELECT AVG(c1), c2 FROM t1 GROUP BY c2) v ON t1.c2 = v.c2
ORDER BY t1.pk;
```