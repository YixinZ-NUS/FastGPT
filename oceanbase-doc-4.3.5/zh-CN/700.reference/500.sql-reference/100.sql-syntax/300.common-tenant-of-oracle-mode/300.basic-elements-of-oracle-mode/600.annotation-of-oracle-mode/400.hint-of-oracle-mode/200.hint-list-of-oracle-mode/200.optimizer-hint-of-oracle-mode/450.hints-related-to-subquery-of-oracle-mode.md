| Description   |                 |
|---------------|-----------------|
| keywords      |                 |
| dir-name      |Subquery Hint    |
| dir-name-en   |                 |
| tenant-type   | Oracle Mode     |
|machine-translation||

# Optimized Hint 类型下的 Subquery Hint

| Hint 类型                       | 描述                                                   |
|--------------------------------|---------------------------------------------------------|
| PQ_SUBQUERY                    |  提供了对并行处理中子查询行为的细粒度控制。   |
| PUSH_SUBQ                      | 用于指示优化器尽早执行未改写成连接的子查询。<main id="notice" type='explain'><h4>说明</h4><p>对于 OceanBase 数据库 V4.3.5 版本，从 V4.3.5 BP2 版本开始支持 <code>PUSH_SUBQ</code> Hint。</p></main>|
| NO_PUSH_SUBQ                   | 是 `PUSH_SUBQ` 的反向操作，用于优化器将未改写成连接的子查询放在最后执行。<main id="notice" type='explain'><h4>说明</h4><p>对于 OceanBase 数据库 V4.3.5 版本，从 V4.3.5 BP2 版本开始支持 <code>NO_PUSH_SUBQ</code> Hint。</p></main>|

## PQ_SUBQUERY Hint

`PQ_SUBQUERY` Hint 提供了对并行处理中子查询行为的细粒度控制，指示优化器在并行查询（Parallel Query, PQ）环境下如何处理子查询，特别是在涉及分布式数据分发的情况下。

`PQ_SUBQUERY` Hint 包含两种主要控制方式：非精确控制方式和精确控制方式。

### 非精确控制方式

#### 语法

```sql
/*+ PQ_SUBQUERY ([ @qb_name ] [table_list] [op_order_no] sub_qb_name_list method_list) */
```

#### 参数描述

- `@qb_name`: 可选项，指定当前查询块的别名。
- `table_list`: 可选项，指代表的列表，仅在连接中分配的 subplan filter 方法中使用。
- `op_order_no`: 操作节点的顺序编号。
- `sub_qb_name_list`: 子查询块的别名列表。
- `method_list`: 分布式数据分发方式，具体分发方法如下：
  - `DIST_BASIC_METHOD`: 不指定具体方法。
  - `DIST_PARTITION_WISE`: 分区间分配数据，使用 `NONE NONE` 方法。
  - `DIST_PULL_TO_LOCAL`: 将数据拉取到本地，使用 `LOCAL LOCAL` 方法。
  - `DIST_PARTITION_NONE`: 分区处理，但未指定后续方法，使用 `PARTITION NONE`。
  - `DIST_NONE_ALL`: 不分区处理，将数据广播到所有节点，使用 `NONE ALL`。

### 示例

```sql
PQ_SUBQUERY(@SEL$1 0 SEL$1 PARTITION NONE) -- 可省略为 PQ_SUBQUERY(SEL$1)
PQ_SUBQUERY(@SEL$1 1 SEL$2 PARTITION NONE)

CREATE TABLE t1(c1 INT, c2 INT, c3 INT, c4 INT)
    PARTITION BY HASH(c1) PARTITIONS 10;

EXPLAIN
SELECT
  (SELECT t_inner.c1 FROM t1 t_inner WHERE t_inner.c1 = t_outer.c3) AS a
FROM t1 t_outer
ORDER BY c3;
```

返回结果如下所示：

```sql
+--------------------------------------------------------------------------------------------------+
| Query Plan                                                                                       |
+--------------------------------------------------------------------------------------------------+
| ==========================================================================                       |
| |ID|OPERATOR                              |NAME    |EST.ROWS|EST.TIME(us)|                       |
| --------------------------------------------------------------------------                       |
| |0 |PX COORDINATOR                        |        |3       |157         |                       |
| |1 |└─EXCHANGE OUT DISTR                  |:EX10002|3       |156         |                       |
| |2 |  └─SUBPLAN FILTER                    |        |3       |155         |                       |
| |3 |    ├─EXCHANGE IN DISTR               |        |3       |42          |                       |
| |4 |    │ └─EXCHANGE OUT DISTR (PKEY)     |:EX10001|3       |41          |                       |
| |5 |    │   └─EXCHANGE IN MERGE SORT DISTR|        |3       |40          |                       |
| |6 |    │     └─EXCHANGE OUT DISTR        |:EX10000|3       |40          |                       |
| |7 |    │       └─SORT                    |        |3       |39          |                       |
| |8 |    │         └─PX PARTITION ITERATOR |        |3       |38          |                       |
| |9 |    │           └─TABLE FULL SCAN     |t_outer |3       |38          |                       |
| |10|    └─PX PARTITION ITERATOR           |        |1       |38          |                       |
| |11|      └─TABLE FULL SCAN               |t_inner |1       |38          |                       |
| ==========================================================================                       |
| Outputs & filters:                                                                               |
| -------------------------------------                                                            |
|   0 - output([INTERNAL_FUNCTION(subquery(1))]), filter(nil), rowset=16                           |
|   1 - output([INTERNAL_FUNCTION(subquery(1))]), filter(nil), rowset=16                           |
|       dop=1                                                                                      |
|   2 - output([subquery(1)]), filter(nil), rowset=16                                              |
|       exec_params_([t_outer.c3(:0)]), onetime_exprs_(nil), init_plan_idxs_(nil), use_batch=false |
|   3 - output([t_outer.c3]), filter(nil), rowset=16                                               |
|   4 - output([t_outer.c3]), filter(nil), rowset=16                                               |
|       (#keys=1, [t_outer.c3]), is_single, dop=1                                                  |
|   5 - output([t_outer.c3]), filter(nil), rowset=16                                               |
|       sort_keys([t_outer.c3, ASC])                                                               |
|   6 - output([t_outer.c3]), filter(nil), rowset=16                                               |
|       dop=1                                                                                      |
|   7 - output([t_outer.c3]), filter(nil), rowset=16                                               |
|       sort_keys([t_outer.c3, ASC])                                                               |
|   8 - output([t_outer.c3]), filter(nil), rowset=16                                               |
|       force partition granule                                                                    |
|   9 - output([t_outer.c3]), filter(nil), rowset=16                                               |
|       access([t_outer.c3]), partitions(p[0-9])                                                   |
|       is_index_back=false, is_global_index=false,                                                |
|       range_key([t_outer.__pk_increment]), range(MIN ; MAX)always true                           |
|  10 - output([t_inner.c1]), filter(nil), rowset=16                                               |
|       affinitize, partition wise, force partition granule                                        |
|  11 - output([t_inner.c1]), filter([t_inner.c1 = :0]), rowset=16                                 |
|       access([t_inner.c1]), partitions(p[0-9])                                                   |
|       is_index_back=false, is_global_index=false, filter_before_indexback[false],                |
|       range_key([t_inner.__pk_increment]), range(MIN ; MAX)always true                           |
+--------------------------------------------------------------------------------------------------+
44 rows in set
```

### 精确控制方式

#### 语法

```sql
/*+ PQ_SUBQUERY ([ @qb_name ] win_group ...) */
```

#### 参数解释

- `win_group`: (索引列表) 声明窗口函数的分组及内部行为的元组。
  - `dist_method`: 指定分布式执行方式，可选项同上。
  - `PARTITION_SORT`: 是否在使用哈希分布式执行（`HASH`）或无分布式执行（`NONE`）时应用 partition sort 算法，默认不使用。
  - `PUSHDOWN`: 在使用哈希分布式执行时是否应用窗口函数下压。

#### 示例

```sql
PQ_SUBQUERY (@SEL$1 (t_a t_b t_c) 0 SEL$2 PARTITION NONE)
-- 可省略表示为 PQ_SUBQUERY ((t_a t_b t_c) SEL$2 PARTITION NONE)

EXPLAIN
SELECT /*+ PQ_SUBQUERY (@SEL$1 (t_a, t_b, t_c) 0 SEL$2 PARTITION NONE) */
  t_a.c1 AS a_c1,
  t_b.c1 AS b_c1,
  t_c.c1 AS c_c1,
  t_d.c1 AS d_c1
FROM t1 t_a
LEFT JOIN t1 t_b ON t_a.c3 = t_b.c4
INNER JOIN t1 t_c ON t_a.c1 = t_c.c1
RIGHT JOIN t1 t_d ON t_a.c3 = t_d.c4
WHERE t_a.c1 = t_d.c3
  AND t_c.c2 + (SELECT c4 FROM t1 WHERE c1 = t_c.c3 AND c2 = t_a.c2 AND c3 = t_b.c1) = t_a.c3;
```

返回结果如下所示：

```sql
+--------------------------------------------------------------------------------------------------------------------------+
| Query Plan                                                                                                               |
+--------------------------------------------------------------------------------------------------------------------------+
| ===========================================================================                                              |
| |ID|OPERATOR                               |NAME    |EST.ROWS|EST.TIME(us)|                                              |
| ---------------------------------------------------------------------------                                              |
| |0 |PX COORDINATOR                         |        |1       |302         |                                              |
| |1 |└─EXCHANGE OUT DISTR                   |:EX10004|1       |300         |                                              |
| |2 |  └─SUBPLAN FILTER                     |        |1       |298         |                                              |
| |3 |    ├─EXCHANGE IN DISTR                |        |3       |184         |                                              |
| |4 |    │ └─EXCHANGE OUT DISTR (PKEY)      |:EX10003|3       |180         |                                              |
| |5 |    │   └─HASH JOIN                    |        |3       |172         |                                              |
| |6 |    │     ├─EXCHANGE IN DISTR          |        |3       |43          |                                              |
| |7 |    │     │ └─EXCHANGE OUT DISTR       |:EX10000|3       |42          |                                              |
| |8 |    │     │   └─PX PARTITION ITERATOR  |        |3       |38          |                                              |
| |9 |    │     │     └─TABLE FULL SCAN      |t_d     |3       |38          |                                              |
| |10|    │     └─HASH RIGHT OUTER JOIN      |        |3       |128         |                                              |
| |11|    │       ├─EXCHANGE IN DISTR        |        |3       |41          |                                              |
| |12|    │       │ └─EXCHANGE OUT DISTR     |:EX10001|3       |40          |                                              |
| |13|    │       │   └─PX PARTITION ITERATOR|        |3       |38          |                                              |
| |14|    │       │     └─TABLE FULL SCAN    |t_b     |3       |38          |                                              |
| |15|    │       └─EXCHANGE IN DISTR        |        |3       |86          |                                              |
| |16|    │         └─EXCHANGE OUT DISTR     |:EX10002|3       |84          |                                              |
| |17|    │           └─PX PARTITION ITERATOR|        |3       |78          |                                              |
| |18|    │             └─HASH JOIN          |        |3       |78          |                                              |
| |19|    │               ├─TABLE FULL SCAN  |t_a     |3       |38          |                                              |
| |20|    │               └─TABLE FULL SCAN  |t_c     |3       |38          |                                              |
| |21|    └─PX PARTITION ITERATOR            |        |1       |39          |                                              |
| |22|      └─TABLE FULL SCAN                |t1      |1       |39          |                                              |
| ===========================================================================                                              |
| Outputs & filters:                                                                                                       |
| -------------------------------------                                                                                    |
|   0 - output([INTERNAL_FUNCTION(t_a.c1, t_b.c1, t_c.c1, t_d.c1)]), filter(nil), rowset=16                                |
|   1 - output([INTERNAL_FUNCTION(t_a.c1, t_b.c1, t_c.c1, t_d.c1)]), filter(nil), rowset=16                                |
|       dop=1                                                                                                              |
|   2 - output([t_b.c1], [t_a.c1], [t_d.c1], [t_c.c1]), filter([t_c.c2 + subquery(1) = t_a.c3]), rowset=16                 |
|       exec_params_([t_c.c3(:0)], [t_a.c2(:1)], [t_b.c1(:2)]), onetime_exprs_(nil), init_plan_idxs_(nil), use_batch=false |
|   3 - output([t_b.c1], [t_c.c3], [t_a.c2], [t_a.c1], [t_a.c3], [t_d.c1], [t_c.c1], [t_c.c2]), filter(nil), rowset=16     |
|   4 - output([t_b.c1], [t_c.c3], [t_a.c2], [t_a.c1], [t_a.c3], [t_d.c1], [t_c.c1], [t_c.c2]), filter(nil), rowset=16     |
|       (#keys=1, [t_c.c3]), is_single, dop=1                                                                              |
|   5 - output([t_b.c1], [t_c.c3], [t_a.c2], [t_a.c1], [t_a.c3], [t_d.c1], [t_c.c1], [t_c.c2]), filter(nil), rowset=16     |
|       equal_conds([t_a.c1 = t_d.c3], [t_a.c3 = t_d.c4]), other_conds(nil)                                                |
|   6 - output([t_d.c1], [t_d.c4], [t_d.c3]), filter(nil), rowset=16                                                       |
|   7 - output([t_d.c1], [t_d.c4], [t_d.c3]), filter(nil), rowset=16                                                       |
|       dop=1                                                                                                              |
|   8 - output([t_d.c1], [t_d.c4], [t_d.c3]), filter(nil), rowset=16                                                       |
|       force partition granule                                                                                            |
|   9 - output([t_d.c1], [t_d.c4], [t_d.c3]), filter(nil), rowset=16                                                       |
|       access([t_d.c1], [t_d.c4], [t_d.c3]), partitions(p[0-9])                                                           |
|       is_index_back=false, is_global_index=false,                                                                        |
|       range_key([t_d.__pk_increment]), range(MIN ; MAX)always true                                                       |
|  10 - output([t_b.c1], [t_c.c3], [t_a.c2], [t_a.c1], [t_a.c3], [t_c.c1], [t_c.c2]), filter(nil), rowset=16               |
|       equal_conds([t_a.c3 = t_b.c4]), other_conds(nil)                                                                   |
|  11 - output([t_b.c1], [t_b.c4]), filter(nil), rowset=16                                                                 |
|  12 - output([t_b.c1], [t_b.c4]), filter(nil), rowset=16                                                                 |
|       dop=1                                                                                                              |
|  13 - output([t_b.c1], [t_b.c4]), filter(nil), rowset=16                                                                 |
|       force partition granule                                                                                            |
|  14 - output([t_b.c1], [t_b.c4]), filter(nil), rowset=16                                                                 |
|       access([t_b.c1], [t_b.c4]), partitions(p[0-9])                                                                     |
|       is_index_back=false, is_global_index=false,                                                                        |
|       range_key([t_b.__pk_increment]), range(MIN ; MAX)always true                                                       |
|  15 - output([t_c.c3], [t_a.c2], [t_a.c1], [t_a.c3], [t_c.c1], [t_c.c2]), filter(nil), rowset=16                         |
|  16 - output([t_c.c3], [t_a.c2], [t_a.c1], [t_a.c3], [t_c.c1], [t_c.c2]), filter(nil), rowset=16                         |
|       dop=1                                                                                                              |
|  17 - output([t_c.c3], [t_a.c2], [t_a.c1], [t_a.c3], [t_c.c1], [t_c.c2]), filter(nil), rowset=16                         |
|       partition wise, force partition granule                                                                            |
|  18 - output([t_c.c3], [t_a.c2], [t_a.c1], [t_a.c3], [t_c.c1], [t_c.c2]), filter(nil), rowset=16                         |
|       equal_conds([t_a.c1 = t_c.c1]), other_conds(nil)                                                                   |
|  19 - output([t_a.c1], [t_a.c3], [t_a.c2]), filter(nil), rowset=16                                                       |
|       access([t_a.c1], [t_a.c3], [t_a.c2]), partitions(p[0-9])                                                           |
|       is_index_back=false, is_global_index=false,                                                                        |
|       range_key([t_a.__pk_increment]), range(MIN ; MAX)always true                                                       |
|  20 - output([t_c.c1], [t_c.c3], [t_c.c2]), filter(nil), rowset=16                                                       |
|       access([t_c.c1], [t_c.c3], [t_c.c2]), partitions(p[0-9])                                                           |
|       is_index_back=false, is_global_index=false,                                                                        |
|       range_key([t_c.__pk_increment]), range(MIN ; MAX)always true                                                       |
|  21 - output([t1.c4]), filter(nil), rowset=16                                                                            |
|       affinitize, partition wise, force partition granule                                                                |
|  22 - output([t1.c4]), filter([t1.c1 = :0], [t1.c2 = :1], [t1.c3 = :2]), rowset=16                                       |
|       access([t1.c1], [t1.c2], [t1.c3], [t1.c4]), partitions(p[0-9])                                                     |
|       is_index_back=false, is_global_index=false, filter_before_indexback[false,false,false],                            |
|       range_key([t1.__pk_increment]), range(MIN ; MAX)always true                                                        |
+--------------------------------------------------------------------------------------------------------------------------+
80 rows in set
```

## PUSH_SUBQ Hint

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>对于 OceanBase 数据库 V4.3.5 版本，从 V4.3.5 BP2 版本开始支持 <code>PUSH_SUBQ</code> Hint。</p>
</main>

`PUSH_SUBQ` Hint 用于指示优化器尽早执行未改写成连接的子查询，通常这些子查询如果不被改写成连接的话，会被放在执行计划的所有表连接计算之后。如果子查询计算成本低且能过滤大量数据，提前执行可能提升计划性能。但是要注意，如果子查询被改写成连接（`/+unnest/`），这个提示无效。适用场景如下：

* 子查询的执行开销较小，但能快速过滤大量数据。
* 需要尽早利用子查询的结果缩小数据范围。

**语法如下：**

```sql
/*+ PUSH_SUBQ[(@qb_name)] */
```

参数解释：

* `@qb_name`：可选参数，指定子查询的别名（详细介绍信息，可参见上文 **QB_NAME 参数**），用于明确提示作用的对象。如果省略，则默认对 Hint 所处的子查询生效。

**示例如下：**

在查询中使用 `PUSH_SUBQ` Hint 提示优化器尽早执行子查询，以提前过滤 `tbl1` 表的数据。

```sql
SELECT /*+ PUSH_SUBQ(@"SEL$2") */ *
FROM tbl1, tbl2
WHERE tbl1.col1 = (SELECT MAX(tbl3.col1)
                   FROM tbl3
                   WHERE tbl3.col2 = tbl2.col2);
```

## NO_PUSH_SUBQ Hint

<main id="notice" type='explain'>
  <h4>说明</h4>
  <p>对于 OceanBase 数据库 V4.3.5 版本，从 V4.3.5 BP2 版本开始支持 <code>NO_PUSH_SUBQ</code> Hint。</p>
</main>

`NO_PUSH_SUBQ` Hint 是 `PUSH_SUBQ` 的反向操作，用于优化器将未改写成连接的子查询放在最后执行。适用于子查询成本高或无法显著减少行数的情况。适用场景如下：

* 子查询的执行开销较大，或其结果对数据量的影响较小。
* 需要将子查询的执行延迟到其他过滤条件生效后再执行，以减少其输入数据量。

**语法如下：**

```sql
/*+ NO_PUSH_SUBQ[(@qb_name)] */
```

参数解释：

* `@qb_name`：可选参数，指定子查询的别名。

**示例如下：**

在查询中使用 `NO_PUSH_SUBQ` Hint 提示优化器将子查询推迟到最后执行。

```sql
SELECT /*+ NO_PUSH_SUBQ */ *
FROM tbl1, tbl2
WHERE tbl1.col1 = (SELECT MAX(tbl3.col1)
                   FROM tbl3
                   WHERE tbl3.col2 = tbl2.col2);
```