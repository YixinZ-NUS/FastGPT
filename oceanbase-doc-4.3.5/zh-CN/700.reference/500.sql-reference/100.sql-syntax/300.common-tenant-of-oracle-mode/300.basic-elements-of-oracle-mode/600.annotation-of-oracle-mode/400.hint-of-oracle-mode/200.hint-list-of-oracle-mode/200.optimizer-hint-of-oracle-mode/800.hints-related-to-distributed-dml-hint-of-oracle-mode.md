| Description   |                 |
|---------------|-----------------|
| keywords      |                 |
| dir-name      | Distributed DML Hint |
| dir-name-en   |                 |
| tenant-type   | Oracle Mode     |
|machine-translation||

# Optimized Hint 类型下的 Distributed DML Hint

在 Oracle 模式的 OceanBase 数据库中，使用分布式 DML Hint 可以控制 DML 操作是否采用分布式方式进行。请注意区分以下两个重要概念：

- 分布式 DML：专指在多个节点间执行的 DML 操作，与在单个节点上局部或 partition-wise 执行的非分布式 DML 操作有本质区别。
- 并行 DML：强调的是在单个节点内多线程并行执行一个 DML 操作的情况。

此外，尽管此类 Hint 可用于执行计划固定，不建议用户使用，一般情况下仅在 OUTLINE DATA 中启用。

| Hint 名称                              | 解释       |
|---------------------------------------|------------|
| `USE_DISTRIBUTED_DML`     |启用分布式 DML 操作。它的反向操作是 `NO_USE_DISTRIBUTED_DML`。  |
| `NO_USE_DISTRIBUTED_DML`  | 禁用分布式 DML 操作。它的反向操作是 `USE_DISTRIBUTED_DML`。    |

## `USE_DISTRIBUTED_DML` Hint

`USE_DISTRIBUTED_DML` Hint 启用分布式 DML 操作，启用此 Hint 后，DML 操作将采用分布式执行。它的反向操作是 `NO_USE_DISTRIBUTED_DML` Hint。

### 语法

```sql
/*+ USE_DISTRIBUTED_DML [ ( [ @ qb_name ] ) ] */
```

### 示例

```sql
-- 创建一个散列分区的表tp1，包含10个分区
CREATE TABLE tp1(c1 INT, c2 INT, c3 INT) PARTITION BY HASH(c1) PARTITIONS 10;

-- 利用USE_DISTRIBUTED_DML Hint更新tp1表，将c2列的值设置为4，条件是c1列的值小于4
-- 此更新操作将分布式执行
EXPLAIN BASIC UPDATE /*+ USE_DISTRIBUTED_DML */ tp1 SET c2 = 4 WHERE c1 < 4;
+--------------------------------------------------------------------------------------------------------------------------+
| Query Plan                                                                                                               |
+--------------------------------------------------------------------------------------------------------------------------+
| =========================================                                                                                |
| |ID|OPERATOR                   |NAME    |                                                                                |
| -----------------------------------------                                                                                |
| |0 |DISTRIBUTED UPDATE         |        |                                                                                |
| |1 |└─PX COORDINATOR           |        |                                                                                |
| |2 |  └─EXCHANGE OUT DISTR     |:EX10000|                                                                                |
| |3 |    └─PX PARTITION ITERATOR|        |                                                                                |
| |4 |      └─TABLE FULL SCAN    |TP1     |                                                                                |
| =========================================                                                                                |
| Outputs & filters:                                                                                                       |
| -------------------------------------                                                                                    |
|   0 - output(nil), filter(nil)                                                                                           |
|       table_columns([{TP1: ({TP1: (TP1.__pk_increment, TP1.C1, TP1.C2, TP1.C3)})}]),                                     |
|       update([TP1.C2=column_conv(NUMBER,PS:(-1,0),NULL,cast(4, NUMBER(-1, -85)))])                                       |
|   1 - output([TP1.__pk_increment], [TP1.C1], [TP1.C2], [TP1.C3]), filter(nil), rowset=16                                 |
|   2 - output([TP1.__pk_increment], [TP1.C1], [TP1.C2], [TP1.C3]), filter(nil), rowset=16                                 |
|       dop=1                                                                                                              |
|   3 - output([TP1.__pk_increment], [TP1.C1], [TP1.C2], [TP1.C3]), filter(nil), rowset=16                                 |
|       force partition granule                                                                                            |
|   4 - output([TP1.__pk_increment], [TP1.C1], [TP1.C2], [TP1.C3]), filter([TP1.C1 < cast(4, NUMBER(-1, -85))]), rowset=16 |
|       access([TP1.__pk_increment], [TP1.C1], [TP1.C2], [TP1.C3]), partitions(p[0-9])                                     |
|       is_index_back=false, is_global_index=false, filter_before_indexback[false],                                        |
|       range_key([TP1.__pk_increment]), range(MIN ; MAX)always true                                                       |
+--------------------------------------------------------------------------------------------------------------------------+
23 rows in set
```

## `NO_USE_DISTRIBUTED_DML` Hint

`NO_USE_DISTRIBUTED_DML` Hint 禁止 DML 操作采用分布式执行方式。它的反向操作是 `USE_DISTRIBUTED_DML` Hint。

### 语法

```sql
/*+ NO_USE_DISTRIBUTED_DML [ ( [ @ qb_name ] ) ] */
```

### 示例

```sql
-- 创建一个散列分区的表tp1，包含10个分区
CREATE TABLE tp1(c1 INT, c2 INT, c3 INT) PARTITION BY HASH(c1) PARTITIONS 10;

-- 使用NO_USE_DISTRIBUTED_DML Hint限制更新操作在单一节点上局部执行，而非分布式
-- 此更新操作将非分布式执行
EXPLAIN BASIC UPDATE /*+ NO_USE_DISTRIBUTED_DML */ tp1 SET c2 = 4 WHERE c1 < 4;
+--------------------------------------------------------------------------------------------------------------------------+
| Query Plan                                                                                                               |
+--------------------------------------------------------------------------------------------------------------------------+
| =======================================                                                                                  |
| |ID|OPERATOR                 |NAME    |                                                                                  |
| ---------------------------------------                                                                                  |
| |0 |PX COORDINATOR           |        |                                                                                  |
| |1 |└─EXCHANGE OUT DISTR     |:EX10000|                                                                                  |
| |2 |  └─PX PARTITION ITERATOR|        |                                                                                  |
| |3 |    └─UPDATE             |        |                                                                                  |
| |4 |      └─TABLE FULL SCAN  |TP1     |                                                                                  |
| =======================================                                                                                  |
| Outputs & filters:                                                                                                       |
| -------------------------------------                                                                                    |
|   0 - output(nil), filter(nil), rowset=16                                                                                |
|   1 - output(nil), filter(nil), rowset=16                                                                                |
|       dop=1                                                                                                              |
|   2 - output(nil), filter(nil), rowset=16                                                                                |
|       partition wise, force partition granule                                                                            |
|   3 - output(nil), filter(nil)                                                                                           |
|       table_columns([{TP1: ({TP1: (TP1.__pk_increment, TP1.C1, TP1.C2, TP1.C3)})}]),                                     |
|       update([TP1.C2=column_conv(NUMBER,PS:(-1,0),NULL,cast(4, NUMBER(-1, -85)))])                                       |
|   4 - output([TP1.__pk_increment], [TP1.C1], [TP1.C2], [TP1.C3]), filter([TP1.C1 < cast(4, NUMBER(-1, -85))]), rowset=16 |
|       access([TP1.__pk_increment], [TP1.C1], [TP1.C2], [TP1.C3]), partitions(p[0-9])                                     |
|       is_index_back=false, is_global_index=false, filter_before_indexback[false],                                        |
|       range_key([TP1.__pk_increment]), range(MIN ; MAX)always true                                                       |
+--------------------------------------------------------------------------------------------------------------------------+
23 rows in set
```