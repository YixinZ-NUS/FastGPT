| Description   |                 |
|---------------|-----------------|
| keywords      |                 |
| dir-name      | Heuristics Transform Hints  |
| dir-name-en   |                 |
| tenant-type   | Oracle Mode     |
|machine-translation||

# Transform Hint 类型下的 Heuristics Transform Hints

在 SQL 查询中，与启发式（Heuristics）相关的 Hint，旨在快速找到可行的解决方案，尽管这不一定是最优的,特别是在复杂查询中，数据库优化器会尝试应用多种不同的规则和转换策略，以找到最有效的执行方案。

| Hint 类型                         | 描述                     |
|-----------------------------------|-------------------------|
| `AGGR_FIRST_UNNEST `         | 当查询包含聚合类子查询（如 AVG, SUM, MAX 等函数）时，`AGGR_FIRST_UNNEST` Hint 启用聚合类子查询的聚合优先子查询提升查询改写。它的反向操作是 `NO_AGGR_FIRST_UNNEST`。 |
| `NO_AGGR_FIRST_UNNEST`       | 禁止聚合类子查询的聚合优先子查询提升查询改写。它的反向操作是 `AGGR_FIRST_UNNEST`。|
| `COUNT_TO_EXISTS`            | 启用将 `COUNT` 子查询转化为 `EXISTS` 子查询进行查询改写。它的反向操作是 `NO_COUNT_TO_EXISTS`。|
| `NO_COUNT_TO_EXISTS`         | 禁用将 `COUNT` 子查询转化为 `EXISTS`子查询进行查询改写。它的反向操作是 `COUNT_TO_EXISTS`。    |
| `ELIMINATE_JOIN`             | 识别和移除查询执行计划中不必要的连接（join）操作。它的反向操作是 `NO_ELIMINATE_JOIN`。|
| `NO_ELIMINATE_JOIN`          | 不消除查询执行计划中的连接（join）操作。它的反向操作是 `ELIMINATE_JOIN`。     |
| `FAST_MINMAX`                | 启用对查询进行 MIN 或 MAX 优化的查询改写。它的反向操作是 `NO_FAST_MINMAX`。 |
| `NO_FAST_MINMAX`             | 禁用对查询进行 MIN 或 MAX 优化的查询改写。它的反向操作是 `FAST_MINMAX`。    |
| `INLINE`                     | 指示优化器展开公用表表达式（CTE），将其查询内容直接嵌入到主体查询中。它的反向操作是 `MATERIALIZE`。             |
| `MATERIALIZE`                | 控制 CTE 的抽取或不进行 CTE 的展开。它的反向操作是 `INLINE`。              |
| `JOIN_FIRST_UNNEST`          | 在处理聚合函数的子查询时，会尝试优先使用连接（join）操作进行查询改写。它的反向操作是 `NO_JOIN_FIRST_UNNEST`。 |
| `NO_JOIN_FIRST_UNNEST`       | 禁止在聚合子查询中应用连接优先的改写策略。它的反向操作是 `JOIN_FIRST_UNNEST`。|
| `LEFT_TO_ANTI`               | 启用优化器尝试将外连接（OUTER JOIN）转化为反连接（ANTI JOIN）。它的反向操作是 `NO_LEFT_TO_ANTI`。|
| `NO_LEFT_TO_ANTI`            | 禁用优化器尝试将外连接（OUTER JOIN）转化为反连接（ANTI JOIN）。它的反向操作是 `LEFT_TO_ANTI`。   |
| `OUTER_TO_INNER`             | 启用优化器在可能的情况下将外连接（OUTER JOIN）改写为内连接（INNER JOIN）。它的反向操作是 `NO_OUTER_TO_INNER`。     |
| `NO_OUTER_TO_INNER`          | 禁用优化器将外连接（OUTER JOIN）改写为内连接（INNER JOIN）。它的反向操作是 `OUTER_TO_INNER`。     |
| `PRED_DEDUCE`                | 启用优化器利用已有的谓词产生新的谓词，通过推导和下推来优化查询的执行。这种改写通常针对嵌套查询或连接查询有效。它的反向操作是 `NO_PRED_DEDUCE`。                  |
| `NO_PRED_DEDUCE`             | 禁用提示优化器利用已有的谓词产生新的谓词。它的反向操作是 `PRED_DEDUCE`。         |
| `PROJECT_PRUNE`              | 提示优化器在内部查询块中剪除一些未使用的投影列。这在包含多表连接和多层次嵌套查询时特别有用。它的反向操作是 `NO_PROJECT_PRUNE`。    |
| `NO_PROJECT_PRUNE`           | 禁止优化器在内部查询块中剪除一些未使用的投影列。它的反向操作是 `PROJECT_PRUNE`。       |
| `PULLUP_EXPR`                | 启用表达式上拉改写。它的反向操作是 `NO_PULLUP_EXPR`。    |
| `NO_PULLUP_EXPR`             | 禁用表达式上拉改写。它的反向操作是 `PULLUP_EXPR`。       |
| `PUSH_LIMIT`                 | 启用 limit 下压改写。它的反向操作是 `NO_PUSH_LIMIT`。   |
| `NO_PUSH_LIMIT`              | 禁用 limit 下压改写。它的反向操作是 `PUSH_LIMIT`。 |
| `REPLACE_CONST`              | 启用常量传播改写。它的反向操作是 `NO_REPLACE_CONST`。  |
| `NO_REPLACE_CONST`           | 禁用常量传播改写。它的反向操作是 `REPLACE_CONST`。 |
| `SIMPLIFY_DISTINCT`          | 启用一系列 Distinct 相关查询改写。它的反向操作是 `NO_SIMPLIFY_DISTINCT`。  |
| `NO_SIMPLIFY_DISTINCT`       | 禁止一系列 Distinct 相关查询改写。它的反向操作是 `SIMPLIFY_DISTINCT`。  |
| `SIMPLIFY_EXPR`              | 启用表达式转化相关查询改写。它的反向操作是 `NO_SIMPLIFY_EXPR。  |
| `NO_SIMPLIFY_EXPR`           | 禁止表达式转化相关查询改写。它的反向操作是 `SIMPLIFY_EXPR`。  |
| `SIMPLIFY_GROUP_BY`          | 启用 Group By 相关查询改写。它的反向操作是 `NO_SIMPLIFY_GROUP_BY`。  |
| `NO_SIMPLIFY_GROUP_BY`       | 禁止 Group By 相关查询改写。它的反向操作是 `SIMPLIFY_GROUP_BY`。  |
| `SIMPLIFY_LIMIT`             | 启用 Limit 相关查询改写。它的反向操作是 `NO_SIMPLIFY_LIMIT`。  |
| `NO_SIMPLIFY_LIMIT`          | 禁止 Limit 相关查询改写。它的反向操作是 `SIMPLIFY_LIMIT`。|
| `SIMPLIFY_ORDER_BY`          | 启用 Order By 相关查询改写。它的反向操作是 `NO_SIMPLIFY_ORDER_BY`。  |
| `NO_SIMPLIFY_ORDER_BY`       | 禁止 Order By 相关查询改写。它的反向操作是 `SIMPLIFY_ORDER_BY`。  |
| `SIMPLIFY_SET`               | 启用集合查询相关查询改写。它的反向操作是 `NO_SIMPLIFY_SET`。 |
| `NO_SIMPLIFY_SET`            | 禁止集合查询相关查询改写。它的反向操作是 `SIMPLIFY_SET`。      |
| `SIMPLIFY_SUBQUERY`          | 启用子查询相关查询改写。它的反向操作是 `NO_SIMPLIFY_SUBQUERY`。  |
| `NO_SIMPLIFY_SUBQUERY`       | 禁止子查询相关查询改写。它的反向操作是 `SIMPLIFY_SUBQUERY`。  |
| `SIMPLIFY_WINFUNC`           | 启用窗口函数相关查询改写。它的反向操作是 `NO_SIMPLIFY_WINFUNC`。   |
| `NO_SIMPLIFY_WINFUNC`        | 禁止窗口函数相关查询改写。它的反向操作是 `SIMPLIFY_WINFUNC`。   |
| `UNNEST`                     | 启用子查询提升改写。它的反向操作是 `NO_UNNEST`。                  |
| `NO_UNNEST`                  | 禁用子查询提升改写。它的反向操作是 `UNNEST`。    |

## `AGGR_FIRST_UNNEST` Hint

`AGGR_FIRST_UNNEST` Hint 使优化器在处理聚合函数的子查询时优先考虑独立的聚合计算，而不是合并到主查询中。它的反向操作是 `NO_AGGR_FIRST_UNNEST` Hint。

需要注意的是，不推荐直接使用 `AGGR_FIRST_UNNEST`/`NO_AGGR_FIRST_UNNEST` Hint，因为它们直接影响子查询提升的改写行为。通常情况下，如果需要对子查询的提升行为进行更基本的控制，更建议使用 `UNNEST` 或 `NO_UNNEST` Hint。

### 语法

```sql
/*+ AGGR_FIRST_UNNEST [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定到遵循 Hint 的特定查询块。

### 示例

下方的查询示例中，使用 `AGGR_FIRST_UNNEST` 启用聚合类子查询的聚合，优先子查询提升查询改写。

```sql
-- Hint 推动优化器在解析查询时优先对子查询中的 AVG 聚合函数进行提升处理。
SELECT * FROM t1
WHERE t1.c1 > (SELECT /*+ AGGR_FIRST_UNNEST */ AVG(d1)
               FROM t2
               WHERE t1.c2 = t2.d2);
```

## `NO_AGGR_FIRST_UNNEST` Hint

`NO_AGGR_FIRST_UNNEST` Hint 禁止优化器在处理聚合函数的子查询时优先考虑独立的聚合计算。它的反向操作是 `AGGR_FIRST_UNNEST` Hint。

需要注意的是，不推荐直接使用 `AGGR_FIRST_UNNEST`/`NO_AGGR_FIRST_UNNEST` Hint，因为它们直接影响子查询提升的改写行为。通常情况下，如果需要对子查询的提升行为进行更基本的控制，更建议使用 `UNNEST` 或 `NO_UNNEST` Hint。

### 语法

```sql
/*+ NO_AGGR_FIRST_UNNEST [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定到遵循 Hint 的特定查询块。

### 示例

下方的查询示例中，使用 `NO_AGGR_FIRST_UNNEST` Hint, 该查询将保持原有的聚合子查询形式，不会进行聚合优先的查询改写。

```sql
SELECT * FROM t1
WHERE t1.c1 > (SELECT /*+ NO_AGGR_FIRST_UNNEST */ AVG(d1)
               FROM t2
               WHERE t1.c2 = t2.d2);
```

## `COUNT_TO_EXISTS` Hint

`COUNT_TO_EXISTS` Hint 启用将 `COUNT` 子查询转化为 `EXISTS` 子查询的查询改写。它的反向操作是 `NO_COUNT_TO_EXISTS` Hint 。

### 语法

```sql
/*+ COUNT_TO_EXISTS [ ( [ @ qb_name ] [ qb_name_list ] ) ] */
```

#### 参数解释

- `qb_name_list` 可以指定对特定的 Query Block 子查询进行改写，当参数缺省时，Hint 指定对所有子查询尝试进行改写。

### 示例

下方的查询示例中，使用 `COUNT_TO_EXISTS` Hint 启用对 `COUNT` 子查询进行查询改写。

```sql
-- `COUNT_TO_EXISTS` Hint 将引导优化器转化内嵌 `COUNT` 子查询为更高效的 `EXISTS` 形式。
SELECT /*+ COUNT_TO_EXISTS */ * FROM t1
WHERE (SELECT COUNT(*) FROM t2 WHERE t2.c1 = t1.c2) > 0;
```

## `NO_COUNT_TO_EXISTS` Hint

`COUNT_TO_EXISTS` Hint 禁用将 `COUNT` 子查询转化为 `EXISTS`子查询的查询改写。它的反向操作是 `COUNT_TO_EXISTS` Hint 。

### 语法

```sql
/*+ NO_COUNT_TO_EXISTS [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定查询块以应用该 Hint。
- `qb_name_list`： 可以指定禁用特定的 Query Block 子查询进行改写，当参数缺省时，Hint 指定对所有子查询尝试禁用改写。

### 示例

下方的查询示例中，使用 `NO_COUNT_TO_EXISTS` Hint 禁止对 `COUNT` 子查询进行查询改写。

```sql
-- 使用 `NO_COUNT_TO_EXISTS` Hint 保持使用 COUNT 子查询原样，不做转化。
SELECT /*+ NO_COUNT_TO_EXISTS */ * FROM t1
WHERE (SELECT COUNT(*) FROM t2 WHERE t2.c1 = t1.c2) > 0;
```

## `ELIMINATE_JOIN` Hint

`ELIMINATE_JOIN` Hint 控制连接消除的查询改写。它的反向操作是 `NO_ELIMINATE_JOIN` Hint。

### 语法

```sql
/*+ ELIMINATE_JOIN [ ( [ @ qb_name ] [ table_list ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定查询块以应用该 Hint。
- `table_list`：可选，可以指定对特定连接表进行连接消除，当参数缺省时，Hint 指定对所有连接表尝试进行连接消除。

### 示例

下方的查询示例中，分别使用 `ELIMINATE_JOIN` Hint 启用进行连接消除的查询改写。

```sql
--  使用 `ELIMINATE_JOIN` Hint 查找并消除 t1 自连接
CREATE TABLE t1(c1 INT PRIMARY KEY, c2 INT, c3 INT);
SELECT /*+ ELIMINATE_JOIN */ *
FROM t1 a, t1 b
WHERE a.c1 = b.c1;
```

## `NO_ELIMINATE_JOIN` Hint

`NO_ELIMINATE_JOIN` Hint 禁用连接消除的查询改写，保留所有指定的连接。它的反向操作是 `ELIMINATE_JOIN` Hint。

### 语法

```sql
/*+ NO_ELIMINATE_JOIN [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定查询块以应用该 Hint。
- `table_list`：可选，可以指定对特定连接表禁用连接消除，当参数缺省时，Hint 指定对所有连接表尝试禁用连接消除。

### 示例

下方的查询示例中，使用 `NO_ELIMINATE_JOIN` 禁止进行连接消除的查询改写。

```sql
-- 使用 `NO_ELIMINATE_JOIN` Hint 确保连接操作被保留
SELECT /*+ NO_ELIMINATE_JOIN */ *
FROM t1 a, t1 b
WHERE a.c1 = b.c1;
```

## `FAST_MINMAX` Hint

`FAST_MINMAX` Hint 启用 `MIN`/`MAX` 聚合函数的查询进行查询改写。它提示数据库查询优化器重写查询，以便更快地获取最小值和最大值。它的反向操作是 `NO_FAST_MINMAX` Hint。

### 语法

```sql
/*+ FAST_MINMAX [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定查询块以应用该 Hint。

### 示例

下方的查询示例中，使用 `FAST_MINMAX` 启用对查询进行`MIN`/`MAX`优化的查询改写。

```sql
CREATE TABLE t1(c1 int primary key, c2 int, c3 int);
-- 使用 `FAST_MINMAX` Hint 以最快的方法来执行 MAX(c1) 的计算。
SELECT /*+ FAST_MINMAX */ MAX(c1) FROM t1;
```

## `NO_FAST_MINMAX` Hint

`NO_FAST_MINMAX` Hint 禁用 `MIN`/`MAX` 聚合函数的查询进行查询改写。它的反向操作是 `FAST_MINMAX` Hint。

### 语法

```sql
/*+ NO_FAST_MINMAX [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定查询块以应用该 Hint。

### 示例

下方的查询示例中，使用 `NO_FAST_MINMAX` 禁止对查询进行 `MIN`/`MAX` 优化的查询改写。

```sql
CREATE TABLE t1(c1 int primary key, c2 int, c3 int);
-- 使用 `FAST_MINMAX` Hint 禁止优化器采加速 MAX(c1) 运算的。
SELECT /*+ NO_FAST_MINMAX */ MAX(c1) FROM t1;
```

## `INLINE` Hint

`INLINE` Hint 用于指定公用表表达式（CTE）的展开，将 CTE 直接集成到主查询中。它的反向操作是 `MATERIALIZE` Hint。

### 语法

```sql
/*+ INLINE [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定查询块以应用该 Hint。

### 示例

对以下查询，使用 INLINE Hint 指定对 `with cte`定义的 CTE 进行展开。

```sql
-- 使用 `INLINE` Hint 在主查询中直接使用 with cte 中定义的子查询内容
WITH cte AS (
  SELECT /*+INLINE*/ t1.*
  FROM t1
  JOIN t2 ON t1.c1 = t2.c1
)
SELECT * FROM cte A, cte B;
```

## `MATERIALIZE` Hint

`MATERIALIZE` Hint 控制 CTE 的抽取或不进行 CTE 展开。它的反向操作是 `INLINE` Hint。

### 语法

```sql
/*+ MATERIALIZE [ ( [ @ qb_name ] [ qb_name_list ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定查询块以应用该 Hint。
- `qb_name_list`：可选，禁用对特定的 Query Block 进行 CTE 的抽取，当参数缺省时，不进行 CTE 的抽取。仅推荐在 `with cte`定义的 CTE 内部使用 `MATERIALIZE` Hint。

### 示例

对以下查询，使用 `MATERIALIZE` Hint 指定禁止对 `with cte` 定义的 CTE 进行展开或主动对查询中的 Query Block 抽取 CTE。

```sql
-- 示例1: 物化单个 CTE
WITH cte AS (
  SELECT /*+MATERIALIZE*/ * FROM t1
)
SELECT * FROM cte;

-- 示例2: 物化多个 Query Blocks
SELECT /*+MATERIALIZE(("SEL$2", "SEL$3"))*/ v1.*
FROM   (SELECT t1.* FROM t1 JOIN t2 ON t1.c1 = t2.c1) v1,
       (SELECT t1.* FROM t1 JOIN t2 ON t1.c1 = t2.c1) v2,
       (SELECT t1.* FROM t1 JOIN t2 ON t1.c1 = t2.c1) v3,
       (SELECT t1.* FROM t1 JOIN t2 ON t1.c1 = t2.c1) v4;
```

## `JOIN_FIRST_UNNEST` Hint

`JOIN_FIRST_UNNEST` Hint 启用聚合类子查询提升相关的查询改写，即首先考虑使用连接操作来优化含有聚合函数的子查询。它的反向操作是 `NO_JOIN_FIRST_UNNEST` Hint。

需要注意的是，不推荐直接使用 `JOIN_FIRST_UNNEST`/`NO_JOIN_FIRST_UNNEST` Hint，干预子查询提升改写推荐使用使用 `UNNEST`/`NO_UNNEST` Hint。

### 语法

```sql
/*+ JOIN_FIRST_UNNEST [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定查询块以应用该 Hint。

### 示例

下方的查询示例中，使用 `JOIN_FIRST_UNNEST`  Hint 启用聚合类子查询的连接，优先子查询提升查询改写。

```sql
-- 使用 `JOIN_FIRST_UNNEST` Hint 处理包含聚合函数（如 AVG）的子查询时，优先考虑执行计划的连接操作（join）
SELECT * FROM t1
WHERE t1.c1 > (
  SELECT /*+ JOIN_FIRST_UNNEST */ AVG(d1)
  FROM t2
  WHERE t1.c2 = t2.d2
);
```

## `NO_JOIN_FIRST_UNNEST` Hint

`NO_JOIN_FIRST_UNNEST` Hint 用于禁止聚合类子查询的连接优先子查询提升查询改写，使用 `NO_JOIN_FIRST_UNNEST` Hint，查询优化器将不会考虑连接优先的策略。它的反向操作是 `JOIN_FIRST_UNNEST` Hint。

需要注意的是，不推荐直接使用 `JOIN_FIRST_UNNEST`/`NO_JOIN_FIRST_UNNEST` Hint，干预子查询提升改写推荐使用使用 `UNNEST`/`NO_UNNEST` Hint。

### 语法

```sql
/*+ NO_JOIN_FIRST_UNNEST [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定查询块以应用该 Hint。

### 示例

下方的查询示例中，使用 `NO_JOIN_FIRST_UNNEST` 禁止聚合类子查询的连接优先子查询提升查询改写。

```sql
-- 使用 `NO_JOIN_FIRST_UNNEST` Hint 不会考虑将子查询与外部查询进行连接操作
SELECT * FROM t1
WHERE t1.c1 > (
  SELECT /*+ NO_JOIN_FIRST_UNNEST */ AVG(d1)
  FROM t2
  WHERE t1.c2 = t2.d2
);
```

## `LEFT_TO_ANTI` Hint

`LEFT_TO_ANTI` Hint 启用 `OUTER JOIN` 转化为 `ANTI JOIN` 的查询改写。它的反向操作是 `NO_LEFT_TO_ANTI` Hint。

### 语法

```sql
/*+ LEFT_TO_ANTI [ ( [ @ qb_name ] [ table_list ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定查询块以应用该 Hint。
- `table_list`：可选，可以指定对特定 `LEFT JOIN` 的右表进行查询改写，当参数缺省时，Hint 指定对所有 `OUTER JOIN` 尝试进行改写。

### 示例

下方的查询示例中，使用 `LEFT_TO_ANTI` 启用 `OUTER JOIN` 转化为 `ANTI JOIN` 的查询改写。

```sql
CREATE TABLE t1(c1 int primary key, c2 int, c3 int);
CREATE TABLE t2(c1 int primary key, c2 int, c3 int);

SELECT /*+ LEFT_TO_ANTI(t2) */ * FROM t1 LEFT JOIN t2 ON t1.c2 = t2.c2 WHERE t2.c1 IS NULL;
```

## `NO_LEFT_TO_ANTI` Hint

`NO_LEFT_TO_ANTI` Hint 禁用 `OUTER JOIN` 转化为 `ANTI JOIN` 的查询改写。它的反向操作是 `LEFT_TO_ANTI` Hint。

### 语法

```sql
/*+ NO_LEFT_TO_ANTI [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定查询块以应用该 Hint。

### 示例

下方的查询示例中，使用 `NO_LEFT_TO_ANTI` 禁止 `OUTER JOIN` 转化为 `ANTI JOIN` 的查询改写。

```sql
CREATE TABLE t1(c1 int primary key, c2 int, c3 int);
CREATE TABLE t2(c1 int primary key, c2 int, c3 int);

SELECT /*+ NO_LEFT_TO_ANTI */ * FROM t1
LEFT JOIN t2 ON t1.c2 = t2.c2
WHERE t2.c1 IS NULL;
```

## `OUTER_TO_INNER` Hint

`OUTER_TO_INNER` Hint 控制外连接转内连接的查询改写，即将 `LEFT OUTER JOIN` 或 `RIGHT OUTER JOIN` 转换为更效率的 `INNER JOIN`。它的反向操作是 `NO_OUTER_TO_INNER` Hint。

### 语法

```sql
/*+ OUTER_TO_INNER [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定查询块以应用该 Hint。

### 示例

下方的查询示例中，使用 `OUTER_TO_INNER` 启用外连接转内连接查询改写。

```sql
-- 过滤条件 b.c1 > 0，其作用仅适用于 b 表，它隐含地剔除了外连接中右表的空值（null）可能性，从而使得这个外连接操作可被视为一个内连接
SELECT /*+ OUTER_TO_INNER */ *
FROM t1 a
LEFT JOIN t1 b ON a.c2 = b.c2
WHERE b.c1 > 0;
```

## `NO_OUTER_TO_INNER` Hint

`NO_OUTER_TO_INNER` Hint 禁用外连接转内连接的查询改写，查询优化器不会把外连接转换为内连接。它的反向操作是 `OUTER_TO_INNER` Hint。

### 语法

```sql
/*+ NO_OUTER_TO_INNER [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定查询块以应用该 Hint。

### 示例

下方的查询示例中，使用 `NO_OUTER_TO_INNER` 禁止外连接转内连接查询改写。

```sql
-- `WHERE` 子句的条件可能隐含了一个内连接，`NO_OUTER_TO_INNER` Hint 保证外连接的逻辑得以保持
SELECT /*+ NO_OUTER_TO_INNER */ *
FROM t1 a
LEFT JOIN t1 b ON a.c2 = b.c2
WHERE b.c1 > 0;
```

## `PRED_DEDUCE` Hint

`PRED_DEDUCE` Hint 控制谓词推导查询改写，利用已有谓词推导出新谓词、对谓词进行下压等操作。这种改写通常针对嵌套查询或连接查询有效。它的反向操作是 `NO_PRED_DEDUCE` Hint。

### 语法

```sql
/*+ PRED_DEDUCE [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定查询块以应用该 Hint。

### 示例

下方的查询示例中，使用 `PRED_DEDUCE` 启用外层 Query Block 参与谓词推导查询改写。

```sql
-- 启用谓词推导来改写外层查询
select /*+pred_deduce*/ c1
from (
  -- 禁用子查询合并，保证 no_merge hint 的使用有效
  select /*+no_merge*/ t1.* from t1
)
where c1 = 3;
```

## `NO_PRED_DEDUCE` Hint

`NO_PRED_DEDUCE` Hint 禁用提示优化器利用已有的谓词产生新的谓词。它的反向操作是 `PRED_DEDUCE` Hint。

### 语法

```sql
/*+ NO_PRED_DEDUCE [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定查询块以应用该 Hint。

### 示例

下方的查询示例中，使用 `NO_PRED_DEDUCE` 禁止外层 Query Block 参与谓词推导查询改写。

```sql
-- 禁用谓词推导来改写外层查询
select /*+no_pred_deduce*/ c1
from (
  -- 禁用子查询合并，保证 no_merge hint 的使用有效
  select /*+no_merge*/ t1.* from t1
)
where c1 = 3;
```

## `PROJECT_PRUNE` Hint

`PROJECT_PRUNE` Hint 优化了查询执行过程，能够有效地减少查询处理的数据量，尤其是在数据集大、查询较为复杂时。通过裁剪不需要的列来减少查询块（Query Block）的输出。这种查询改写技术，即 Project Pruning，有助于提高查询效率，尤其是在处理内部查询块时。它的反向操作是 `NO_PROJECT_PRUNE` Hint。

### 语法

```sql
/*+ PROJECT_PRUNE [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定哪个特定的查询块应该应用 `PROJECT_PRUNE` Hint，为查询优化提供更细粒度的控制。

### 示例

下方的查询示例中，使用 `PROJECT_PRUNE` 调用了 Project Pruning 改写机制。这使得除了 C1 列之外，内联视图中的所有输出列都会被优化器裁剪掉。

```sql
select c1 from (select /*+no_merge project_prune*/ t1.* from t1);
```

## `NO_PROJECT_PRUNE` Hint

`NO_PROJECT_PRUNE` Hint 禁用了 Project Pruning 的查询改写操作。Project Pruning 在查询优化过程中自动裁剪了未被使用的输出列。当出于特定的性能或功能要求需要保留这些列时，使用 `NO_PROJECT_PRUNE Hint` 就显得尤为重要。它的反向操作是 `PROJECT_PRUNE` Hint。

### 语法

```sql
/*+ NO_PROJECT_PRUNE [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指明哪个查询块应该避免应用 Project Pruning。当多个查询块存在时，这提供了更精确的控制。

### 示例

下方的查询示例中，使用 `NO_PROJECT_PRUNE` 禁止 Project Pruning 改写操作。查询的这个设定确保了即使不需要 `c1` 以外的所有输出列，这些列也仍会留在内联视图的结果中。

```sql
select c1 from (select /*+no_merge no_project_prune*/ t1.* from t1);
```

## `PULLUP_EXPR` Hint

`PULLUP_EXPR` Hint 启用允许优化器提升（上拉）子查询表达式到父查询层级。它的反向操作是 `NO_PULLUP_EXPR` Hint。

### 语法

```sql
/*+ PULLUP_EXPR [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定查询块以应用该 Hint。

### 示例

下方的查询示例中，使用 `PULLUP_EXPR` 启用表达式上拉改写。表达式上拉查询改写触发后，内联视图中 `SELECT` 中子查询被上拉到外层。

```sql
-- 假设 t1 是现有的表结构
CREATE TABLE t1(c1 INT PRIMARY KEY, c2 INT, c3 INT);

-- 执行带有 PULLUP_EXPR hint 的查询
SELECT *
FROM (SELECT /*+no_merge pullup_expr*/ t1.*,
             (SELECT c2 FROM t1 WHERE c1 = 1)
      FROM t1)
WHERE c1 > 1000;
```

## `NO_PULLUP_EXPR` Hint

`NO_PULLUP_EXPR` Hint 禁用查询优化器执行表达式上拉优化。它的反向操作是 `PULLUP_EXPR` Hint。

### 语法

```sql
/*+ NO_PULLUP_EXPR [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定查询块以应用该 Hint。

### 示例

下方的查询示例中，使用 `NO_PULLUP_EXPR` 禁止表达式上拉改写。表达式上拉查询改写触发后，内联视图中 select 中子查询被阻止上拉到外层。

```sql
-- 假设 t1 是现有的表结构
CREATE TABLE t1(c1 INT PRIMARY KEY, c2 INT, c3 INT);

-- 执行带有 NO_PULLUP_EXPR hint 的查询
SELECT *
FROM (SELECT /*+no_merge no_pullup_expr*/ t1.*,
             (SELECT c2 FROM t1 WHERE c1 = 1)
      FROM t1)
WHERE c1 > 1000;
```

## `PUSH_LIMIT` Hint

`PUSH_LIMIT` Hint 用于在处理分页数据时，它允许优化器将 LIMIT 子句（限制返回的行数）推下（下压）到连接查询的内部，如外连接或笛卡尔积，可以显著提高分页查询的效率。它的反向操作是 `NO_PUSH_LIMIT` Hint。

### 语法

```sql
/*+ PUSH_LIMIT [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定查询块以应用该 Hint。

### 示例

下方的查询示例中，分别使用 `PUSH_LIMIT` 启用 Limit 下压连接改写。

```sql
-- t1 假设是已存在的表结构
CREATE TABLE t1(c1 int primary key, c2 int, c3 int);

-- 使用 PUSH_LIMIT hint 的查询示例
SELECT /*+push_limit*/ *
FROM t1 a LEFT JOIN t1 b on a.c2 = b.c2
fetch next 10 rows only;
```

## `NO_PUSH_LIMIT` Hint

`NO_PUSH_LIMIT` Hint 阻止优化器改变原始查询结构，特别是在不希望 LIMIT 下压到连接查询内部时。它的反向操作是 `PUSH_LIMIT` Hint。

### 语法

```sql
/*+ NO_PUSH_LIMIT [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定查询块以应用该 Hint。

### 示例

下方的查询示例中，使用 `NO_PUSH_LIMIT` 禁止 Limit 下压连接改写。

```sql
-- t1 假设是已存在的表结构
CREATE TABLE t1(c1 int primary key, c2 int, c3 int);

-- 使用 NO_PUSH_LIMIT hint 的查询示例
SELECT /*+no_push_limit*/ *
FROM t1 a LEFT JOIN t1 b ON a.c2 = b.c2
FETCH NEXT 10 ROWS ONLY;
```

## `REPLACE_CONST` Hint

`REPLACE_CONST` Hint 启用优化器进行常量传播查询改写，即将查询中的等值条件用常量替换以降低复杂性并提升查询效率。它的反向操作是 `NO_REPLACE_CONST` Hint。

### 语法

```sql
/*+ REPLACE_CONST [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定查询块以应用该 Hint。

### 示例

下方的查询示例中，使用 `REPLACE_CONST` 启用常量传播查询改写。

```sql
-- 假定 t1 为现存表格
CREATE TABLE t1(c1 INT PRIMARY KEY, c2 INT, c3 INT);

-- 通过 REPLACE_CONST hint 的查询，传播简化 WHERE 子句
SELECT /*+replace_const*/ c2
FROM t1
WHERE c1 = c2 AND c2 = 4;
```

## `NO_REPLACE_CONST` Hint

`NO_REPLACE_CONST` Hint 禁止常量传播查询改写，以避免某些场景下可能导致的不必要改写。。它的反向操作是 `REPLACE_CONST` Hint。

### 语法

```sql
/*+ NO_REPLACE_CONST [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定查询块以应用该 Hint。

### 示例

下方的查询示例中，使用 `NO_REPLACE_CONST` 禁止常量传播查询改写。

```sql
-- 假定 t1 为现存表格
CREATE TABLE t1(c1 INT PRIMARY KEY, c2 INT, c3 INT);

-- 采用 NO_REPLACE_CONST hint 的查询示例，来维持原始查询条件不变
SELECT /*+no_replace_const*/ c2
FROM t1
WHERE c1 = c2 AND c2 = 4;
```

## `SIMPLIFY_DISTINCT` Hint

`SIMPLIFY_DISTINCT` Hint 启用优化器执行 Distinct 查询改写，简化和优化处理 Distinct 操作的查询。它的反向操作是 `NO_SIMPLIFY_DISTINCT` Hint。

### 语法

```sql
/*+ SIMPLIFY_DISTINCT [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定查询块以应用该 Hint。

### 示例

下方的查询示例中，使用 `SIMPLIFY_DISTINCT` 启用一系列 Distinct 相关查询改写。

```sql
CREATE TABLE t1(c1 INT PRIMARY KEY, c2 INT, c3 INT);

SELECT DISTINCT c1, c2
FROM (SELECT /*+simplify_distinct*/ DISTINCT t1.* FROM t1);
```

## `NO_SIMPLIFY_DISTINCT` Hint

`NP_SIMPLIFY_DISTINCT` Hint 显式禁止 Distinct 查询的简化处理。这可以在特定场景下保持查询原貌，防止优化器自动进行可能不希望的改写。它的反向操作是 `SIMPLIFY_DISTINCT` Hint。

### 语法

```sql
/*+ NO_SIMPLIFY_DISTINCT [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定查询块以应用该 Hint。

### 示例

下方的查询示例中，使用 `NO_SIMPLIFY_DISTINCT` 禁止一系列 Distinct 相关查询改写。

```sql
CREATE TABLE t1(c1 INT PRIMARY KEY, c2 INT, c3 INT);

SELECT DISTINCT c1, c2
FROM (SELECT /*+no_simplify_distinct*/ DISTINCT t1.* FROM t1);
```

## `SIMPLIFY_EXPR` Hint

`SIMPLIFY_EXPR` Hint 启用优化器对查询中的表达式进行转换和简化。它的反向操作是 `NO_SIMPLIFY_EXPR` Hint。

### 语法

```sql
/*+ SIMPLIFY_EXPR [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定查询块以应用该 Hint。

### 示例

下方的查询示例中，使用 `SIMPLIFY_EXPR` 启用优化器对查询中的表达式进行转换和简化。

```sql
-- 使用 `SIMPLIFY_EXPR` Hint ，在条件简化时通过移除冗余的逻辑来优化查询效率
SELECT /*+simplify_expr*/ 1 FROM t1 WHERE c1 = 1 OR 1 = 1;
```

## `NO_SIMPLIFY_EXPR` Hint

`NO_SIMPLIFY_EXPR` Hint 禁用优化器对查询中的表达式进行转换和简化。它的反向操作是 `SIMPLIFY_EXPR` Hint。

### 语法

```sql
/*+ NO_SIMPLIFY_EXPR [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定查询块以应用该 Hint。

### 示例

下方的查询示例中，使用  `NO_SIMPLIFY_EXPR` 禁止优化器对查询中的表达式进行转换和简化。

```sql
--使用 `NO_SIMPLIFY_EXPR` Hint，禁止表达式转化和简化操作
SELECT /*+no_simplify_expr*/ 1 FROM t1 WHERE c1 = 1 OR 1 = 1;
```

## `SIMPLIFY_GROUP_BY` Hint

`SIMPLIFY_GROUP_BY` Hint 用于优化含 `GROUP BY` 子句的查询。此 Hint 启用查询优化器对 `GROUP BY` 操作进行精简和改写。它的反向操作是 `NO_SIMPLIFY_GROUP_BY` Hint。

### 语法

```sql
/*+ SIMPLIFY_GROUP_BY [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定查询块以应用该 Hint。

### 示例

下方的查询示例中，使用 `SIMPLIFY_GROUP_BY` 启用 Group By 相关查询改写。

```sql
CREATE TABLE t1(c1 INT PRIMARY KEY, c2 INT, c3 INT);
-- `SIMPLIFY_GROUP_BY` Hint 启用优化器通过改写来优化聚合操作的执行
SELECT /*+simplify_group_by*/ COUNT(DISTINCT c1) FROM t1 GROUP BY c2;
```

## `NO_SIMPLIFY_GROUP_BY` Hint

`NO_SIMPLIFY_GROUP_BY` Hint 禁止任何 `GROUP BY` 相关的查询改写，以保持查询的原始逻辑不变。它的反向操作是 `SIMPLIFY_GROUP_BY` Hint。

### 语法

```sql
/*+ NO_SIMPLIFY_GROUP_BY [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定查询块以应用该 Hint。

### 示例

下方的查询示例中，使用 `NO_SIMPLIFY_GROUP_BY` 保持原有 `GROUP BY` 逻辑，防止任何自动化的查询优化。

```sql
CREATE TABLE t1(c1 INT PRIMARY KEY, c2 INT, c3 INT);

SELECT /*+no_simplify_group_by*/ COUNT(DISTINCT c1) FROM t1 GROUP BY c2;
```

## `SIMPLIFY_LIMIT` Hint

`SIMPLIFY_LIMIT` Hint 启用优化器针对 `LIMIT` 子句进行简化查询输出，提升分页查询的性能。它的反向操作是 `NO_SIMPLIFY_LIMIT` Hint。

### 语法

```sql
/*+ SIMPLIFY_LIMIT [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定查询块以应用该 Hint。

### 示例

下方的查询示例中，使用 `SIMPLIFY_LIMIT` 启用 Limit 相关查询改写。

```sql
CREATE TABLE t1(c1 INT PRIMARY KEY, c2 INT, c3 INT);

-- 应该使用 `SIMPLIFY_LIMIT` 而非 `NO_SIMPLIFY_LIMIT`，修正示例中的Hint使用
SELECT /*+simplify_limit*/ *
FROM (SELECT /*+no_rewrite*/ ROWNUM cnt,
             (SELECT c2 FROM t1 WHERE c1 = 1)
      FROM t1)
OFFSET 10 ROWS FETCH NEXT 10 ROWS ONLY;
```

## `NO_SIMPLIFY_LIMIT` Hint

`NO_SIMPLIFY_LIMIT` Hint 用于避免 `LIMIT` 子句的查询改写。它的反向操作是 `SIMPLIFY_LIMIT` Hint。

### 语法

```sql
/*+ NO_SIMPLIFY_LIMIT [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定查询块以应用该 Hint。

### 示例

下方的查询示例中，使用 `NO_SIMPLIFY_LIMIT` 禁止 `LIMIT` 相关查询改写。

```sql
CREATE TABLE t1(c1 INT PRIMARY KEY, c2 INT, c3 INT);

-- 使用 `NO_SIMPLIFY_LIMIT` 以确保原始分页逻辑保持不变
SELECT /*+no_simplify_limit*/ *
FROM (SELECT /*+no_rewrite*/ ROWNUM cnt,
             (SELECT c2 FROM t1 WHERE c1 = 1)
      FROM t1)
OFFSET 10 ROWS FETCH NEXT 10 ROWS ONLY;
```

## `SIMPLIFY_ORDER_BY` Hint

`SIMPLIFY_ORDER_BY` Hint 用于优化含 `ORDER BY` 子句的查询。此 Hint 启用查询优化器对 `ORDER BY` 操作进行精简和改写。它的反向操作是 `NO_SIMPLIFY_ORDER_BY` Hint。

### 语法

```sql
/*+ SIMPLIFY_ORDER_BY [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定查询块以应用该 Hint。

### 示例

下方的查询示例中，使用 `SIMPLIFY_GROUP_BY` 启用 Group By 相关查询改写。

```sql
CREATE TABLE t1(c1 INT PRIMARY KEY, c2 INT, c3 INT);
-- `SIMPLIFY_ORDER_BY` Hint 启用优化器通过改写来优化排序操作的执行
SELECT /*+simplify_order_by*/ c1 FROM
(SELECT /*+no_merge*/ * FROM t1 ORDER BY c2) ORDER BY c2 DESC;
```

## `NO_SIMPLIFY_ORDER_BY` Hint

`NO_SIMPLIFY_ORDER_BY` Hint 禁止任何 `ORDER BY` 相关的查询改写，以保持查询的原始逻辑不变。它的反向操作是 `SIMPLIFY_ORDER_BY` Hint。

### 语法

```sql
/*+ NO_SIMPLIFY_ORDER_BY [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定查询块以应用该 Hint。

### 示例

下方的查询示例中，使用 `NO_SIMPLIFY_ORDER_BY` 保持原有 `ORDER BY` 逻辑，防止任何自动化的查询优化。

```sql
CREATE TABLE t1(c1 INT PRIMARY KEY, c2 INT, c3 INT);

SELECT /*+no_simplify_order_by*/ c1 FROM
(SELECT /*+no_merge*/ * FROM t1 ORDER BY c2) ORDER BY c2 DESC;
```

## `SIMPLIFY_SUBQUERY` Hint

`SIMPLIFY_SUBQUERY` Hint 启用触发对嵌套子查询的改写，有助于转换或消除不必要的子查询结构，以简化查询逻辑。它的反向操作是 `NO_SIMPLIFY_SUBQUERY` Hint。

### 语法

```sql
/*+ SIMPLIFY_SUBQUERY [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定查询块以应用该 Hint。

### 示例

下方的查询示例中，使用 `SIMPLIFY_SUBQUERY` 启用子查询相关查询改写。

```sql
-- 假设 t1 为预先创建好的表
CREATE TABLE t1(c1 INT PRIMARY KEY, c2 INT, c3 INT);

-- 查询例子演示 `SIMPLIFY_SUBQUERY` Hint 的使用，启用优化器简化或消除不必要的子查询部分
SELECT /*+simplify_subquery*/ * FROM t1
WHERE EXISTS (SELECT * FROM t1);
```

## `NO_SIMPLIFY_SUBQUERY` Hint

`NO_SIMPLIFY_SUBQUERY` Hint 阻止自动改写子查询的方法，保持原始的查询结构和逻辑。它的反向操作是 `SIMPLIFY_SUBQUERY` Hint。

### 语法

```sql
/*+ NO_SIMPLIFY_SUBQUERY [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定查询块以应用该 Hint。

### 示例

下方的查询示例中，使用 `NO_SIMPLIFY_SUBQUERY` 禁止子查询相关查询改写。

```sql
-- 假设 t1 为预先创建好的表
CREATE TABLE t1(c1 INT PRIMARY KEY, c2 INT, c3 INT);

-- 查询例子演示 `NO_SIMPLIFY_SUBQUERY` Hint 的使用，确保子查询保持原样不被优化器改写。
SELECT /*+no_simplify_subquery*/ * FROM t1
WHERE EXISTS (SELECT * FROM t1);
```

## `SIMPLIFY_SET` Hint

`SIMPLIFY_SET` Hint 启用优化器对集合操作（如 `UNION`，`INTERSECT`，`EXCEPT`）进行改写。它的反向操作是 `NO_SIMPLIFY_SET` Hint。

### 语法

```sql
/*+ SIMPLIFY_SET [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定查询块以应用该 Hint。

<main id="notice" type='explain'>
<h4>说明</h4>
<p>集合查询的 Query Block 没有直接添加 Hint 的位置，因此必须通过 QB Name 的方法指定 Hint 作用的 Query Block。</p>
</main>

### 示例

下方的查询示例中，使用 `SIMPLIFY_SET` 启用集合查询相关查询改写。

```sql
-- 假设 t1 是预先存在的表
CREATE TABLE t1(c1 INT PRIMARY KEY, c2 INT, c3 INT);

-- 利用 SIMPLIFY_SET Hint 优化查询
SELECT /*+simplify_set(@set$1)*/ * FROM t1
UNION ALL
SELECT * FROM t1 WHERE 1 = 0;
```

上面的示例中包含了一个 Hint（`/*+simplify_set(@set$1)*/`），该 Hint 表示禁用数据库优化器对这个特定的集合操作（`UNION ALL`）查询的自动简化。`@set$1` 是一个 Query Block Name（QB Name），在这种情况下，它用来标识整个 `UNION ALL` 查询语句。

## `NO_SIMPLIFY_SET` Hint

`NO_SIMPLIFY_SET` Hint 禁用对集合查询相关的查询改写。它的反向操作是 `SIMPLIFY_SET` Hint。

### 语法

```sql
/*+ NO_SIMPLIFY_SET [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定查询块以应用该 Hint。

<main id="notice" type='explain'>
<h4>说明</h4>
<p>集合查询的 Query Block 没有直接添加 Hint 的位置，因此必须通过 QB Name 的方法指定 Hint 作用的 Query Block。</p>
</main>

### 示例

下方的查询示例中，使用 `NO_SIMPLIFY_SET` 禁止集合查询相关查询改写。

```sql
-- 针对预定义的表 t1
CREATE TABLE t1(c1 INT PRIMARY KEY, c2 INT, c3 INT);

-- 使用 NO_SIMPLIFY_SET Hint 以阻止集合查询改写
SELECT /*+no_simplify_set(@set$1)*/ * FROM t1
UNION ALL
SELECT * FROM t1 WHERE 1 = 0;
```

上面的示例中包含了一个 Hint（`/*+no_simplify_set(@set$1)*/`），该 Hint 表示禁用数据库优化器对这个特定的集合操作（`UNION ALL`）查询的自动简化。`@set$1` 是一个 Query Block Name（QB Name），在这种情况下，它用来标识整个 `UNION ALL` 查询语句。

## `SIMPLIFY_WINFUNC` Hint

`SIMPLIFY_WINFUNC` Hint 启用优化器对包含窗口函数（Window Functions）的查询进行有效的改写。它的反向操作是 `NO_SIMPLIFY_WINFUNC` Hint。

### 语法

```sql
/*+ SIMPLIFY_WINFUNC [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定查询块以应用该 Hint。

### 示例

下方的查询示例中，使用 `SIMPLIFY_WINFUNC` 启用窗口函数相关查询改写。

```sql
-- 前提是 t1 表已被创建
CREATE TABLE t1(c1 INT PRIMARY KEY, c2 INT, c3 INT);

-- 使用 SIMPLIFY_WINFUNC Hint 的查询示例，启用优化器识别并实施任何可能的改写来简化 MAX(c2) OVER (PARTITION BY c1) 的计算过程。
SELECT /*+simplify_winfunc*/ MAX(c2) OVER (PARTITION BY c1) FROM t1;
```

## `NO_SIMPLIFY_WINFUNC` Hint

`NO_SIMPLIFY_WINFUNC` Hint 禁止优化器对含有窗口函数的查询进行改写，确保特殊逻辑绝对保持原样时使用。它的反向操作是 `SIMPLIFY_WINFUNC` Hint。

### 语法

```sql
/*+ NO_SIMPLIFY_WINFUNC [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定查询块以应用该 Hint。

### 示例

下方的查询示例中，使用 `NO_SIMPLIFY_WINFUNC` 禁止窗口函数相关查询改写。

```sql
-- 假定 t1 表已存在
CREATE TABLE t1(c1 INT PRIMARY KEY, c2 INT, c3 INT);

-- 应用 NO_SIMPLIFY_WINFUNC Hint 的查询保持窗口函数原有行为
SELECT /*+no_simplify_winfunc*/ MAX(c2) OVER (PARTITION BY c1) FROM t1;
```

## `UNNEST` Hint

`UNNEST` Hint 启用优化器将子查询拆成连接 (joins) 来提升查询改写，将查询中出现的子查询转化为多种连接。它的反向操作是 `NO_UNNEST` Hint。

OceanBase 数据库支持进一步的子查询提升优化，比如 `AGGR_FIRST_UNNEST` Hint 和 `JOIN_FIRST_UNNEST` Hint，它们分别指导优化器在子查询提升时优先考虑聚合或连接操作。尽管如此，在大多数场景下，推荐直接使用 `UNNEST` Hint，因为它提供了一种通用的优化策略。

### 语法

```sql
/*+ UNNEST [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定查询块以应用该 Hint。

### 示例

下方的查询示例中，使用 `UNNEST`启用子查询提升相关查询改写。

```sql
-- 假设有表 t1 已创建
CREATE TABLE t1(c1 INT, c2 INT, c3 INT);

-- 使用 UNNEST Hint 的查询，触发子查询的提升
SELECT (SELECT /*+unnest*/ COUNT(*)
        FROM t1 b
        WHERE a.c2 = b.c2)
FROM t1 a;
```

## `NO_UNNEST` Hint

`NO_UNNEST` Hint 阻止子查询提升的查询改写，即使在子查询可以被有效改写为连接的情况下。它的反向操作是 `UNNEST` Hint。

### 语法

```sql
/*+ NO_UNNEST [ ( [ @ qb_name ] ) ] */
```

#### 参数解释

- `@qb_name`：可选，指定查询块以应用该 Hint。

### 示例

下方的查询示例中，使用 `NO_UNNEST` 禁止子查询提升相关查询改写。

```sql
-- 前提是表 t1 已被创建
CREATE TABLE t1(c1 INT, c2 INT, c3 INT);

-- 应用 NO_UNNEST Hint 保持子查询不被自动改写成连接操作
SELECT (SELECT /*+no_unnest*/ COUNT(*)
        FROM t1 b
        WHERE a.c2 = b.c2)
FROM t1 a;
```