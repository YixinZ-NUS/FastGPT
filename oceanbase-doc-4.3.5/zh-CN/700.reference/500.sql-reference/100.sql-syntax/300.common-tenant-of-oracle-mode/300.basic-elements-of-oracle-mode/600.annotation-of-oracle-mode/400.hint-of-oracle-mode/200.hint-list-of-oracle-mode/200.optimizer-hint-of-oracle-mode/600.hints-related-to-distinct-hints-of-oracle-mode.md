| Description   |                 |
|---------------|-----------------|
| keywords      |                 |
| dir-name      |Distinct Hint    |
| dir-name-en   |                 |
| tenant-type   | Oracle Mode     |
|machine-translation||

# Optimized Hint 类型下的 Distinct Hint

Distinct Hint 用于指导优化器在处理含有 `DISTINCT` 关键字的查询时采取特定的行为。

| Hint 类型                    | 描述                                                   |
|-----------------------------|--------------------------------------------------------|
| `USE_HASH_DISTINCT`           |  启用优化器采用 `HASH` 算法执行 `DISTINCT` 操作。它的反向操作是 `NO_USE_HASH_DISTINCT` Hint。  |
| `NO_USE_HASH_DISTINCT`        |  禁用优化器在执行 `DISTINCT` 操作时不使用 `HASH` 算法。它的反向操作是 `USE_HASH_DISTINCT` Hint。  |
| `DISTINCT_PUSHDOWN`           |  提示优化器允许在分布式环境下进行 `DISTINCT` 下压。它的反向操作是 `NO_DISTINCT_PUSHDOWN` Hint。  |
| `NO_DISTINCT_PUSHDOWN`        |  提示优化器在分布式环境下禁止 `DISTINCT` 下压。它的反向操作是 `DISTINCT_PUSHDOWN` Hint。  |

## `USE_HASH_DISTINCT` Hint

`USE_HASH_DISTINCT` Hint 启用优化器采用 `HASH` 算法执行 `DISTINCT` 操作。它的反向操作是 `NO_USE_HASH_DISTINCT` Hint。

### 语法

```sql
/*+ USE_HASH_DISTINCT [ ( [ @ qb_name ] ) ] */
```

### 示例

下方的查询示例中，使用 `USE_HASH_DISTINCT` 控制启用 `HASH` 去重算法。

```sql
-- 使用 `USE_HASH_DISTINCT` Hint 使查询在执行 `DISTINCT` 操作时采用 `HASH` 算法
EXPLAIN BASIC SELECT /*+ USE_HASH_DISTINCT */ DISTINCT c1, c2, c3 FROM t1;
| Query Plan                                                        |
+-------------------------------------------------------------------+
| ===========================                                       |
| |ID|OPERATOR         |NAME|                                       |
| ---------------------------                                       |
| |0 |HASH DISTINCT    |    |                                       |
| |1 |└─TABLE FULL SCAN|T1  |                                       |
| ===========================                                       |
| Outputs & filters:                                                |
| -------------------------------------                             |
|   0 - output([T1.C1], [T1.C2], [T1.C3]), filter(nil), rowset=16   |
|       distinct([T1.C1], [T1.C2], [T1.C3])                         |
|   1 - output([T1.C1], [T1.C2], [T1.C3]), filter(nil), rowset=16   |
|       access([T1.C1], [T1.C2], [T1.C3]), partitions(p0)           |
|       is_index_back=false, is_global_index=false,                 |
|       range_key([T1.__pk_increment]), range(MIN ; MAX)always true |
+-------------------------------------------------------------------+
14 rows in set
```

## `NO_USE_HASH_DISTINCT` Hint

`NO_USE_HASH_DISTINCT` Hint 禁用执行 distinct 操作使用的具体算法。它的反向操作是 `USE_HASH_DISTINCT` Hint。

### 语法

```sql
/*+ NO_USE_HASH_DISTINCT [ ( [ @ qb_name ] ) ] */
```

### 示例

下方的查询示例中，使用 `NO_USE_HASH_DISTINCT` 禁用优化器执行 `DISTINCT` 操作时使用 `HASH` 算法。由于 Oceanbase 支持 `HASH` 和 `MERGE` 两种去重算法， 使用 `NO_USE_HASH_DISTINCT` Hint 后实际效果为使用 MERGE 去重算法。

```sql
-- 使用 `NO_USE_HASH_DISTINCT` Hint 确保查询在执行 `DISTINCT` 操作时不采用 `HASH` 算法，而是使用 `MERGE` 算法
EXPLAIN BASIC SELECT /*+ NO_USE_HASH_DISTINCT */ DISTINCT c1, c2, c3 FROM t1;
+-------------------------------------------------------------------+
| Query Plan                                                        |
+-------------------------------------------------------------------+
| =============================                                     |
| |ID|OPERATOR           |NAME|                                     |
| -----------------------------                                     |
| |0 |MERGE DISTINCT     |    |                                     |
| |1 |└─SORT             |    |                                     |
| |2 |  └─TABLE FULL SCAN|T1  |                                     |
| =============================                                     |
| Outputs & filters:                                                |
| -------------------------------------                             |
|   0 - output([T1.C1], [T1.C2], [T1.C3]), filter(nil), rowset=16   |
|       distinct([T1.C1], [T1.C2], [T1.C3])                         |
|   1 - output([T1.C1], [T1.C2], [T1.C3]), filter(nil), rowset=16   |
|       sort_keys([T1.C1, ASC], [T1.C2, ASC], [T1.C3, ASC])         |
|   2 - output([T1.C1], [T1.C2], [T1.C3]), filter(nil), rowset=16   |
|       access([T1.C1], [T1.C2], [T1.C3]), partitions(p0)           |
|       is_index_back=false, is_global_index=false,                 |
|       range_key([T1.__pk_increment]), range(MIN ; MAX)always true |
+-------------------------------------------------------------------+
```

## `DISTINCT_PUSHDOWN` Hint

`DISTINCT_PUSHDOWN` Hint 提示优化器在分布式执行时对 `DISTINCT` 操作进行下压，允许在各分区节点先做局部去重压。它的反向操作是 `NO_DISTINCT_PUSHDOWN` Hint。

### 语法

```sql
/*+ DISTINCT_PUSHDOWN [ ( [ @ qb_name ] ) ] */
```

### 示例

下方的查询示例中，使用 `DISTINCT_PUSHDOWN` 启用分布式执行时 `DISTINCT` 的下压。没有添加 Hint 时，默认进行 `DISTINCT` 下压。

```sql
-- 使用 `DISTINCT_PUSHDOWN` Hint 使得分布式查询下压 `DISTINCT` 操作到各分区节点
CREATE TABLE tp1(c1 INT, c2 INT, c3 INT) PARTITION BY HASH(c1) PARTITIONS 10;
EXPLAIN BASIC SELECT /*+ DISTINCT_PUSHDOWN */ DISTINCT c2, c3 FROM tp1;
+---------------------------------------------------------------------------+
| Query Plan                                                                |
+---------------------------------------------------------------------------+
| ===============================================                           |
| |ID|OPERATOR                         |NAME    |                           |
| -----------------------------------------------                           |
| |0 |PX COORDINATOR                   |        |                           |
| |1 |└─EXCHANGE OUT DISTR             |:EX10001|                           |
| |2 |  └─HASH DISTINCT                |        |                           |
| |3 |    └─EXCHANGE IN DISTR          |        |                           |
| |4 |      └─EXCHANGE OUT DISTR (HASH)|:EX10000|                           |
| |5 |        └─HASH DISTINCT          |        |                           |
| |6 |          └─PX PARTITION ITERATOR|        |                           |
| |7 |            └─TABLE FULL SCAN    |TP1     |                           |
| ===============================================                           |
| Outputs & filters:                                                        |
| -------------------------------------                                     |
|   0 - output([INTERNAL_FUNCTION(TP1.C2, TP1.C3)]), filter(nil), rowset=16 |
|   1 - output([INTERNAL_FUNCTION(TP1.C2, TP1.C3)]), filter(nil), rowset=16 |
|       dop=1                                                               |
|   2 - output([TP1.C2], [TP1.C3]), filter(nil), rowset=16                  |
|       distinct([TP1.C2], [TP1.C3])                                        |
|   3 - output([TP1.C2], [TP1.C3]), filter(nil), rowset=16                  |
|   4 - output([TP1.C2], [TP1.C3]), filter(nil), rowset=16                  |
|       (#keys=2, [TP1.C2], [TP1.C3]), dop=1                                |
|   5 - output([TP1.C2], [TP1.C3]), filter(nil), rowset=16                  |
|       distinct([TP1.C2], [TP1.C3])                                        |
|   6 - output([TP1.C2], [TP1.C3]), filter(nil), rowset=16                  |
|       force partition granule                                             |
|   7 - output([TP1.C2], [TP1.C3]), filter(nil), rowset=16                  |
|       access([TP1.C2], [TP1.C3]), partitions(p[0-9])                      |
|       is_index_back=false, is_global_index=false,                         |
|       range_key([TP1.__pk_increment]), range(MIN ; MAX)always true        |
+---------------------------------------------------------------------------+
```

## `NO_DISTINCT_PUSHDOWN` Hint

`NO_DISTINCT_PUSHDOWN` Hint 禁止优化器在分布式执行时对 `DISTINCT` 操作进行下压。它的反向操作是 `DISTINCT_PUSHDOWN` Hint。

### 语法

```sql
/*+ NO_DISTINCT_PUSHDOWN [ ( [ @ qb_name ] ) ] */
```

### 示例

下方的查询示例中，使用 `NO_DISTINCT_PUSHDOWN` 禁止分布式执行时 `DISTINCT` 的下压。

```sql
-- 使用NO_DISTINCT_PUSHDOWN Hint 禁止分布式查询下压DISTINCT操作
CREATE TABLE tp1(c1 INT, c2 INT, c3 INT) PARTITION BY HASH(c1) PARTITIONS 10;
EXPLAIN BASIC SELECT /*+ NO_DISTINCT_PUSHDOWN */ DISTINCT c2, c3 FROM tp1;
+---------------------------------------------------------------------------+
| Query Plan                                                                |
+---------------------------------------------------------------------------+
| ===============================================                           |
| |ID|OPERATOR                         |NAME    |                           |
| -----------------------------------------------                           |
| |0 |PX COORDINATOR                   |        |                           |
| |1 |└─EXCHANGE OUT DISTR             |:EX10001|                           |
| |2 |  └─HASH DISTINCT                |        |                           |
| |3 |    └─EXCHANGE IN DISTR          |        |                           |
| |4 |      └─EXCHANGE OUT DISTR (HASH)|:EX10000|                           |
| |5 |        └─PX PARTITION ITERATOR  |        |                           |
| |6 |          └─TABLE FULL SCAN      |TP1     |                           |
| ===============================================                           |
| Outputs & filters:                                                        |
| -------------------------------------                                     |
|   0 - output([INTERNAL_FUNCTION(TP1.C2, TP1.C3)]), filter(nil), rowset=16 |
|   1 - output([INTERNAL_FUNCTION(TP1.C2, TP1.C3)]), filter(nil), rowset=16 |
|       dop=1                                                               |
|   2 - output([TP1.C2], [TP1.C3]), filter(nil), rowset=16                  |
|       distinct([TP1.C2], [TP1.C3])                                        |
|   3 - output([TP1.C2], [TP1.C3]), filter(nil), rowset=16                  |
|   4 - output([TP1.C2], [TP1.C3]), filter(nil), rowset=16                  |
|       (#keys=2, [TP1.C2], [TP1.C3]), dop=1                                |
|   5 - output([TP1.C2], [TP1.C3]), filter(nil), rowset=16                  |
|       force partition granule                                             |
|   6 - output([TP1.C2], [TP1.C3]), filter(nil), rowset=16                  |
|       access([TP1.C2], [TP1.C3]), partitions(p[0-9])                      |
|       is_index_back=false, is_global_index=false,                         |
|       range_key([TP1.__pk_increment]), range(MIN ; MAX)always true        |
+---------------------------------------------------------------------------+
27 rows in set
```