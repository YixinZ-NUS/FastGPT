| Description   |                 |
|---------------|-----------------|
| keywords      |                 |
| dir-name      |                 |
| dir-name-en   |                 |
| tenant-type   | Oracle Mode     |
|machine-translation||

# INSERT

## 描述

该语句用于向表中添加一个或多个记录。

## 权限要求

执行 `INSERT` 语句需要当前用户拥有 `INSERT` 的系统权限。有关 OceanBase 数据库权限的详细介绍，请参见 [Oracle 模式下的权限分类](../../../../../../600.manage/500.security-and-permissions/300.access-control/200.user-and-permission/300.permission-of-oracle-mode/000.permission-classification-of-oracle-mode.md)。

## 语法

```sql
INSERT [hint_options] { single_table_insert | multi_table_insert | overwrite_table_insert};

single_table_insert:
    { INTO insert_table_clause { NOLOGGING | /*EMPTY*/ } '(' column_list ')' values_clause [{ RETURNING | RETURN } returning_exprs [into_clause]]
    | INTO insert_table_clause { NOLOGGING | /*EMPTY*/ } '(' ')' values_clause [{ RETURNING | RETURN } returning_exprs [into_clause]]
    | INTO insert_table_clause { NOLOGGING | /*EMPTY*/ } values_clause [{ RETURNING | RETURN } returning_exprs [into_clause]]
    }

hint_options:
    [/*+ [APPEND | DIRECT(bool, int, load_mode)] enable_parallel_dml PARALLEL(N) | NO_DIRECT */]
    [INTO] table_name [PARTITION(PARTITION_OPTION)]

column_list:
      column_definition_ref [, column_definition_ref...]

returning_exprs:
    projection_col_name [,projection_col_name ...]

insert_into_clause:
    { INTO into_var_list | BULK COLLECT INTO into_var_list}

into_var_list:
    { USER_VARIABLE | ref_name } [, { USER_VARIABLE | ref_name }...]

values_clause:
    VALUES ({ expr | DEFAULT } [, { expr | DEFAULT } ]...  )

returning_exprs:
    projection_col_name [,projection_col_name ...]

multi_table_insert:
    { ALL { insert_into_clause [ values_clause ] [error_logging_clause] }
    | conditional_insert_clause
    } subquery

conditional_insert_clause:
    [ ALL | FIRST ]
    WHEN condition
    THEN insert_into_clause
    [ values_clause ]
    [ error_logging_clause ]
    [ insert_into_clause [ values_clause ] [ error_logging_clause ] ]...
    [ WHEN condition
        THEN insert_into_clause
        [ values_clause ]
        [ error_logging_clause ]
        [ insert_into_clause [ values_clause ] [ error_logging_clause ] ]...
    ]...
    [ ELSE insert_into_clause
        [ values_clause ]
        [ error_logging_clause ]
        [ insert_into_clause [ values_clause ] [ error_logging_clause ] ]...
    ]

error_logging_clause:
    LOG ERRORS [ INTO [schema.] table_name] [ (simple_expression) ] [ REJECT LIMIT { integer | UNLIMITED } ]

overwrite_table_insert:
    [/*+PARALLEL(N)*/] OVERWRITE table_name [(list_of_columns)] [PARTITION (partition_name, ...)] select_stmt
```

## 参数解释

|            参数           |                            描述                                      |
|---------------------------|---------------------------------------------------------------------|
| hint_options              | 使用 Hint 启用旁路导入功能，可选项。更多使用 Hint 信息，参见 [Hint 概述](../../300.basic-elements-of-oracle-mode/600.annotation-of-oracle-mode/400.hint-of-oracle-mode/100.hint-overview-of-oracle-mode.md)。<main id="notice" type='notice'><h4>注意</h4><p>在执行旁路导入任务的过程中，不建议同时进行 OceanBase 数据库的升级操作，因为这可能导致旁路导入任务失败。</p></main> `INSERT INTO SELECT` 语句支持通过 `APPEND \| DIRECT()\| NO_DIRECT` Hint 控制数据的导入方式，格式为 `/*+ [APPEND \| DIRECT(bool, int, load_mode)] enable_parallel_dml PARALLEL(N) \| NO_DIRECT */`。Hint 中各参数解释如下：<ul><li><code>APPEND</code>：默认等同于使用的 <code>DIRECT(true, 0)</code>，同时可以实现在线收集统计信息（</code>GATHER_OPTIMIZER_STATISTICS</code> Hint）的功能。</li><li><code>DIRECT()</code>：<ul><li><code>bool</code>：表示写入的数据是否需要排序，<code>true</code> 表示需要排序，<code>false</code> 表示不需要排序。</li><li><code>int</code>：表示最大容忍的错误行数。</li><li><code>load_mode</code>：可选参数，表示旁路导入的模式。取值须使用英文单引号包起来，取值如下：<ul><li><code>full</code>：默认值，表示全量导入。</li><li><code>inc</code>：表示增量导入，支持 <code>INSERT</code> 和 <code>IGNORE</code> 语义。</li><li><code>inc_replace</code>：表示增量导入，但不检查主键是否重复，相当于 <code>REPLACE</code> 语义的增量导入。</li></ul> </li><li><code>enable_parallel_dml parallel(N)</code>：加载数据的并行度，<code>N</code> 默认为 4。<main id="notice" type='explain'><h4>说明</h4><p>一般情况下，<code>enable_parallel_dml</code> Hint 和 <code>parallel</code> Hint 必须配合使用才能开启并行 DML。不过，当目标表的 Schema 上指定了表级别的并行度时，仅需指定 <code>enable_parallel_dml</code> Hint。</p></main></li></ul><li><code>NO_DIRECT</code>：控制单条 SQL 强制不走旁路导入，只要输入的 SQL 带有该 Hint，则整个语句忽略其他旁路导入的 Hint，执行普通导入。</li></ul>更多使用 `INSERT INTO SELECT` 旁路导入的信息，参见 [使用 INSERT INTO SELECT 语句旁路导入数据](../../../../../../620.obap/300.obap-data-collection/300.obap-import-data/20.bypass-import/200.full-bypass-import.md)。|
| table_name                       | 导入数据的表的名称，支持指定表任意列数目。  |
| PARTITION_OPTION                   | 指定分区旁路导入时的分区名：<ul><li>partition_option_list：一级分区列表，同时插入多个分区时以逗号（,）分隔。 </li> <li>subpartition_option_list：二级分区列表，同时插入多个分区时以逗号（,）分隔。</li></ul>|
| single_table_insert       | 单表插入。                                                                                                                                                                                                             |
| insert_table_clause       | 指定的插入的表，可以是基表、可更新视图、特殊子查询。   <main id="notice" type='notice'><h4>注意</h4><p>特殊子查询是指类似于可更新视图对应的子查询，这类子查询不应该包含复杂的算子（例如 <code>GROUP BY</code>、<code>DISTINCT</code>、<code>WINDOW FUNCTION</code> 等）。                                                                                                                                                                                      |
| opt_nologging             | 尽量减少插入时的日志信息。                                                                                                                                                                                                     |
| column_list               | 指定要插入的列名。                                                                                                                                                                                                         |
| returning_exprs           | 返回插入数据之后的投影列。                                                                                                                                                                                                     |
| insert_into_clause        | 将插入数据之后的列值插入到指定列表中。                                                                                                                                                                                               |
| multi_table_insert        | 多表插入。                                                                                                                                                                                                             |
| conditional_insert_clause | 带条件的多表插入。 <ul><li> `ALL`：遍历所有匹配条件的分支，只要满足条件就会将数据插入对应的表。   </li><li> `FIRST`：找到第一个满足条件的分支后，将数据插入该分支对应的表，不会再继续检查剩余分支的条件是否满足。</li></ul>    |
| error_logging_clause      | 将 SQL 错误和受影响的行数列中的值保存在一个错误记录表。                                                                                                                                                                                    |
| overwrite_table_insert  | 用于将查询结果替换表或分区中的现有数据。有关使用 `INSERT OVERWRITE SELECT` 语句的详细信息，参见 [插入数据](../../../../../../300.develop/200.application-development-of-oracle-mode/400.write-data-of-oracle-mode/100.insert-data-of-oracle-mode-in-develop.md) 中的 **使用 INSERT OVERWRITE SELECT 语句插入数据** 章节。|
| list_of_columns   | 指定表中需要插入数据的列。                     |
| select_stmt             | 指定 `SELECT` 子句。有关查询语句的详细信息，参见 [SIMPLE SELECT](500.select-of-oracle-mode/100.simple-select-of-oracle-mode.md)。|

## 示例

示例表及数据基于以下定义：

```shell
obclient> CREATE TABLE tbl(col1 INT PRIMARY KEY, col2 INT,col3 INT);
Query OK, 0 rows affected

obclient> CREATE TABLE tbl2(col1 INT PRIMARY KEY, col2 INT,col3 INT);
Query OK, 0 rows affected

obclient> CREATE TABLE tbl3(col1 INT PRIMARY KEY, col2 INT,col3 INT);
Query OK, 0 rows affected
```

* 单表插入：向表 `tbl1` 中插入两行数据。

  ```shell
  obclient> INSERT INTO tbl1 (col1, col2, col3) VALUES (1, 10, 100), (2, 20, 200);
  Query OK, 2 row affected

  obclient> SELECT * FROM tbl1;
  +------+------+------+
  | COL1 | COL2 | COL3 |
  +------+------+------+
  |    1 |   10 |  100 |
  |    2 |   20 |  200 |
  +------+------+------+
  2 rows in set
  ```

* 单表插入：直接向子查询中插入数据。

  ```shell
  obclient>INSERT INTO tbl1 (col1, col2, col3) SELECT col1 + 2, col2 + 5, col3 + 10 FROM tbl1;
  Query OK, 2 row affected

  obclient> SELECT * FROM tbl1;
  +------+------+------+
  | COL1 | COL2 | COL3 |
  +------+------+------+
  |    1 |   10 |  100 |
  |    2 |   20 |  200 |
  |    3 |   15 |  110 |
  |    4 |   25 |  210 |
  +------+------+------+
  4 rows in set
  ```

* 单表插入：包含 `RETURNING` 子句。

  ```shell
  obclient> INSERT INTO tbl1 (col1, col2, col3) VALUES (5, 50, 500), (6, 60, 600) RETURNING col1;
  +------+
  | COL1 |
  +------+
  |    5 |
  |    6 |
  +------+
  2 rows in set

  obclient> SELECT * FROM tbl1;
  +------+------+------+
  | COL1 | COL2 | COL3 |
  +------+------+------+
  |    1 |   10 |  100 |
  |    2 |   20 |  200 |
  |    3 |   15 |  110 |
  |    4 |   25 |  210 |
  |    5 |   50 |  500 |
  |    6 |   60 |  600 |
  +------+------+------+
  6 rows in set
  ```

* 普通的多表插入：当表 `tbl3` 中有至少一行数据时，向表 `tbl1` 插入一行数据 (7,8,9)，向表 `tbl2` 插入一行数据 (10,11,12)。

  ```shell
  obclient> INSERT ALL INTO tbl1 VALUES(7,8,9)
                                      INTO tbl2 VALUES(10,11,12)
                  SELECT * FROM tbl3 WHERE ROWNUM< 2;
  Query OK, 2 rows affected
  Records: 2  Duplicates: 0  Warnings: 0

  obclient> SELECT * FROM tbl1;
  +------+------+------+
  | COL1 | COL2 | COL3 |
  +------+------+------+
  |    1 |   10 |  100 |
  |    2 |   20 |  200 |
  |    3 |   15 |  110 |
  |    4 |   25 |  210 |
  |    5 |   50 |  500 |
  |    6 |   60 |  600 |
  |    7 |    8 |    9 |
  +------+------+------+
  7 rows in set

  obclient> SELECT * FROM tbl2;
  +------+------+------+
  | COL1 | COL2 | COL3 |
  +------+------+------+
  |   10 |   11 |   12 |
  +------+------+------+
  1 row in set
  ```

* 带条件的多表插入：使用 `INSERT ALL`，当表 `tbl` 中 `col2` 的值大于 `1` 时，向表 `tbl1` 中插入数据 (10,11,12)；当表 `tbl` 中 `col3` 的值大于 `1` 时，向表 `tbl2` 中插入数据 (22,23,24)；如果都不满足，则向表 `tbl1` 中插入数据 (33,34,35)。

  ```shell
  obclient> INSERT INTO tbl VALUES(1,2,3);
  Query OK, 1 row affected

  obclient>INSERT ALL
                WHEN col2 > 1 THEN INTO tbl1 VALUES(10,11,12)
                WHEN col3 > 1 THEN INTO tbl2 VALUES(22,23,24)
                ELSE INTO tbl1 VALUES(33,34,35) SELECT col2,col3 FROM tbl;
  Query OK, 2 rows affected
  Records: 2  Duplicates: 0  Warnings: 0

  obclient> SELECT * FROM tbl1;
  +------+------+------+
  | COL1 | COL2 | COL3 |
  +------+------+------+
  |    1 |   10 |  100 |
  |    2 |   20 |  200 |
  |    3 |   15 |  110 |
  |    4 |   25 |  210 |
  |    5 |   50 |  500 |
  |    6 |   60 |  600 |
  |    7 |    8 |    9 |
  |   10 |   11 |   12 |
  +------+------+------+
  8 rows in set

  obclient> SELECT * FROM tbl2;
  +------+------+------+
  | COL1 | COL2 | COL3 |
  +------+------+------+
  |   10 |   11 |   12 |
  |   22 |   23 |   24 |
  +------+------+------+
  2 rows in set
  ```

* 带条件的多表插入：使用 `INSERT FIRST`，当表 `tbl` 中 `col2` 的值大于 `1` 时，向表 `tbl1` 中插入数据 (14,15,16)，向表 `tbl2` 中插入数据 (40,41,42)；当表 `tbl` 中 `col3` 的值大于 `1` 时，向表 `tbl2` 中插入数据 (25,26,27)；如果都不满足，则向表 `tbl1` 中插入数据 (35,36,37)。

  ```shell
  obclient>INSERT ALL
                WHEN col2 > 1 THEN INTO tbl1 VALUES(14,15,16) INTO tbl2 VALUES(40,41,42)
                WHEN col3 > 1 THEN INTO tbl2 VALUES(25,26,27)
                ELSE INTO tbl1 VALUES(35,36,37) SELECT col2,col3 FROM tbl;
  Query OK, 3 rows affected
  Records: 3  Duplicates: 0  Warnings: 0

  obclient> SELECT * FROM tbl1;
  +------+------+------+
  | COL1 | COL2 | COL3 |
  +------+------+------+
  |    1 |   10 |  100 |
  |    2 |   20 |  200 |
  |    3 |   15 |  110 |
  |    4 |   25 |  210 |
  |    5 |   50 |  500 |
  |    6 |   60 |  600 |
  |    7 |    8 |    9 |
  |   10 |   11 |   12 |
  |   14 |   15 |   16 |
  +------+------+------+
  9 rows in set

  obclient> SELECT * FROM tbl2;
  +------+------+------+
  | COL1 | COL2 | COL3 |
  +------+------+------+
  |   10 |   11 |   12 |
  |   22 |   23 |   24 |
  |   25 |   26 |   27 |
  |   40 |   41 |   42 |
  +------+------+------+
  4 rows in set
  ```

* 通过 `direct` Hint 的 load_mode 参数来指定增量旁路导入。

  ```sql
  obclient [SYS]> INSERT /*+ direct(true, 0, 'inc_replace') enable_parallel_dml parallel(2) */ INTO tbl2 SELECT * FROM tbl1;
  ```

  返回结果如下：

  ```sql
  Query OK, 8 rows affected
  Records: 8  Duplicates: 0  Warnings: 0
  ```

* 指定分区旁路导入。
  假设在表 `tbl1` 和表 `tbl2` 中的分区规则如下：

  ```sql
  partition p0 values less than (10)
      subpartition p0_1 values less than (5)
      subpartition p0_2 values less than (10)
  partition p1 values less than (20)
      subpartition p1_1 values less than (15)
      subpartition p1_2 values less than (20)
  ```

  * 指定一级分区旁路导入

    ```sql
    insert /*+ enable_parallel_dml parallel(3) append */
    into tbl2 partition(p0, p1)
    select * from tbl1 partition(p0, p1);
    ```

  * 指定二级分区旁路导入

    ```sql
    insert /*+ enable_parallel_dml parallel(3) append */
    into tbl2 partition(p0sp0_1, p1sp1_1)
    select * from tbl1 partition(p0sp0_1, p1sp1_1);
    ```

## 相关文档

* [插入数据](../../../../../../300.develop/200.application-development-of-oracle-mode/400.write-data-of-oracle-mode/100.insert-data-of-oracle-mode-in-develop.md)
* [使用 INSERT INTO SELECT 语句旁路导入数据](../../../../../../620.obap/300.obap-data-collection/300.obap-import-data/20.bypass-import/200.full-bypass-import.md)
* [SIMPLE SELECT](500.select-of-oracle-mode/100.simple-select-of-oracle-mode.md)