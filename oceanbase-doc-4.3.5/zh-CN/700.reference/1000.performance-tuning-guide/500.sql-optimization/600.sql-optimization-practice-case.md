# SQL 执行计划调优实践

某客户数据库系统发生性能故障，出现大量交易拥堵现象，直接原因是部分 OceanBase 数据库服务器节点的 CPU 使用率飙升至 100%，导致交易无法正常处理。通过分析 `GV$OB_SQL_AUDIT` 视图的执行审计信息，定位到一条问题 SQL 的平均执行时间为 2 秒，其 CPU 占用率超过该节点总 CPU 资源的 70%。结合执行计划（Explain）及表/视图的 DDL 定义，最终通过 DDL 优化将 SQL 的 CPU 耗时降至 4 ms，彻底消除性能瓶颈。

## 排查思路

本案例的排查和优化思路如下：

1. 通过查询 `GV$OB_SQL_AUDIT` 视图定位 TOP SQL。

   执行如下 SQL 语句查询指定时间段内（30 分钟）某指定的 OBserver 节点上（`svr_ip`）的 SQL (`GROUP BY sql_id`) 相比于问题时间段内总 CPU 的使用率（`SUM(execute_time)/(30*60*1000*1000）AS cpu_cnt`）等信息，筛选出 CPU 占用率最高的 SQL：

   ```sql
   SELECT sql_id,
          COUNT(*)               AS executions,
          SUM(execute_time)      AS tot_cpu_time,
          AVG(execute_time)      AS avg_cpu_time,
          SUM(execute_time)/(30*60*1000*1000)     AS cpu_cnt,
          query_sql
       FROM oceanbase.GV$OB_SQL_AUDIT
       WHERE tenant_id= 'mysql001'
           AND svr_ip='xxx.xxx.xxx.xxx'
           AND request_time BETWEEN (TIME_TO_USEC(NOW())-30*60*1000*1000) AND TIME_TO_USEC(NOW())
           AND is_executor_rpc =0
           GROUP BY sql_id
           HAVING COUNT(*)>1
           ORDER BY cpu_cnt DESC LIMIT 10;
   ```

   **结果分析**：

   - `SELECT ... FROM V_TT01 WHERE (COL001 IN (...))` 类 SQL 的执行频率和 CPU 使用率较高，大概为 70%（80 c/108 c），而且集中于同一台 OBServer 节点上。

   ```shell
   +----------------------------------+------------+--------------+--------------+---------+------------------------------------------------------------------------------------------------------------------------------------------------------+
   |       sql_id                     | executions | tot_cpu_time | avg_cpu_time | cpu_cnt | query_sql      |
   +----------------------------------+------------+--------------+--------------+---------+------------------------------------------------------------------------------------------------------------------------------------------------------+
   | 2705182A6EAB699CEC8E59DA80710B64 |   23,425 |   33,818,182,526  |      1,443,679 |      56 | SELECT ... FROM V_TT01 WHERE (COL001 IN (20017476)) |
   | 32AB97A0126F566064F84DDDF4936F82 |    7,112 |     7,926.295,919 |      1,114,496 |      13 | SELECT ... FROM V_TT01 WHERE (COL001 IN (20035891,20035892)) |
   | A5F514E873BE9D1F9A339D0DA7481D69 |    4,046 |     6,053,872,739 |      1,496,261 |      10 | SELECT ... FROM V_TT01 WHERE (COL001 IN (20017892,20007654,20025634)) |
   | 31FD78420DB07C11C8E3154F1658D237 |      186 |       646,926,207 |      3,478,098 |       1 | SELECT ... FROM V_TT01 WHERE (COL001 IN (20027596,20035891))  |
   | C48AEE941D985D8DEB66892228D5E845 |       28 |       569,004,505 |     20,321,589 |       1 | SELECT ... |
   | 101B7B79DFA9AE801BEE4F1A234AD294 |      155 |       440,190,675 |      2,839,940 |       1 | SELECT ... |
   | 1D0BA376E273B9D622641124D8C59264 |      423 |       429,140,148 |      1,014,516 |       1 | SELECT ... |
   | 64CF75576816DB5614F3D5B1F35B1472 |      113 |       326,338,159 |      2,887,948 |       1 | SELECT ... |
   | 23D1C653347BA469396896AD9B20DCA1 |      381 |       309.367.170 |        811,987 |       1 | SELECT ... |
   | FA4F493FA5CE2DCC64F51CF3754F96C6 |        7 |       289,191,515 |     41,313,074 |       0 | SELECT ... |
   +------------+----------------------------+--------------+------------+--------------+------------------------------------------------------------------------------------------------------------------------------------------------------+
   10 rows in set

   ```

2. 分析执行计划（Explain）定位性能瓶颈。

   通过 `EXPLAIN` 命令获取问题 SQL 的执行计划：

   ```shell
   =================================================================================
   |ID|OPERATOR                             |NAME                 |EST. ROWS|COST  |
   ---------------------------------------------------------------------------------
   |0 |EXCHANGE IN REMOTE                   |                     |177      |432961|
   |1 | EXCHANGE OUT REMOTE                 |                     |177      |397632|
   |2 |  SUBPLAN SCAN                       |V_TT01               |177      |397632|
   |3 |   UNION ALL                         |                     |177      |397629|
   |4 |    NESTED-LOOP JOIN CARTESIAN       |                     |0        |151990|
   |5 |     TABLE SCAN                      |TBL1(IDX_TBL1_COL001)|1        |92    |
   |6 |     MATERIAL                        |                     |0        |151899|
   |7 |      NESTED-LOOP ANTI JOIN CARTESIAN|                     |0        |151899|
   |8 |       TABLE SCAN                    |TT01(IDX_TT01_COL001)|1        |92    |
   |9 |       MATERIAL                      |                     |177      |151781|
   |10|        SUBPLAN SCAN                 |VIEW1                |177      |151780|
   |11|         TABLE SCAN                  |TBL3(IDX_TBL3_COL170)|177      |151777|
   |12|    NESTED-LOOP JOIN CARTESIAN       |                     |177      |236327|
   |13|     TABLE GET                       |TBL2                 |1        |46    |
   |14|     TABLE SCAN                      |TBL3(IDX_TBL3_COL170)|177      |235510|
   =================================================================================

   Outputs & filters:
   -------------------------------------

     5 - output(......), filter(nil),
         access(......), partitions(p0),
         is_index_back=true,
         range_key([TBL1.COL001(0x7f510ed97860)], [TBL1.COL002(0x7f48eec9baa0)]), range(20017476,MIN ; 20017476,MAX),
         range_cond([TBL1.COL001(0x7f510ed97860) = 20017476(0x7f510edbd750)])

     8 - output(......), filter(nil),
         access(......), partitions(p0),
         is_index_back=true,
         range_key([TT01.COL001(0x7f510ed97570)], [TT01.COL003(0x7f510ed97b50)]), range(20017476,MIN ; 20017476,MAX),
         range_cond([TT01.COL001(0x7f510ed97570) = 20017476(0x7f510edbcc50)])

    11 - output(......), filter([20017476 = cast(cast(TBL3.COL170(0x7f3f5b51c090), VARCHAR2(20 BYTE))(0x7f3f5b51d6b0), NUMBER(-1, -85))(0x7f3f5b51ce80)(0x7f3f5b51c380)]),
         access(......), partitions(p0),
         is_index_back=false, filter_before_indexback[false],
         range_key([TBL3.COL170(0x7f3f5b51c090)], [TBL3.COL002(0x7f3f5b528e80)]), range(MIN,MIN ; MAX,MAX)always true

    13 - output(......), filter(nil),
         access(......), partitions(p0),
         is_index_back=false,
         range_key([TBL2.COL004(0x7f0cb0ff9f20)]), range[20017476 ; 20017476],
         range_cond([TBL2.COL004(0x7f0cb0ff9f20) = 20017476(0x7f0cb1001170)])

    14 - output(......), filter([20017476 = cast(cast(TBL3.COL170(0x7f0cb0ffa210), VARCHAR2(20 BYTE))(0x7f0cb1002fa0), NUMBER(-1, -85))(0x7f0cb1002770)(0x7f0cb1001c70)]),
         access(......), partitions(p0),
         is_index_back=true, filter_before_indexback[true],
         range_key([TBL3.COL170(0x7f0cb0ffa210)], [TBL3.COL002(0x7f3f5b582c10)]), range(MIN,MIN ; MAX,MAX)always true
   ```

   **结果分析**：

    - 根据上述 `EXPALIN` 信息，了解得到该条 SQL 的执行总代价估算为 432961，代价主要体现在 3 号算子 `UNION ALL` 部分（代价估算为 397629），`UNION ALL` 的两个分支都包含 `NESTED-LOOP JOIN`，代价估算分别为 151990 和 236327。`UNION ALL` 部分第一个分支（从 4 号到 11 号算子）的主要代价体现在 11 号算子上面，即通过索引 `TBL3(IDX_TBL3_COL170)` 进行 `TABLE SCAN`；

    - 第二个分支（从 12 号到 14 号算子）的主要代价体现在 14 号算子上面，也是通过索引 `TBL3(IDX_TBL3_COL170)` 进行 `TABLE SCAN`。由此可见 11 号算子和 14 号算子代价偏高可能都是由于 `TBL3` 的索引导致的，初步定位出该案例中性能问题的瓶颈点。

    - 观察下述执行计划，分析 11 号算子和 14 号算子的 Outputs & filters 信息，其中 `range(MIN,MIN ; MAX,MAX)always true` 表明该 SQL 执行过程中没有做索引匹配，而 `filter([20017476 = cast(cast(TBL3.COL170(0x7f0cb0ffa210), VARCHAR2(20 BYTE))(0x7f0cb1002fa0), NUMBER(-1, -85))(0x7f0cb1002770)(0x7f0cb1001c70)])` 表明在访问时发生了数据类型的转换，由此得知可能是关联字段的数据类型不统一而进行了数据类型的转换，导致了 `TBL3.COL170` 上的索引不能做匹配。基于此结论再结合 DDL 定义做进一步的分析。

    ```sql
     11 - output(......), filter([20017476 = cast(cast(TBL3.COL170(0x7f3f5b51c090), VARCHAR2(20 BYTE))(0x7f3f5b51d6b0), NUMBER(-1, -85))(0x7f3f5b51ce80)(0x7f3f5b51c380)]),
          access(......), partitions(p0),
          is_index_back=false, filter_before_indexback[false],
          range_key([TBL3.COL170(0x7f3f5b51c090)], [TBL3.COL002(0x7f3f5b528e80)]), range(MIN,MIN ; MAX,MAX)always true

     14 - output(......), filter([20017476 = cast(cast(TBL3.COL170(0x7f0cb0ffa210), VARCHAR2(20 BYTE))(0x7f0cb1002fa0), NUMBER(-1, -85))(0x7f0cb1002770)(0x7f0cb1001c70)]),
          access(......), partitions(p0),
          is_index_back=true, filter_before_indexback[true],
          range_key([TBL3.COL170(0x7f0cb0ffa210)], [TBL3.COL002(0x7f3f5b582c10)]), range(MIN,MIN ; MAX,MAX)always true
    ```

    **关键发现**：

    - **总代价**：UNION ALL 算子（3 号算子）的代价占总执行计划的 92%（397,629 / 432,961）。
    - **索引失效**：TBL3 表的索引 IDX_TBL3_COL170 未生效，导致 TABLE SCAN 全表扫描。
    - **类型转换问题**：COL170 字段为 VARCHAR2，与关联字段 NUMBER 类型不匹配，强制转换导致索引失效。


3. 分析相关表和视图的 DDL 定义，确定出现性能问题的原因。

   - 首先，从视图 `V_TT01` 的定义中可知, `UNION ALL` 的第一个分支中 `tbl3` 存在于 `NOT EXISTS` 子查询中，结合 `EXPLAIN` 信息，可以得出相关子查询被改写为 `NESTED-LOOP ANTI JOIN`。此外，视图 `V_TT01` 发生了 `TO_NUMBER` 转换，其中的 `col001` 和 `col004` 会通过 `col170` 传递给 `TBL3` 的索引 `(IDX_TBL3_COL170)`。

   - 接下来分析表 `TBL3` 的定义，可知索引 `TBL3(IDX_TBL3_COL170)` 定义于 `COL170` 字段，数据类型为 `VARCHAR2(20)`，而该字段就是视图 `V_TT01` 与其他表进行关联的字段。从视图 `V_TT01` 的定义可知，`UNION ALL` 第一个分支中，11 号算子对应的关联为 `"tbl3"."col170" = "tt01"."col001" = 20017476`, 第二个分支中 14 号算子对应的关联为 `"tbl3"."col170" = "tbl2"."col004" = 20017476`，由于关联字段数据类型不一致，所以发生了 `TO_NUMBER` 转换，即将 `COL170` 字段的 `VARCHAR2` 类型被强制转换为了 `NUMBER`。这与 11 号算子和 14 号算子的 Outputs & filters 中的 `filter` 信息相符合。

   综合 DDL 定义和 `EXPALIN` 信息可知，该类别 SQL 执行过程中，视图 `V_TT01` 发生的 `TO_NUMBER` 强制转换不合理导致索引性能下降，造成 11 号和 14 号算子的代价估算较大，应该去掉 `TO_NUMBER` 转换。

   ```sql
   /* 问题 SQL 的定义 */
   SELECT ......
       FROM   v_tt01
       WHERE  COL001 IN (20017476);

   /* 视图 V_TT01 的定义 */
   CREATE VIEW "V_TT01_OLD"
   AS
     (SELECT
             To_number("LOCAL_CXZX"."tt01"."col001") AS "COL001",
             ... ...
      FROM   "LOCAL_CXZX"."tt01",
             "LOCAL_CXZX"."tbl1"
      WHERE  ( "LOCAL_CXZX"."tt01"."col001" = "LOCAL_CXZX"."tbl1"."col001" )
             AND NOT EXISTS((SELECT 1
                             FROM   "LOCAL_CXZX"."tbl3"
                             WHERE  ( "LOCAL_CXZX"."tt01"."col001" =
                                      "LOCAL_CXZX"."tbl3"."col170"
                                    ))))

     UNION ALL

     (SELECT
             To_number("LOCAL_CXZX"."tbl2"."col004") AS "COL001",
             ... ...
      FROM   "LOCAL_CXZX"."tbl2",
             "LOCAL_CXZX"."tbl3" "TBL3"
      WHERE  ( "LOCAL_CXZX"."tbl2"."col004" = "tbl3"."col170" ))

      ;


   /* 表 TBL1 的定义*/
   CREATE TABLE "LOCAL_BDZGBGYY"."TBL1" (
     "COL001" NUMBER(16)  NOT NULL ,    // 5: To_number("tt01"."col001") = "tbl1"."col001" = 20017476,  To_number(NUMBER(16)) = NUMBER(20)
     ... ...
     PRIMARY KEY ("COL002")
   ) ;

   CREATE INDEX "LOCAL_BDZGBGYY"."IDX_TBL1_COL001" on "LOCAL_BDZGBGYY"."TBL1" (
    "COL001"
   ) GLOBAL ;


   /* 表 TT01 的定义 */
   CREATE TABLE "EINP_BASICINFO"."TT01" (
   ... ...
     "COL001" NUMBER(20)  NOT NULL,     // 8: To_number("tt01"."col001") = "tbl1"."col001" = 20017476,  To_number(NUMBER(16)) = NUMBER(20)
   ... ...
     PRIMARY KEY ("COL003")
   ) ;

   CREATE INDEX "EINP_BASICINFO"."IDX_TT01_COL001" on "EINP_BASICINFO"."TT01" (
    "COL001"
   ) GLOBAL ;


   /* 表 TBL3 的定义*/
   CREATE TABLE "LOCAL_BDZGBGYY"."TBL3" (
     "COL170" VARCHAR2(20) NOT NULL,      // 11: "tbl3"."col170" = "tt01"."col001" = 20017476, VARCHAR2(20) 修改为 NUMBER (20)
     ... ...                              // 14: "zb10"."col170" = "tbl2"."col004" = 20017476, VARCHAR2(20) 修改为 NUMBER (20)
     PRIMARY KEY ("COL002")
   ) ;

   CREATE INDEX "LOCAL_BDZGBGYY"."IDX_TBL3_COL170" on "LOCAL_BDZGBGYY"."TBL3" (
    "COL170"
   ) GLOBAL ;

   /* 表 TBL2 的定义 */
   CREATE TABLE "SICP4_BASICINFOCENTER_EINP"."TBL2" (
     "COL004" NUMBER(20)  NOT NULL,      //  13: COL004 = 20017476
     ... ....
     PRIMARY KEY ("COL004")
   ) ;
   ```

   **关键表字段类型对比**：

   |  表/字段	                |  数据类型	      |  关联条件	  |  问题描述  |
   |--------------------------|----------------|------------|----------|
   |TT01.COL001               |	NUMBER(20)	  | tt01.COL001 = tbl3.COL170	|视图中强制转换为 To_number，导致类型不匹配|
   |TBL3.COL170	              | VARCHAR2(20)	|tbl3.COL170 = tt01.COL001	|字符串类型无法直接与 NUMBER 关联字段匹配|
   |TBL2.COL004               |	NUMBER(20)	  |tbl2.COL004 = tbl3.COL170	|同 TBL3.COL170 类型不匹配问题|

## 优化思路

本案例中针对表和视图的 DDL 优化方案如下：

1. 移除不必要的类型转换。

   - 问题：视图 `V_TT01` 中的 `TO_NUMBER` 转换导致关联字段类型不匹配，索引失效。
   - 优化：直接使用原生字段类型，移除 `TO_NUMBER`：

   ```sql
   -- 优化后的视图定义（移除类型转换）
   CREATE VIEW "V_TT01_NEW" AS
   (
       SELECT
           "tt01"."col001" AS "COL001",
           ...
       FROM
           "tt01", "tbl1"
       WHERE
           "tt01"."col001" = "tbl1"."col001"
           AND NOT EXISTS (
               SELECT 1
               FROM "tbl3"
               WHERE "tt01"."col001" = "tbl3"."col170"
           )
       UNION ALL
       (
           SELECT
               "tbl2"."col004" AS "COL001",
               ...
           FROM
               "tbl2", "tbl3"
           WHERE
               "tbl2"."col004" = "tbl3"."col170"
       )
   );
   ```

   - 效果：SQL 执行时间从 2s 缩短至 150 ms，优化器选择更优的 JOIN 顺序。

2. 统一字段数据类型。

   - 问题：`TBL3.COL170` 为 `VARCHAR2(20)`，而关联字段 COL001 和 COL004 为 `NUMBER`，导致类型转换和索引失效。
   - 优化：

   ```sql
   -- 修改 TBL3 字段类型为 NUMBER(20)
   ALTER TABLE "TBL3" MODIFY ("COL170" NUMBER(20));

   -- 重建索引
   CREATE INDEX "IDX_TBL3_COL170" ON "TBL3" ("COL170");
   ```


   - 效果：表与视图中的关联字段的数据类型定义统一为 `NUMBER(20)`，规避类型转换后，使得 `TBL3(IDX_TBL3_COL170)` 可以做索引匹配，类型统一后索引生效，SQL 执行时间进一步降至 20 ms。

3. 分区与表组改造。

   - 问题：热点视图 `V_TT01` 导致单节点 CPU 负载过高。
   - 优化方案：
     - Hash 分区：对关联表按 `COL001/COL004/COL170` 字段进行 Hash 分区。
     - 表组绑定：将关联表加入同一表组，避免跨节点关联查询。

   ```sql
   -- 示例：对 TBL3 进行 Hash 分区
   ALTER TABLE "TBL3"
   PARTITION BY HASH("COL170")
   PARTITIONS 8;

   -- 将表加入表组
   ALTER TABLE "TBL3" SET TABLEGROUP = 'group1';
   ```

   - 效果：查询压力分散至多节点，最终 SQL 执行时间降至 4 ms。

**优化后的执行计划**：

```sql
====================================================================
|ID|OPERATOR                |NAME                   |EST. ROWS|COST|
--------------------------------------------------------------------
|0 |PX COORDINATOR          |                       |3        |477 |
|1 | EXCHANGE OUT DISTR     |:EX10000               |3        |405 |
|2 |  SUBPLAN SCAN          |V_TT01                 |3        |405 |
|3 |   PX PARTITION ITERATOR|                       |3        |405 |
|4 |    UNION ALL           |                       |3        |405 |
|5 |     NESTED-LOOP JOIN   |                       |2        |273 |
|6 |      MERGE ANTI JOIN   |                       |2        |183 |
|7 |       TABLE SCAN       |TT01(INDX_TT01_COL001) |2        |137 |
|8 |       SUBPLAN SCAN     |VIEW1                  |1        |46  |
|9 |        TABLE SCAN      |TBL3(INDEX_TBL3_COL170)|1        |46  |
|10|      TABLE SCAN        |TBL1(INDEX_TBL1_COL001)|1        |44  |
|11|     NESTED-LOOP JOIN   |                       |1        |132 |
|12|      TABLE SCAN        |TBL3(INDEX_TBL3_COL170)|1        |92  |
|13|      TABLE GET         |TBL2                   |1        |40  |
====================================================================
```

**关键改进**：

- `PX PARTITION ITERATOR` 表明只在分区内执行 `UNION ALL`。
- 索引 `TBL3.INDEX_TBL3_COL170` 有效匹配，避免全表扫描，`TBL3` 上索引的代价非常低，性能得到了很大的提升。。

## 相关文档

如果您想要了解本篇文档中提到的视图，请参见相应的视图文档：

- [GV$OB_SQL_AUDIT (sys 租户)](../../../700.reference/700.system-views/300.system-view-of-sys-tenant/300.performance-view-of-sys-tenant/3500.gv-ob_sql_audit-of-sys-tenant.md)
- [GV$OB_SQL_AUDIT（MySQL 模式)](../../../700.reference/700.system-views/400.system-view-of-mysql-mode/300.performance-view-of-mysql-mode/3500.gv-ob_sql_audit-of-mysql-mode.md)
- [GV$OB_SQL_AUDIT（Oracle 模式)](../../../700.reference/700.system-views/500.system-view-of-oracle-mode/300.performance-view-of-oracle-mode/3400.gv-ob_sql_audit-of-oracle-mode.md)
