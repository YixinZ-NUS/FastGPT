# 并行执行入门实践指南

并行执行是提升 SQL 性能的关键技术，但因其复杂性，初学者需逐步掌握其核心机制。本文为 OceanBase 数据库 V3.1 及以上版本提供入门指南，帮助用户快速上手并行执行功能。尽管参数非最优配置，但能避免常见问题，确保基础功能正常运行。

## 环境配置

### 初始化参数设置

设置 `parallel_servers_target` 参数，控制集群最大可用并行 Worker 数量：

```sql
/* MySQL 租户 */
SET GLOBAL parallel_servers_target = MIN_CPU * 20;

/* Oracle 租户 */
ALTER SYSTEM SET parallel_servers_target = MIN_CPU * 20;
```

**说明**：
- `MIN_CPU` 是集群中单节点 CPU 核数的最小值。
- 该参数确保系统有足够的资源支持并行任务。

### 统计信息采集

统计信息质量直接影响并行计划生成：

- **V3.x 版本**：数据导入后需触发 **合并操作**，自动收集统计信息。所以在导入数据之后，需要发起一轮合并才能保证统计信息的搜集。
- **V4.x 版本**：可直接调用 `DBMS_STATS` 包手动收集统计信息，无需依赖合并操作。

更多关于统计信息，请参考[统计信息概述](../../../../600.manage/900.performance-tuning/400.sql-tuning/200.execution-plan-optimization/100.statistics-and-cost-based-optimization/200.statistic-information/100.statistic-information-overview.md)。


## 并行度（DOP）设置

### 设置原则

- **DOP 上限**：不超过物理 CPU 核数的 **1.5 倍**。
- **单 SQL 推荐值**：若无并发需求，可直接设为 CPU 核数（如 32 核，Hint 就设置为 `/*+ PARALLEL(32) */`）。

### 添加并行 Hint

```sql
/*+ PARALLEL(32) */
```

## 性能调优步骤

### 监控 CPU 利用率

通过以下命令检查租户 CPU 使用情况：

```bash
top -H
```

### 分析 SQL 执行性能

对慢 SQL 添加 `/*+ MONITOR */` Hint，执行后通过 `sql_plan_monitor` 视图获取性能报告：

#### 汇总视图（按租户类型）

**MySQL 租户**：

```sql
SELECT op_id, op, rows, rescan, threads,
       (close_time - open_time) AS open_dt,
       (last_row_eof_time - first_row_time) AS row_dt,
       open_time, close_time, first_row_time, last_row_eof_time
FROM (
  SELECT plan_line_id AS op_id,
         CONCAT(LPAD('', plan_depth, ' '), plan_operation) AS op,
         SUM(output_rows) AS rows,
         SUM(STARTS) AS rescan,
         MIN(first_refresh_time) AS open_time,
         MAX(last_refresh_time) AS close_time,
         MIN(first_change_time) AS first_row_time,
         MAX(last_change_time) AS last_row_eof_time,
         COUNT(1) AS threads
  FROM oceanbase.gv$sql_plan_monitor
  WHERE trace_id = 'Yxxxxxxxxx'
  GROUP BY plan_line_id, plan_operation, plan_depth
  ORDER BY plan_line_id
) a;
```

**Oracle 租户**：

```sql
SELECT op_id, op, output_rows, rescan, threads,
       (close_time - open_time) AS open_dt,
       (last_row_eof_time - first_row_time) AS row_dt,
       open_time, close_time, first_row_time, last_row_eof_time
FROM (
  SELECT plan_line_id AS op_id,
         CONCAT(LPAD(' ', plan_depth, ' '), plan_operation) AS op,
         SUM(output_rows) AS output_rows,
         SUM(STARTS) AS rescan,
         MIN(first_refresh_time) AS open_time,
         MAX(last_refresh_time) AS close_time,
         MIN(first_change_time) AS first_row_time,
         MAX(last_change_time) AS last_row_eof_time,
         COUNT(1) AS threads
  FROM sys.gv$sql_plan_monitor
  WHERE trace_id = 'Yxxxxxxxxx'
  GROUP BY plan_line_id, plan_operation, plan_depth
  ORDER BY plan_line_id
) a;
```

#### 明细视图（线程级分析）

**MySQL 租户**：
```sql
SELECT op_id, thread, op, rows, rescan,
       (close_time - open_time) AS open_dt,
       (last_row_eof_time - first_row_time) AS row_dt,
       open_time, close_time, first_row_time, last_row_eof_time
FROM (
  SELECT plan_line_id AS op_id,
         PROCESS_NAME AS thread,
         CONCAT(LPAD('', plan_depth, ' '), plan_operation) AS op,
         output_rows AS rows,
         STARTS AS rescan,
         first_refresh_time AS open_time,
         last_refresh_time AS close_time,
         first_change_time AS first_row_time,
         last_change_time AS last_row_eof_time
  FROM oceanbase.gv$sql_plan_monitor
  WHERE trace_id = 'Yxxxxxxxxx'
  ORDER BY plan_line_id, PROCESS_NAME
) a;
```

**Oracle 租户**：

```sql
SELECT op_id, thread, op, output_rows, rescan,
       (close_time - open_time) AS open_dt,
       (last_row_eof_time - first_row_time) AS row_dt,
       open_time, close_time, first_row_time, last_row_eof_time
FROM (
  SELECT plan_line_id AS op_id,
         PROCESS_NAME AS thread,
         CONCAT(LPAD(' ', plan_depth, ' '), plan_operation) AS op,
         output_rows,
         STARTS AS rescan,
         first_refresh_time AS open_time,
         last_refresh_time AS close_time,
         first_change_time AS first_row_time,
         last_change_time AS last_row_eof_time
  FROM sys.gv$sql_plan_monitor
  WHERE trace_id = 'Yxxxxxxxxx'
  ORDER BY plan_line_id, process_name
) a;
```

## 常见问题与解决方案

### CPU 利用率不足，查询性能未达预期？

- **排查步骤**：
  1. 执行 `SHOW VARIABLES LIKE 'parallel_servers_target';`（MySQL）或 `SHOW PARAMETER parallel_servers_target;`（Oracle）。
  2. 若参数值小于 `MIN_CPU * 20`，调整参数：

     ```sql
     /* MySQL */ SET GLOBAL parallel_servers_target = MIN_CPU * 20;
     /* Oracle */ ALTER SYSTEM SET parallel_servers_target = MIN_CPU * 20;
     ```

### PDML（并行 DML）未生效或性能不佳？

- **验证方法**：
  1. 使用 `EXPLAIN EXTENDED` 验证是否生成 PDML 计划。
  2. 若计划中出现 `DISTRIBUTED INSERT/UPDATE/DELETE`，则 PDML 未生效。
- **常见原因**：
  - 表包含触发器、外键、本地唯一索引等限制。
  - 请移除或调整这些约束以启用 PDML。

### PDML 执行超时，报错 `-4138 OB_SNAPSHOT_DISCARDED`？

- **原因**：事务保留时间（`undo_retention`）不足。
- **解决方案**：
  - **V4.1 之前版本**：
    ```sql
    ALTER SYSTEM SET undo_retention = <PDML 最大执行时间>;  -- 默认 30 分钟
    ```
  - **V4.1 及以上版本**：无需手动设置，已优化超时逻辑。

### 业务 SQL 无法修改，如何强制开启并行？

- **方案**：通过 **OBProxy** 配置全局并行度：
  - 在 OBProxy 的 Web 界面中，设置连接的默认并行度（如全局默认值设为 2）。
  - 此配置对所有通过该连接的 SQL 生效，无需修改 SQL 代码。
