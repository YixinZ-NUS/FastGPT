# 并行查询

并行执行（Parallel Execution）是将一个较大任务切分为多个小任务，通过多线程或进程并行处理，利用更多 CPU 和 IO 资源缩短响应时间。OceanBase 支持以下三类并行执行：

- **并行查询（Parallel Query）**
- [**并行 DDL（Parallel DDL）**](1000.parallel-dml.md)
- [**并行 DML（Parallel DML）** ](1100.parallel-ddl.md)

本篇文章介绍 **并行查询（Parallel Query）**。

启动并行查询的方式有以下两种：

* 通过 `PARALLEL` Hint 指定并行度（DOP）的方式启动并行查询。

* 针对查询分区数大于 1 的分区表会自动启动并行查询。

## 启用分区表并行查询

OceanBase 对分区表的并行查询规则如下：

### 自动并行规则

当查询的 **目标分区数 > 1** 时，系统会自动启用并行查询，默认 `DOP（并行度）` 为 `1`。

#### 示例：全表扫描的默认并行

如下例所示，创建一个分区表 ptable：

```sql
CREATE TABLE ptable(c1 INT, c2 INT) PARTITION BY HASH(c1) PARTITIONS 16;
```

对 ptable 进行全表数据的扫描操作，通过 EXPLAIN 命令查看生成的执行计划：

```sql
EXPLAIN SELECT * FROM ptable;
```

**执行计划输出**：

```shell
Query Plan:
=======================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST   |
-------------------------------------------------------
|0 |EXCHANGE IN DISTR      |        |1600000  |1246946|
|1 | EXCHANGE OUT DISTR    |:EX10000|1600000  |1095490|
|2 |  PX PARTITION ITERATOR|        |1600000  |1095490|
|3 |   TABLE SCAN          |ptable  |1600000  |1095490|
=======================================================

Outputs & filters:
-------------------------------------
  0 - output([ptable.c1], [ptable.c2]), filter(nil)
  1 - output([ptable.c1], [ptable.c2]), filter(nil), dop=1
  2 - output([ptable.c1], [ptable.c2]), filter(nil)
  3 - output([ptable.c1], [ptable.c2]), filter(nil),
      access([ptable.c1], [ptable.c2]), partitions(p[0-15])
```

**示例分析**：

- 默认 `DOP=1`，即使分区数为 16。
- 若 OceanBase 集群有 3 个 OBServer 节点，每个节点启动 **1 个工作线程（Worker Thread）**，总线程数为 3。

### 通过 Hint 指定分区表并行度

通过 `PARALLEL` Hint 可强制指定 `DOP`，覆盖默认值。

#### 示例：显式设置 DOP=8

针对上文中的分区表 `ptable`，添加 `PARALLEL` Hint 启动并行查询，并指定 dop 值，通过 `EXPLAIN` 命令查看生成的执行计划。

```shell
obclient> EXPLAIN SELECT /*+ PARALLEL(8) */ * FROM ptable;
```

**执行计划输出**：

```shell
Query Plan:
=======================================================
|ID|OPERATOR               |NAME    |EST. ROWS|COST   |
-------------------------------------------------------
|0 |EXCHANGE IN DISTR      |        |1600000  |1246946|
|1 | EXCHANGE OUT DISTR    |:EX10000|1600000  |1095490|
|2 |  PX PARTITION ITERATOR|        |1600000  |1095490|
|3 |   TABLE SCAN          |ptable  |1600000  |1095490|
=======================================================

Outputs & filters:
-------------------------------------
  0 - output([ptable.c1], [ptable.c2]), filter(nil)
  1 - output([ptable.c1], [ptable.c2]), filter(nil), dop=8
  2 - output([ptable.c1], [ptable.c2]), filter(nil)
  3 - output([ptable.c1], [ptable.c2]), filter(nil),
      access([ptable.c1], [ptable.c2]), partitions(p[0-15])
```

**工作线程分配规则**：

- **查询分区所在的 OBServer 节点 ≤ DOP**：那么工作线程（总个数等于 dop 值）会按照一定的策略分配到涉及的 OBServer 节点上。
  + 例如，当 dop=8，如果 16 个分区均匀的分布在 4 台 OBServer 节点上，那么每一个 OBServer 节点上都会启动 2 个工作线程来扫描其对应的分区（一共启动 8 个工作线程）

- **查询分区所在的 OBServer 节点 > DOP**：每一个 OBServer 都会至少启动一个工作线程，一共需要启动的工作线程的数目会大于 dop 值。
  + 如果 16 个分区分布在 16 台 OBServer 节点上（每一个节点一个分区），那么每一台 OBServer 节点上都会启动 1 个工作线程来扫描其对应的分区（一共启动 16 个工作线程）。

### 分区表单分区查询的强制并行

即使查询的目标分区数为 1（如通过 `WHERE` 条件过滤），仍可通过 `PARALLEL` Hint 启用分区内并行（需 `DOP ≥2`）。

#### 示例：单分区强制并行

```sql
EXPLAIN SELECT /*+ PARALLEL(8) */ * FROM ptable WHERE c1 = 1;
```
**执行计划输出**：

```shell
Query Plan:
=================================================
|ID|OPERATOR           |NAME    |EST. ROWS|COST |
-------------------------------------------------
|0 |EXCHANGE IN DISTR  |        |990      |85316|
|1 | EXCHANGE OUT DISTR|:EX10000|990      |85222|
|2 |  PX BLOCK ITERATOR|        |990      |85222|
|3 |   TABLE SCAN      |ptable  |990      |85222|
=================================================

Outputs & filters:
-------------------------------------
  0 - output([ptable.c1], [ptable.c2]), filter(nil)
  1 - output([ptable.c1], [ptable.c2]), filter(nil), dop=8
  2 - output([ptable.c1], [ptable.c2]), filter(nil)
  3 - output([ptable.c1], [ptable.c2]), filter([ptable.c1 = 1]),
      access([ptable.c1], [ptable.c2]), partitions(p1)
```

**示例分析**：

- `WHERE c1=1` 限制查询到 1 个分区，默认 `DOP=1`，但通过 `PARALLEL(8)` 强制设置 `DOP=8`。
- 此时，系统会为单分区启动 **分区内并行**（需 `DOP ≥2`）。

<main id="notice" type='notice'>
  <h4>注意</h4>
  <ul>
    <li>分区表的 <code>PARALLEL</code> Hint 必须指定 <code>dop ≥2</code> 才能启动分区内并行（即使分区数=1）。</li>
    <li>非分区表因仅有 1 个分区，必须通过 <code>PARALLEL</code> Hint 指定 <code>dop ≥2</code> 才能触发并行。</li>
    <li>若 <code>dop</code> 值为空或 < 2，系统将忽略并行配置。</li>
  </ul>
</main>

## 启用非分区表并行查询

非分区表本质是 **单分区表**，因此：

1. **无法自动并行**：即使通过 `PARALLEL` Hint，若 `DOP <2` 则无效。
2. **强制并行条件**：必须通过 `PARALLEL` Hint 指定 `DOP ≥2`。

#### 示例：非分区表强制并行

创建一个非分区表 `stable`：

```sql
CREATE TABLE stable(c1 INT, c2 INT);
```

对 `stable` 进行全表数据的扫描操作，通过 EXPLAIN 命令查看生成的执行计划：

```sql
EXPLAIN SELECT * FROM stable;
```

**执行计划输出**：

```shell
Query Plan:
======================================
|ID|OPERATOR  |NAME  |EST. ROWS|COST |
--------------------------------------
|0 |TABLE SCAN|stable|100000   |68478|
======================================

Outputs & filters:
-------------------------------------
  0 - output([stable.c1], [stable.c2]), filter(nil),
      access([stable.c1], [stable.c2]), partitions(p0)
```

**示例分析**：非分区表不使用 Hint 的情况下，不会启动并行查询。

添加 `PARALLEL` Hint 启动分区内并行查询，并指定 dop 值（大于等于 2），通过 EXPLAIN 命令查看生成的执行计划。

```sql
EXPLAIN SELECT /*+ PARALLEL(4) */ * FROM stable;
```

**执行计划输出**：

```shell
Query Plan:
=================================================
|ID|OPERATOR           |NAME    |EST. ROWS|COST |
-------------------------------------------------
|0 |EXCHANGE IN DISTR  |        |100000   |77944|
|1 | EXCHANGE OUT DISTR|:EX10000|100000   |68478|
|2 |  PX BLOCK ITERATOR|        |100000   |68478|
|3 |   TABLE SCAN      |stable  |100000   |68478|
=================================================

Outputs & filters:
-------------------------------------
  0 - output([stable.c1], [stable.c2]), filter(nil)
  1 - output([stable.c1], [stable.c2]), filter(nil), dop=4
  2 - output([stable.c1], [stable.c2]), filter(nil)
  3 - output([stable.c1], [stable.c2]), filter(nil),
      access([stable.c1], [stable.c2]), partitions(p0)
```

**示例分析**：

- 默认无 `PARALLEL` Hint 时，`stable` 的 `DOP=1`（非分区表默认不并行）。
- 通过 `PARALLEL(4)` 显式设置后，`DOP=4`，系统启动分区内并行。

## 启用多表并行查询

### 默认行为

多表 `JOIN` 查询的并行度由各表的分区策略独立决定：

- 若所有表的目标分区数 ≤1，则默认不启用并行。
- 若存在分区数 >1 的表，则自动启用并行（默认 `DOP=1`）。

#### 示例：多表默认并行

```sql
-- 首先创建两张分区表 p1table 和 p2table
CREATE TABLE p1table(c1 INT, c2 INT)
          PARTITION BY HASH(c1) PARTITIONS 2;
CREATE TABLE p2table(c1 INT, c2 INT)
          PARTITION BY HASH(c1) PARTITIONS 4;
```

完成建表，使用 `EXPLAIN` 查询 `p1table` 与 `p2table` 的 JOIN 结果，JOIN 条件是 `p1table.c1=p2table.c2`：

```sql
EXPLAIN SELECT * FROM p1table p1 JOIN p2table p2 ON p1.c1=p2.c2;
```

**执行计划输出**：

```shell
Query Plan:
====================================================================
|ID|OPERATOR                          |NAME    |EST. ROWS|COST     |
--------------------------------------------------------------------
|0 |EXCHANGE IN DISTR                 |        |784080000|614282633|
|1 | EXCHANGE OUT DISTR               |:EX10001|784080000|465840503|
|2 |  HASH JOIN                       |        |784080000|465840503|
|3 |   EXCHANGE IN DISTR              |        |200000   |155887   |
|4 |    EXCHANGE OUT DISTR (BROADCAST)|:EX10000|200000   |136955   |
|5 |     PX PARTITION ITERATOR        |        |200000   |136955   |
|6 |      TABLE SCAN                  |p1      |200000   |136955   |
|7 |   PX PARTITION ITERATOR          |        |400000   |273873   |
|8 |    TABLE SCAN                    |p2      |400000   |273873   |
====================================================================

Outputs & filters:
-------------------------------------
  0 - output([p1.c1], [p1.c2], [p2.c1], [p2.c2]), filter(nil)
  1 - output([p1.c1], [p1.c2], [p2.c1], [p2.c2]), filter(nil), dop=1
  2 - output([p1.c1], [p1.c2], [p2.c1], [p2.c2]), filter(nil),
      equal_conds([p1.c1 = p2.c2]), other_conds(nil)
  3 - output([p1.c1], [p1.c2]), filter(nil)
  4 - output([p1.c1], [p1.c2]), filter(nil), dop=1
  5 - output([p1.c1], [p1.c2]), filter(nil)
  6 - output([p1.c1], [p1.c2]), filter(nil),
      access([p1.c1], [p1.c2]), partitions(p[0-1])
  7 - output([p2.c1], [p2.c2]), filter(nil)
  8 - output([p2.c1], [p2.c2]), filter(nil),
      access([p2.c1], [p2.c2]), partitions(p[0-3])
```

**示例分析**：

- `p1table`（2 分区）和 `p2table`（4 分区）默认 `DOP=1`，因此总 `DOP=1`。


### 显式设置多表并行度

通过 `PARALLEL` Hint 可为多表 `JOIN` 指定全局 `DOP`。

#### 示例：全局 DOP=8

```shell
obclient> EXPLAIN SELECT /*+ PARALLEL(8) */ *
          FROM p1table p1 JOIN p2table p2 ON p1.c1=p2.c2;
```

此时 `p1table` 和 `p2table` 的并行度均按 `DOP=8` 执行。


### 特殊场景：分区过滤后的并行

当查询条件限制某表的目标分区数 ≤1 时：

- 该表默认不并行，但可通过 `PARALLEL` Hint 强制启用分区内并行（需 `DOP ≥2`）。

#### 示例：部分分区过滤

```sql
EXPLAIN SELECT /*+ PARALLEL(8) */ *  FROM p1table p1 JOIN p2table p2 ON p1.c1=p2.c2 AND p2.c1=1;
```

**执行计划输出**：

```shell
Query Plan:
=============================================================
|ID|OPERATOR                     |NAME    |EST. ROWS|COST   |
-------------------------------------------------------------
|0 |EXCHANGE IN DISTR            |        |1940598  |1807515|
|1 | EXCHANGE OUT DISTR          |:EX10001|1940598  |1440121|
|...|...|...|...|
=============================================================

Outputs & filters:
-------------------------------------
  1 - dop=8
```

**示例分析**：

- `p2table` 因 `WHERE c1=1` 仅扫描 1 分区，默认 `DOP=1`。
- 通过 `PARALLEL(8)` Hint 强制设置全局 `DOP=8`，覆盖默认值。

## 并行执行监控

OceanBase 提供系统视图 `(G)V$OB_SQL_AUDIT` 查看并行执行的运行状态以及一些统计信息。关键字段包括：

- `qc_id`：并行执行场景下，调度器 ID
- `dfo_id`：并行执行场景下，当前执行的子计划 ID
- `sqc_id`：并行执行场景下，本地协调器 ID
- `worker_id`：并行执行场景下，工作线程 ID

详细说明请参考：[`(G)V$OB_SQL_AUDIT`](../../../700.system-views/400.system-view-of-mysql-mode/300.performance-view-of-mysql-mode/3500.gv-ob_sql_audit-of-mysql-mode.md)
