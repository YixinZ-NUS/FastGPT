# 診断の実行：DBMS_XPLANシステムパッケージを使用してパフォーマンス診断を行います

DBMS_XPLANシステムパッケージは、ロジックプラン管理に関連する機能を提供し、ロジックプラン最適化追跡などを含みます。

## システムパッケージの紹介

### display_cursor

#### 機能紹介

OceanBaseデータベースは、ユーザーが実行したすべてのクエリの計画（物理計画および論理計画を含む）を保存し、後のトラブルシューティングで利用できるようにします。履歴クエリ計画の解読を容易にするため、OceanBaseデータベースは計画を整形する関連DBMSパッケージを提供しています。`EXPLAIN`によって生成される論理実行計画とは異なり、ユーザーが実際に実行したクエリ計画はデータベース内に保持され続け、ユーザーが接続を切断しても即座に無効になることはありません。デフォルトでは、これらの実行計画は以下の条件を満たした場合に削除されます：

* メモリ圧迫による削除：実行計画の保存量が増加すると、システムは古い計画の削除をトリガーします。
* 手動削除：ユーザーは`ALTER SYSTEM FLUSH PLAN CACHE`コマンドを使用して、手動でキャッシュをクリアできます。
* クラスタ再起動：プランキャッシュはクラスタの再起動時に完全にリセットされます。

#### 関連パッケージ関数の説明

```sql
-- display sql plan table`s plan
function display_cursor(plan_id      integer default 0,             -- default value: last plan
                        format		 varchar2 default 'TYPICAL',
                        svr_ip       varchar2 default null,         -- default value: server connected by client
                        svr_port     integer default 0,             -- default value: server connected by client
                        tenant_id	 integer default 0              -- default value: current tenant
                        )
return dbms_xplan_type_table;
```

パラメータの説明：

- plan_id：プランIDは、指定しない場合、前回のプランが表示されます。
- format：プランフォーマットは上記と同様になります。
- svr_ip、svr_port：プランが配置されているノードのIPアドレス、デフォルトでは、sessionが接続されているノードのIPアドレスです。
- tenant_id：プランが所属するテナントID、デフォルトではsessionが目下接続されているテナントになります。

#### 関連データディクショナリの解説

プラン情報はデータディクショナリ __all_virtual_sql_planに格納され、各テナントにも対応するシステムビューgv$ob_sql_plan (現在のテナントのすべてのマシンのプラン)とv$ob_sql_plan (現在のテナントの現在のマシンのプラン)があります。

```sql
+--------------------+---------------------+------+-----+---------+-------+
| Field              | Type                | Null | Key | Default | Extra |
+--------------------+---------------------+------+-----+---------+-------+
| tenant_id          | bigint(20)          | NO   | PRI | NULL    |       |
| plan_id            | bigint(20)          | NO   | PRI | NULL    |       |
| svr_ip             | varchar(46)         | NO   | PRI | NULL    |       |
| svr_port           | bigint(20)          | NO   | PRI | NULL    |       |
| sql_id             | varchar(32)         | NO   |     | NULL    |       |
| db_id              | bigint(20)          | NO   |     | NULL    |       |
| plan_hash          | bigint(20) unsigned | NO   |     | NULL    |       |
| gmt_create         | timestamp(6)        | NO   |     | NULL    |       |
| operator           | varchar(255)        | NO   |     | NULL    |       |
| options            | varchar(255)        | NO   |     | NULL    |       |
| object_node        | varchar(40)         | NO   |     | NULL    |       |
| object_id          | bigint(20)          | NO   |     | NULL    |       |
| object_owner       | varchar(128)        | NO   |     | NULL    |       |
| object_name        | varchar(128)        | NO   |     | NULL    |       |
| object_alias       | varchar(261)        | NO   |     | NULL    |       |
| object_type        | varchar(20)         | NO   |     | NULL    |       |
| optimizer          | varchar(4000)       | NO   |     | NULL    |       |
| id                 | bigint(20)          | NO   |     | NULL    |       |
| parent_id          | bigint(20)          | NO   |     | NULL    |       |
| depth              | bigint(20)          | NO   |     | NULL    |       |
| position           | bigint(20)          | NO   |     | NULL    |       |
| search_columns     | bigint(20)          | NO   |     | NULL    |       |
| is_last_child      | bigint(20)          | NO   |     | NULL    |       |
| cost               | bigint(20)          | NO   |     | NULL    |       |
| real_cost          | bigint(20)          | NO   |     | NULL    |       |
| cardinality        | bigint(20)          | NO   |     | NULL    |       |
| real_cardinality   | bigint(20)          | NO   |     | NULL    |       |
| bytes              | bigint(20)          | NO   |     | NULL    |       |
| rowset             | bigint(20)          | NO   |     | NULL    |       |
| other_tag          | varchar(4000)       | NO   |     | NULL    |       |
| partition_start    | varchar(4000)       | NO   |     | NULL    |       |
| partition_stop     | varchar(4000)       | NO   |     | NULL    |       |
| partition_id       | bigint(20)          | NO   |     | NULL    |       |
| other              | varchar(4000)       | NO   |     | NULL    |       |
| distribution       | varchar(64)         | NO   |     | NULL    |       |
| cpu_cost           | bigint(20)          | NO   |     | NULL    |       |
| io_cost            | bigint(20)          | NO   |     | NULL    |       |
| temp_space         | bigint(20)          | NO   |     | NULL    |       |
| access_predicates  | varchar(4000)       | NO   |     | NULL    |       |
| filter_predicates  | varchar(4000)       | NO   |     | NULL    |       |
| startup_predicates | varchar(4000)       | NO   |     | NULL    |       |
| projection         | varchar(4000)       | NO   |     | NULL    |       |
| special_predicates | varchar(4000)       | NO   |     | NULL    |       |
| time               | bigint(20)          | NO   |     | NULL    |       |
| qblock_name        | varchar(128)        | NO   |     | NULL    |       |
| remarks            | varchar(4000)       | NO   |     | NULL    |       |
| other_xml          | varchar(4000)       | NO   |     | NULL    |       |
+--------------------+---------------------+------+-----+---------+-------+
```

### display_active_session_plan

#### 機能紹介

典型的な適用シナリオ：ユーザーが大きなSQLを実行しているとき、現在の接続が長時間実行され、ユーザーはクエリの実行状況(実行プラン、実行プロセスなど)を知りたいと考えています。このような状況では、現在のsessionが大きなSQLによって占有されているため、新しい接続を開く必要があります。show full processlistコマンドを使用して、大きなSQLが存在するsessionを見つけ、session_idとdisplay_active_session_planを使用して、大きなSQLの実行の詳細を表示します。

#### 関連パッケージ関数の説明

```sql
-- disable real time plan
function display_active_session_plan(
           session_id   integer default 0,
           format       varchar2  default  'TYPICAL',
           svr_ip       varchar2 default null,      -- default value: server connected by client
           svr_port     integer default 0           -- default value: server connected by client
           )
return dbms_xplan_type_table;
```

- session_id：ユーザーが接続しているsession idは、proxy session idではなく、serverのsession idであることに注意してください。
- format：プランフォーマットは上記と同様です。
- svr_ip、svr_port：sessionが存在するノードのIPアドレス。デフォルトは、現在のsessionが接続しているノードのIPアドレスです。

### enable_opt_trace

#### 機能紹介

オプティマイザーがプランを生成するプロセスは非常に複雑であり、最適化が不十分なプランの問題を調査するには、関連情報を収集するために多くの時間を費やす必要があります。本機能は、オプティマイザーのフルリンク追跡メカニズムを設計しており、オプティマイザーがプランを生成するために必要な完全な情報を一度に収集することができ、生成された部分最適化プランの問題を分析しやすくなります。この機能には、以下の追跡情報が含まれています：

- **env：**
   - システム情報、session情報
   - ユーザーSQL
   - オプティマイザー関連の変数情報
- **transformer：**
   - 各リライトルールは、リライト前後のSQLをレポートする
   - 各リライトルールがリライトを実行したか、または実行しなかった詳細な理由(ヒントによる制御か、あるいは何らかの条件が満たされなかったか)
- **optimizer：**
   - 使用される統計情報
   - 基底パス生成ログ(プロセス条件、行数、コスト見積情報、skyline剪定ルールプロセスを含む)
   - join orderの列挙の詳細なプロセス
   - top演算子の分散と最適化プロセス

#### 関連パッケージ関数の説明

**DBMS_XPLAN.ENABLE_OPT_TRACE**

```sql
DEFAULT_INENTIFIER  constant VARCHAR2(20) := '';
DEFAULT_LEVEL       constant INT := 1;
PROCEDURE enable_opt_trace(
    sql_id          IN VARCHAR2 DEFAULT '',
    identifier      IN VARCHAR2 DEFAULT DEFAULT_INENTIFIER,
    level           IN INT DEFAULT DEFAULT_LEVEL
);
```

DBMS_XPLAN.ENABLE_OPT_TRACE関数は、オプティマイザーのフルリンク追跡を有効にするために使用されます。有効にすると、現在のsessionの各プラン生成プロセスが追跡されます。

パラメータ紹介：

- sql_idは、追跡が必要なSQLをマークするために使用されます。例えば、現在のテストでPLプログラムを実行する必要があり、PL関数内の特定のSQLのみを追跡したい場合は、sql_idを設定してマークすることができます。sql_idを設定すると、特定のSQLのみが追跡されます。設定しない場合は、すべてのSQLが追跡されます。
- levelは、追跡のレベルを設定するために使用されます。
   - 0: デフォルトの動作です。
   - 1: 各モジュールの使用メモリと時間を追加で出力します。
   - 2: リライトが行われたかどうかにかかわらず、各リライトられたquery blockに対応するSQLを追加で出力します。

  <main id="notice" type='notice'>
    <h4>注意</h4>
    <p>levelはデータベースのキーワードであり、Oracleテナントでは二重引用符で囲み、MySQLテナントではバッククォート ` で囲む必要があります。</p>
  </main>
- identifierは、traceファイルのサフィックスをマークするために使用され、ユーザーが自分のtraceファイルを見つけるのに役立ちます。

**DBMS_XPLAN.DISABLE_OPT_TRACE**

```sql
PROCEDURE disable_opt_trace;
```

DBMS_XPLAN.DISABLE_OPT_TRACEは、現在のsessionにおけるオプティマイザーのフルリンク追跡機能を無効にするために使用します。

**DBMS_XPLAN.SET_OPT_TRACE_PARAMETER**

```sql
PROCEDURE set_opt_trace_parameter(
    sql_id          IN VARCHAR2 DEFAULT '',
    identifier      IN VARCHAR2 DEFAULT DEFAULT_INENTIFIER,
    level           IN INT DEFAULT DEFAULT_LEVEL
);
```

DBMS_XPLAN.SET_OPT_TRACE_PARAMETERは、現在のsessionのオプティマイザーのフルリンク追跡のパラメータを変更するために使用されます。

## 典型的なシナリオ診断

### クエリは実行を完了できますが、実行速度が遅いです

**クエリ実行の詳細情報の収集：**

:::tab
tab Oracleテナント使用例
  1. Proxyはセッションを「維持」します。

      ```sql
      SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
      ```

  2. クエリを実行します。

      ```sql
      select * from t1;
      ```

  3. DBMS_XPLANパッケージを使用して、前回のプランを確認します。

      ```sql
      select * from table(dbms_xplan.display_cursor(format=>'all'));

      +--------------------------------------------------------------------------------------------------+
      | COLUMN_VALUE                                                                                     |
      +--------------------------------------------------------------------------------------------------+
      | ================================================================================================ |
      | |ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|REAL.ROWS|REAL.TIME(us)|IO TIME(us)|CPU TIME(us)| |
      | ------------------------------------------------------------------------------------------------ |
      | |0 |TABLE FULL SCAN|T1  |1       |2           |0        |0            |0          |0           | |
      | ================================================================================================ |
      | Outputs & filters:                                                                               |
      | -------------------------------------                                                            |
      |   0 - output([T1.C1]), filter(nil), rowset=256                                                   |
      |       access([T1.C1]), partitions(p0)                                                            |
      |       is_index_back=false, is_global_index=false,                                                |
      |       range_key([T1.__pk_increment]), range(MIN ; MAX)always true                                |
      +--------------------------------------------------------------------------------------------------+
      ```
tab MySQLテナント使用例
  1. Proxyはセッションを「維持」します。

      ```sql
      SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
      ```

  2. クエリを実行します。

      ```sql
      select * from t1;
      ```

  3. DBMS_XPLANパッケージとsql_auditを組み合わせて、前回のプランを確認します。

      ```sql
      select dbms_xplan.display_cursor(0, 'all');

      +--------------------------------------------------------------------------------------------------+
      | COLUMN_VALUE                                                                                     |
      +--------------------------------------------------------------------------------------------------+
      | ================================================================================================ |
      | |ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|REAL.ROWS|REAL.TIME(us)|IO TIME(us)|CPU TIME(us)| |
      | ------------------------------------------------------------------------------------------------ |
      | |0 |TABLE FULL SCAN|T1  |1       |2           |0        |0            |0          |0           | |
      | ================================================================================================ |
      | Outputs & filters:                                                                               |
      | -------------------------------------                                                            |
      |   0 - output([T1.C1]), filter(nil), rowset=256                                                   |
      |       access([T1.C1]), partitions(p0)                                                            |
      |       is_index_back=false, is_global_index=false,                                                |
      |       range_key([T1.__pk_increment]), range(MIN ; MAX)always true                                |
      +--------------------------------------------------------------------------------------------------+
      ```
:::

### クエリの実行が遅く、長時間完了しません

**プラン実行の詳細情報を収集する：**

:::tab
tab Oracleテナント使用例
  1. Aに接続して遅いSQLを実行します。

      ```sql
      select count(*) from table(generator(100000)) A, table(generator(10000))B;
      ```

  2. システムテナントにログインし、`__all_virtual_processlist` をクエリして、実行中の遅いSQLのsession情報(session_id、svr_ip、svr_port)を特定します。

      ```sql
      select id, svr_ip, svr_ip, svr_port, info from __all_virtual_processlist where info like "%select%"\G

                      id: 3221489189
                  svr_ip: 11.xxx.xxx.xxx
                svr_port: 50000
                    info: select count(*) from table(generator(100000)) A, table(generator(10000))B
      ```

  3. sessionプランの詳細が表示されます。

      ```sql
      select dbms_xplan.display_active_session_plan(3221668463, 'all', '11.xxx.xxx.xxx', 50000);
      +--------------------------------------------------------------------------------------------------------------------+
      | COLUMN_VALUE                                                                                                       |
      +--------------------------------------------------------------------------------------------------------------------+
      | ==============================================================================================================     |
      | |ID|OPERATOR                     |NAME|EST.ROWS|EST.TIME(us)|REAL.ROWS|REAL.TIME(us)|IO TIME(us)|CPU TIME(us)|     |
      | --------------------------------------------------------------------------------------------------------------     |
      | |0 |SCALAR GROUP BY              |    |1       |1794        |0        |0            |0          |0           |     |
      | |1 |└─NESTED-LOOP JOIN CARTESIAN |    |39601   |1076        |0        |0            |0          |0           |     |
      | |2 |  ├─FUNCTION_TABLE           |A   |199     |1           |0        |0            |0          |0           |     |
      | |3 |  └─MATERIAL                 |    |199     |80          |0        |0            |0          |0           |     |
      | |4 |    └─FUNCTION_TABLE         |B   |199     |1           |0        |0            |0          |0           |     |
      | ==============================================================================================================     |
      | Outputs & filters:                                                                                                 |
      | -------------------------------------                                                                              |
      |   0 - output([T_FUN_COUNT(*)]), filter(nil), rowset=256                                                            |
      |       group(nil), agg_func([T_FUN_COUNT(*)])                                                                       |
      |   1 - output(nil), filter(nil), rowset=256                                                                         |
      |       conds(nil), nl_params_(nil), use_batch=false                                                                 |
      |   2 - output(nil), filter(nil)                                                                                     |
      |       value(GENERATOR(cast(:0, BIGINT(-1, 0))))                                                                    |
      |   3 - output(nil), filter(nil), rowset=256                                                                         |
      |   4 - output(nil), filter(nil)                                                                                     |
      |       value(GENERATOR(cast(:1, BIGINT(-1, 0))))                                                                    |
      +--------------------------------------------------------------------------------------------------------------------+
      ```
tab MySQLテナント使用例
  1. Aに接続して遅いSQLを実行します。

      ```sql
      select count(*) from table(generator(100000)) A, table(generator(10000))B;
      ```

  2. システムテナントにログインし、`__all_virtual_processlist` をクエリして、実行中の遅いSQLのsession情報(session_id、svr_ip、svr_port)を特定します。

      ```sql
      select id, svr_ip, svr_ip, svr_port, info from __all_virtual_processlist where info like "%select%"\G

                      id: 3221489189
                  svr_ip: 11.xxx.xxx.xxx
                svr_port: 50000
                    info: select count(*) from table(generator(100000)) A, table(generator(10000))B
      ```

  3. sessionプランの詳細が表示されます。

      ```sql
      select dbms_xplan.display_active_session_plan(3221668463, 'all', '11.xxx.xxx.xxx', 50000);
      +--------------------------------------------------------------------------------------------------------------------+
      | COLUMN_VALUE                                                                                                       |
      +--------------------------------------------------------------------------------------------------------------------+
      | ==============================================================================================================     |
      | |ID|OPERATOR                     |NAME|EST.ROWS|EST.TIME(us)|REAL.ROWS|REAL.TIME(us)|IO TIME(us)|CPU TIME(us)|     |
      | --------------------------------------------------------------------------------------------------------------     |
      | |0 |SCALAR GROUP BY              |    |1       |1794        |0        |0            |0          |0           |     |
      | |1 |└─NESTED-LOOP JOIN CARTESIAN |    |39601   |1076        |0        |0            |0          |0           |     |
      | |2 |  ├─FUNCTION_TABLE           |A   |199     |1           |0        |0            |0          |0           |     |
      | |3 |  └─MATERIAL                 |    |199     |80          |0        |0            |0          |0           |     |
      | |4 |    └─FUNCTION_TABLE         |B   |199     |1           |0        |0            |0          |0           |     |
      | ==============================================================================================================     |
      | Outputs & filters:                                                                                                 |
      | -------------------------------------                                                                              |
      |   0 - output([T_FUN_COUNT(*)]), filter(nil), rowset=256                                                            |
      |       group(nil), agg_func([T_FUN_COUNT(*)])                                                                       |
      |   1 - output(nil), filter(nil), rowset=256                                                                         |
      |       conds(nil), nl_params_(nil), use_batch=false                                                                 |
      |   2 - output(nil), filter(nil)                                                                                     |
      |       value(GENERATOR(cast(:0, BIGINT(-1, 0))))                                                                    |
      |   3 - output(nil), filter(nil), rowset=256                                                                         |
      |   4 - output(nil), filter(nil)                                                                                     |
      |       value(GENERATOR(cast(:1, BIGINT(-1, 0))))                                                                    |
      +--------------------------------------------------------------------------------------------------------------------+
      ```
:::

### プラン生成時間が長すぎるか、プラン生成中にメモリ不足が発生し、意図しないプランが生成されました

**クエリ最適化情報の収集：**

:::tab
tab Oracleテナント使用例
  1. Proxyはセッションを「維持」します。

      ```sql
      SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
      ```

  2. 現在のsessionのオプティマイザー追跡機能を有効にします。

      ```sql
      call dbms_xplan.enable_opt_trace();
      ```

  3. 追跡ログのlevelとログファイルのサフィックスを設定します。

      ```sql
      call dbms_xplan.set_opt_trace_parameter(identifier=>'trace_test', "level"=>3);
      ```

  4. クエリプラン。

      ```sql
      explain select * from t1;
      ```

  5. `observer` ログディレクトリの下で、`trace_test` をサフィックスとする追跡ログを確認します。

      ```shell
      vi /home/admin/oceanbase/log/optimizer_trace_BkkGn1_trace_test.trac
      ```

  6. 現在のsessionのオプティマイザー追跡機能を無効にします。

      ```shell
      call dbms_xplan.disable_opt_trace();
      ```
tab MySQLテナント使用例
  1. Proxyはセッションを「維持」します。

      ```sql
      SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
      ```

  2. 現在のsessionのオプティマイザー追跡機能を有効にします。

      ```sql
      call dbms_xplan.enable_opt_trace();
      ```

  3. 追跡ログのlevelとログファイルのサフィックスを設定します。

      ```
      call dbms_xplan.set_opt_trace_parameter(identifier=>'trace_test', `level`=>3);
      ```

  4. クエリプラン。

      ```
      explain select * from t1;
      ```

  5. `observer` ログディレクトリの下で、`trace_test` をサフィックスとする追跡ログを確認します。

      ```
      vi /home/admin/oceanbase/log/optimizer_trace_BkkGn1_trace_test.trac
      ```

  6. 現在のsessionのオプティマイザー追跡機能を無効にします。

      ```
      call dbms_xplan.disable_opt_trace();
      ```
:::

## 情報の解読

### plan tableのフィールド説明

|**フィールド**|**説明**|
|---|---|
| **OPERATOR** | 演算子名 |
| **NAME** | スキャン対象テーブル名 |
| **EST.ROWS** | オプティマイザーが推定した出力行数 |
| **EST.TIME(us)** | オプティマイザーが推定した演算子の計算完了時間 |
| **REAL.ROWS** | 現在の演算子の実際の出力行数 |
| **REAL.TIME(us)** | 現在の演算子の実際の計算終了時間 |
| **IO TIME(us)** | 現在の演算子の待機時間(マイクロ秒単位)。EXCHANGE IN、EXCHANGE OUT、PX COORD演算子では、この時間はネットワーク待機時間を示します。 |
| **CPU TIME(us)** | 現在の演算子のCPU時間(マイクロ秒単位)。EXCHANGE IN、EXCHANGE OUT、PX COORD演算子では、この時間は実際のネットワークのオーバーヘッドではないため、注目する必要がありません。。 |

### optimizer infoの紹介

```sql
Optimization Info:
-------------------------------------
  t1:
      table_rows:3
      physical_range_rows:1
      logical_range_rows:1
      index_back_rows:0
      output_rows:1
      table_dop:1
      dop_method:Table DOP
      avaiable_index_name:[idx_ct, idx_pc, t1]
      pruned_index_name:[idx_ct, idx_pc]
      stats version:0
      dynamic sampling level:0
      estimation method:[DEFAULT]
  Plan Type:
      DISTRIBUTED
  Note:
      Degree of Parallelisim is 1 because of table property
```

|属性名|説明|
|---|---|
| **table_rows**           | t1テーブルの元の行数                                               |
| **physical_range_rows**   | t1テーブルはインデックス上でスキャンする必要がある物理的な行数                                 |
| **logical_range_rows**   | t1テーブルはインデックス上でスキャンする必要がある論理行数                                 |
| **index_back_rows**       | t1テーブルでリターンする必要がある行数                                             |
| **output_rows**           | t1テーブルがフィルタリングされた後の行数                                         |
| **table_dop**             | t1テーブルがスキャンされる並列度                                               |
| **dop_method**           | テーブルスキャン並列度の決定要因。TableDOP (テーブル定義の並列度)、AutoDop (オプティマイザーがコストに基づいて選択した並列度。auto dop機能を有効にする必要があります)、global parallel (parallelヒントまたはシステム変数で設定された並列度)のいずれかになります |
| **available_index_name** | t1テーブルで使用可能なインデックスのリスト |
| **pruned_index_name**     | 現在のクエリでルールに基づいて削除されたインデックスリスト                                 |
| **stats_version**        | t1テーブル統計情報バージョン番号。数値が0の場合、当該テーブルに統計情報が収集されていないことを示します。プラン生成の正確性を確保するため、当該テーブルの統計情報は手動で収集するようにしてください  |
| **dynamic_sampling_level** | 動的サンプリング(オプティマイザーの最適化ツール、詳細については公式ドキュメントを参照)レベル。値が0の場合、このテーブルは動的サンプリングを使用していません |
| **estimation_method**    | t1テーブルの行数推定方法。DEFAULT (デフォルト統計情報を使用。この場合、行数の推定は非常に不正確で、DBAの介入による最適化が必要)、STORAGE (ストレージ層を使用してリアルタイムで行数を推定)、STATS (統計情報を使用して行数を推定)のいずれかです |
| **Plan Type**            | 現在のプランタイプは、LOCAL、REMOTE、DISTRIBUTEDのいずれかです                  |
| **Note**                 | このプランを作成する際の補足情報。例えば：「Degree of Parallelism is 1 because of table property」は、現在のテーブルの並列度が1に設定されているため、現在のクエリの並列度が1に設定されていることを意味します。|

### パフォーマンスが低いプランの原因を迅速に特定する

1. CPU TIMEが高いtopNの演算子を見つけ、EXCHANGE IN、EXCHANGE OUT、PX COORDの演算子を削除します。以下の演算子が含まれている場合：

   - TABLE SCAN：Output & filter情報の中に、テーブルリターンを示すis_index_back=trueがあるかどうか確認してください。もしあれば、optimizer infoのindex_back_rowsに注目してください。行数が多ければ、インデックスの最適化が必要です。もしREAL.ROWSがEST.ROWSよりも大幅に大きい場合、統計情報が収集されているか、または統計情報が古くなっているかどうか(optimizer infoのstats versionフィールドで確認)を検討する必要があります。すべて揃っている場合は、複雑なフィルター条件(例：case when、likeなど)の有無を確認してください。こうした状況の下では、手動でダイナミックアンプリング /*+dynamic_sampling(1)*/ を起動させることで推定の正確度を高めることができます。この演算子がNested Loop Join、SubPlan Filter演算子の右側にある場合、rescanが多過ぎてオーバーヘッドが大きくなっていることを示しています。
   - Nested Loop Join：まず、左側の演算子の行数推定が正しいかどうかを確認します。行数のずれが大きい場合は、統計情報の問題に注目するか、動的サンプリング /*+dynamic_sampling(1)*/ を有効にして行数推定の精度を向上させます。これらの方法が効果的でない場合は、/*+use_hash(xxx)*/ を使用して別のプランにバインドします。行数見積もりが正常でもパフォーマンスが低い場合は、Output & filterの情報に注目し、batch_joinが使用されているかどうかを確認する必要があります。
   - SubPlan Filter：まず、左側の演算子の行数推定が正しいかどうかを確認します。行数のずれが大きい場合は、統計情報の問題に注目するか、動的サンプリング /*+dynamic_sampling(1)*/ を有効にして推定の精度を高めます。行数見積もりが正常でもパフォーマンスが低い場合は、Output & filterの情報に注目し、batchが使用されているかどうかを確認する必要があります。上記の方法がすべて正しい場合、SQL内で対応するサブクエリを見つけ、/*+unnest*/ をリライト最適化できるかどうかを確認する必要があります。

    他の比較的遅い演算子については、行数推定と統計情報のステータスに注目します。統計情報の収集や動的サンプリングを有効にした後も改善が見られない場合は、データ量が多いことが原因です。パラレル実行 /*+parallel(xxx)*/ を有効にする必要があります。INSERT、UPDATE、DELETE、MERGEタイプの演算子については、PDMLを有効にしてさらに /*+parallel(xxx) enable_parallel_dml*/ を最適化する必要があります。

2. HASH DISTINCT、SORT、HASH GROUP BY、HASH JOINなどの演算子にI/O TIMEが見られる場合、これらの演算子はディスクに書き込まれていることを示しています。sql_work_area_sizeパラメータを調整することができます。

### opt_traceログの解釈

このセクションを理解するには、オプティマイザーの基本的な知識が必要です。OceanBaseオプティマイザーの基本的な動作原理、つまり、反復的なクエリ・リライトプロセス、インデックス最適化、結合列挙、分散計画最適化などを理解する必要があります。

opt_traceログは以下の情報を記録します：

**transformer：**

- 各リライトルールは、リライト前後のSQLをレポートする
- 各リライトルールがリライトを実行したか、または実行しなかった詳細な理由(ヒントによる制御か、あるいは何らかの条件が満たされなかったか)

**optimizer：**

- 使用される統計情報
- 基底パス生成ログ(プロセス条件、行数、コスト見積情報、skyline剪定ルールプロセスを含む)
- join orderの列挙の詳細なプロセス
- top演算子の分散と最適化プロセス

同時に、ログは各モジュールが終了した後に時間とメモリオーバーヘッドを記録します：

```
SECTION TIME USAGE: 233135 us
TOTAL TIME USAGE: 233135 us
SECTION MEM USAGE: 48744 KB
TOTAL MEM USAGE: 62961 KB
```

- SECTION TIME USAGEは、前回の最適化ステップの終了から現在の最適化ステップの終了までに使用された時間を表します。
- TOTAL TIME USAGEは、クエリ最適化の開始から現在の最適化ステップの終了までの経過時間を表します。
- SECTION MEM USAGEは、前回の最適化ステップの終了から現在の最適化ステップの終了までに使用されたテナントのメモリ量を表します。
- TOTAL MEM USAGEは、クエリ最適化の開始から現在の最適化ステップの終了までに使用されたテナントメモリを示します。

この情報により、プラン生成に時間がかかり、メモリを消費する最適化手順を迅速に特定できます。また、ヒントを使用して対応する最適化機能を無効にすることで、問題を迅速に解決できます。これにより、プラン生成のオーバーヘッドを削減するために、no_rewriteを使用してリライト全体を無効にする必要がなくなります。

## 関連ドキュメント

* DBMS_XPLANシステムパッケージの詳細については、[DBMS_XPLAN (MySQLモード)](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001975632
)と [DBMS_XPLAN (Oracleモード)](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001975235)を参照してください