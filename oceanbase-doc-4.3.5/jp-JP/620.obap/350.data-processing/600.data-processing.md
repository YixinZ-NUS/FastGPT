# データ加工

データ加工とは、元のデータを特定の分析、アプリケーション、または表示に適したものにするために、一連の処理と変換を行うプロセスです。通常、データクレンジング、データ変換、データ統合、データ集計、データエンリッチメント、データフィルタリング、データアノテーションなどの操作が含まれ、元の乱雑なデータを、構造化された高品質で使いやすいデータセットに変換します。この基盤に基づいて、よりシンプルで、より高パフォーマンスなクエリ分析機能を提供できます。

元のデータの高パフォーマンスな読み込み、豊富な関数、効率的なクエリ分析、データの高パフォーマンスな書き込み能力、そして業務の特徴に合わせたサポート機能は、効率的なデータ加工タスクの実行に不可欠です。

本記事では、OceanBaseがデータ加工に関する業務にどのように貢献できるのか、その特徴に焦点を当てて解説します。

## `INSERT OVERWRITER SELECT` 操作

`INSERT OVERWRITER SELECT` は、クエリ結果をターゲットテーブルに挿入し、同時にターゲットテーブル内の既存データを上書きする操作です。これは主にデータクレンジングと変換のプロセスで使用され、加工後のデータを効率的な方法でデータベースに一括挿入するために利用されます。この操作では原子性が保証されており、実行中に例外が発生した場合、操作全体がロールバックされます。

### 使用シナリオ

+ データを一括でインポートしてターゲットテーブルを上書きする必要がある場合、`INSERT OVERWRITER SELECT` には簡単な方法が用意されています。
+ ターゲットテーブルに既存データがあり、新しいデータで古いデータを置き換えるデータクレンジングに適しています。
+ ソーステーブルは、データベースの内部テーブルでも、外部テーブルでも構いません。

### 構文例

```sql
INSERT [/*+PARALLEL(N)*/] OVERWRITE table_name [(list_of_columns)] [PARTITION (partition_name, ...)] select_stmt;
```

### 注意事項

+ この操作はターゲットテーブルまたはパーティション内のすべてのデータを削除するため、使用する際は慎重に操作する必要があります。誤操作を防ぐために、データのバックアップが完了していることを確認してください。
+ データ挿入の失敗を防ぐため、`SELECT` クエリが返すデータのフォーマットが、ターゲットテーブルの構造と一致していることを確認してください。
+ INSERT INTO SELECTとINSERT OVERWRITE SELECTの違いは、INSERT INTO SELECTがターゲットテーブルまたはパーティションに対して挿入前のデータクリアを行わない点にあります。加工後のデータは、増分的にターゲットテーブルに書き込まれます。
+ `INSERT OVERWRITE SELECT` とリアルタイム書き込み方式(INSERT INTO、REPLACE INTO、DELETE、UPDATE)を同時に使用して同じテーブルにデータを書き込むことは避けてください。そうしないと、リアルタイムで書き込まれたデータは破棄されます。

詳細な操作については、[MySQLモードでINSERT OVERWRITE SELECTステートメントを使用してデータを挿入する](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001971643)と [OracleモードでINSERT OVERWRITE SELECTステートメントを使用してデータを挿入する](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001971682)を参照してください。

## ジョブ送信(`Submit Job`)

OceanBaseデータベースでは、ジョブ送信機能を使用すると、ユーザーは複雑なデータ加工タスクを送信および実行できます。これらのタスクには、データバッチ処理、ETL(抽出、変換、ロード)ジョブ、またはその他のバックグラウンドデータ処理作業を含めることができます。`INSERT INTO` または `INSERT OVERWRITE SELECT` を使用してデータをインポートする場合、同期処理プロセスがデフォルトとなっています。データ量が大きい場合は、セッションを長時間アクティブに維持する必要がある場合があります。そのため、データ量が多い場合には、非同期方式でデータインポートタスクを送信することを推奨します。

### 使用シナリオ

+ データインポート、データクレンジング、レポート生成のバッチ処理など、複雑なデータ処理操作を定期的に実行します。
+ 大規模データの移行または変換タスクのスケジューリング。

### ジョブ送信の例

```sql
-- ジョブを送信
SUBMIT JOB INSERT OVERWRITE test
SELECT ex1.c1,t2.c2,sum(ex1.c3)
FROM ex1,t2
WHERE ex1.id = t2.id
GROUP BY ex1.c1,t2,c2;
-- 非同期タスクの状態をクエリ
SHOW JOB STATUS WHERE job='job_id';
```

ジョブには通常、データの抽出、変換、ロードなどの複数の手順が含まれ、データ処理プロセス全体の実行を自動化できます。

## スケジュールタスク

スケジュールタスクは、設定された時間テーブルに従って指定されたジョブを定期的に実行するために使用されます。スケジュールタスクを使用すると、データ加工プロセスを自動化し、人的なメンテナンスコストを削減できます。

### 使用シナリオ

+ 定期的に、期限切れのデータのクリーンアップ、レポートの生成、データの同期などを実行します。
+ 特定の時間のタスクまたは周期的なタスクにおいて、データ処理ジョブを自動的に実行します。

### スケジュールタスクの作成例

- **MySQLモード**：`Event Scheduler` コマンドを使用して、スケジュールタスクを作成します。

```sql
-- スケジュールタスクを作成
CREATE EVENT myevent
    ON SCHEDULE AT '2024-12-26 00:00:00' + INTERVAL 1 DAY
    DO
      INSERT INTO test SELECT * FROM ex_test WHERE date_key = curdate();

-- スケジュールタスクを確認
SELECT * FROM information_schema.events WHERE event_name='myevent';
```

- **Oracleモード**：`DBMS_SCHEDULER` システムパッケージを使用して、スケジュールタスクを作成します。

```sql
-- スケジュールタスクを作成
BEGIN
    DBMS_SCHEDULER.CREATE_JOB(
        job_name         => 'myscheduler',                      -- ジョブ名
        job_type         => 'STORED_PROCEDURE',                 -- ジョブタイプはストレージプロセス
        job_action       => 'data_cleaning',                    -- ジョブ実行のストレージプロセス
        number_of_argument => 0,                                -- パラメータ不要
        start_date       => SYSDATE,                            -- ジョブの実行開始時間
        repeat_interval  => 'FREQ=DAILY; INTERVAL=1',           -- 毎日1回実行
        end_date         => NULL,                               -- 終了時間は設定せず、ジョブの実行が継続
        job_class        => 'DEFAULT_JOB_CLASS',                -- ジョブタイプはデフォルト
        enabled          => TRUE,                               -- ジョブを有効化
        auto_drop        => TRUE,                               -- ジョブ完了後に自動削除
        comments         => '毎日定期的にデータをクレンジングおよび変換',               -- ジョブのコメント
        credential_name  => NULL,                               -- 認証情報なし
        destination_name => NULL,                               -- ターゲットデータベースなし
        max_run_duration => 0                                   -- 最大実行時間制限なし
    );
    COMMIT;
END;
/
-- スケジュールタスクを確認
SELECT * FROM DBA_SCHEDULER_JOBS WHERE job_name = 'myscheduler';
SELECT * from DBA_SCHEDULER_JOB_RUN_DETAILS WHERE job_name ='myscheduler';
```
