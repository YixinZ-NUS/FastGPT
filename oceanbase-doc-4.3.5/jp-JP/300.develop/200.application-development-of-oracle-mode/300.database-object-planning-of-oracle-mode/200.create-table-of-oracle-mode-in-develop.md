|description||
|---|---|
|keywords||
|dir-name||
|dir-name-en||
|tenant-type|Oracle Mode|

# テーブルの作成

本記事では、SQLステートメントを使用してテーブルを作成する方法について説明します。テーブル作成の前提条件、テーブルの概要、従うべき要件などを解説し、いくつかの例を紹介します。

## テーブルの概要

テーブルは、データオブジェクト間の関係を表し、保存するために使用される二次元配列の集合です。データベーステーブルを適切に設計および使用することで、データの信頼性、整合性、およびクエリのパフォーマンスを向上させることができ、データベース内のデータを効率的に管理および活用できます。

OceanBaseデータベーステーブルの詳細については、[テーブルの概要](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001973626)を参照してください。

## 前提条件

テーブルを作成する前に、以下の点を確認する必要があります：

* OceanBaseクラスタをデプロイし、Oracleモードのテナントを作成していること。OceanBaseクラスタのデプロイに関する情報については、[デプロイの概要](../../../400.deploy/100.deploy-overview.md)を参照してください。

* OceanBaseデータベースのOracleテナントに接続していること。データベースへの接続に関する詳細については、[接続方法の概要](../100.connect-to-oceanbase-database-of-oracle-mode/100.connection-methods-overview-of-oracle-mode.md)を参照してください。

* `CREATE TABLE` 権限をお持ちであることを確認してください。現在のユーザー権限を確認するための操作情報については、[ユーザー権限の確認](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001974764)を参照してください。この権限を持っていない場合は、管理者に連絡して権限を付与してもらってください。ユーザー権限の付与に関する操作情報については、[直接権限付与](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001974768)を参照してください。

## コマンドラインでテーブルを作成する

[CREATE TABLE](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001975088) ステートメントを使用してテーブルを作成してください。

### テーブル名の定義

テーブルを作成する際には、まずテーブル名を付ける必要があります。以下は、テーブル名を定義する際に従うべき要件です：

* OceanBaseデータベースのOracleモードでは、各テーブル名はSchema内で一意である必要があります。

* テーブルに名前を付ける際には、実際の意味を持つ名前を使用し、`table1` のような名前は使用しないでください。

例1： 注文情報に関するテーブルを作成します。

```sql
obclient [SYS]> CREATE TABLE ordr (c1 NUMBER, c2 VARCHAR2(50));
Query OK, 0 rows affected
```

### 列の定義

データベースにおいて、列（Column）とは、テーブル内の特定の属性の値を格納するためのフィールドです。ユーザーが各属性に付ける名前が列名となります。列には、列名のほかに、データ型やその最大長（精度）といった情報も含まれています。

以下は、テーブルの列を定義する際に従うべき要件です：

* データ型の特性に基づいて、列に格納するデータに適したデータ型を選択します。

* OceanBaseデータベースOracleモードでサポートされているデータ型とその詳細については、[データ型の概要](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001975141)を参照してください。

* 文字列データに対しては、可変長の文字列データ型を使用し、最大長を指定することを推奨します。指定する最大長は、格納する必要がある最大文字数より大きく設定してください。これにより、最大長を超えた場合に文字が切り捨てられるのを防ぎます。

* [主キー列](#主キー列の定義) の要件に基づき、テーブルに主キー列を定義する必要があるかどうかを確認します。

* [その他の制約](#その他の列制約の定義) の要件に基づき、列に他の制約を追加する必要があるかどうかを確認します。

* 列に `NOT NULL` 制約がある場合、通常はその列にデフォルト値を設定することを推奨します。列のタイプが日付または時刻の場合、データベースの現在時刻をデフォルト値として設定できます。

### 主キー列の定義

主キー制約（Primary Key Constraint）とは、特定のキー（1つまたは複数の列の組み合わせ）に対して定義されるルールであり、テーブル内の各行をそのキーの値によって一意に識別できるようにするためのものです。各データベーステーブルには、`PRIMARY KEY` 制約を1つだけ定義できます。この制約を構成する列（単一列または複数列）の値は、各行データの一意な識別子として機能します。つまり、各データ行はこの主キー値によって識別されます。

主キーを持つテーブルを作成すると、システムは主キー列に自動的にグローバルに一意のインデックスを作成します。主キーを使用することで、行を迅速に特定できます。

特定の列を主キー列として指定するには、その列の定義の後に `PRIMARY KEY` キーワードを追加します。複数の列に主キー制約を定義する場合は、[CREATE TABLE](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001975088) ステートメントのすべての列のリストの後に、主キー制約の定義を追加します。

以下は、主キー列を定義する際に従うべき要件です：

* テーブルに主キーを定義することを推奨します。各データベーステーブルで設定できる主キー（単一列または複数列）は、最大で1つです。

  OceanBaseデータベースでは、ユーザーがテーブルに主キーを定義することは必須ではありませんが、主キーを使用すると、テーブル内の各行データを一意に識別することができ、重複するデータ行の存在を防ぐことができます。適切なフィールドを主キーとして使用できない場合、テーブルに数値列を追加して主キーとし、Oracleテナントのシーケンスを使用して、その列に値を設定することができます。シーケンスの詳細については、[シーケンスの管理](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001971305)を参照してください。

  また、作成時に主キー列を定義していない場合でも、OceanBaseデータベースでは既存のテーブルに主キー列を追加することをサポートしています。

* 主キー列の集合の値は、テーブル全体で一意です。

* 主キー列の数は64列までで、主キーのデータ総長は16 KBを超えることはできません。

* 主キー列の値はNULLまたは空文字列にすることはできません。主キー列には値を入力する必要があります。

* 複数の列に主キー制約を定義する際には、主キー制約の名前を明確に指定することを推奨します。例えば、主キー制約を「PK_xxx」と命名します。

主キー制約の詳細については、[主キー制約](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001975785)を参照してください。

例2：複数の列に主キー制約を定義します。

```sql
obclient [SYS]> CREATE TABLE ordr (c1 NUMBER, c2 VARCHAR2(50), CONSTRAINT PK_c1_c2 PRIMARY KEY(c1, c2));
Query OK, 0 rows affected

obclient [SYS]> desc ordr;
+-------+--------------+------+-----+---------+-------+
| FIELD | TYPE         | NULL | KEY | DEFAULT | EXTRA |
+-------+--------------+------+-----+---------+-------+
| C1    | NUMBER       | NO   | PRI | NULL    | NULL  |
| C2    | VARCHAR2(50) | NO   | PRI | NULL    | NULL  |
+-------+--------------+------+-----+---------+-------+
2 rows in set
```

例2では、c1列とc2列を主キー列として定義し、制約名はPK_c1_c2です。 c1列およびc2列の値はNULLを許容せず、かつ重複してはなりません。

主キー列を定義した後でも、主キー列の変更と削除がサポートされます。主キー制約に関するその他の操作については、[列の制約タイプの定義](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001973623)を参照してください。

### その他の列制約の定義

`PRIMARY KEY` 制約に加えて、OceanBaseデータベースは `NOT NULL` 制約、一意性（UNIQUE）制約、外部キー（FOREIGN KEY）制約、およびCHECK制約をサポートしています。制約を使用することで、テーブルのクエリが簡素化され、クエリパフォーマンスが向上し、データのセマンティックな整合性が保証されます。

各制約タイプとその説明は以下のとおりです：

* NOT NULL制約（`NOT NULL`）：この制約は、対象の列に `NULL` 値を許可しないことを示します。

  NOT NULL制約のある列の場合、`INSERT` ステートメントでその列の値を指定する必要があります。ただし、その列にNOT NULLデフォルト値が定義されている場合は除きます。

* 一意性制約（`UNIQUE`）：制約が適用された列の値は重複を許容されませんが、複数の `NULL` 値は許容されます。

* 外部キー制約（`FOREIGN KEY`）：制約される列の値は、別のテーブルの主キー列から取得される必要があります。

  外部キー制約を作成する際に、外部キー名を指定しない場合、システムは自動的に制約名を割り当てます。自動的に割り当てられる制約名は、`テーブル名_OBFK_作成日時` となります。例えば、`t1_OBFK_1627747200000000` などです。

* `CHECK` 制約：データベースの特定の列の値が指定された条件を満たすことを要求します。

  単一の列に対して1つ以上の `CHECK` 制約を定義することで、その列に特定の値のみを許可することができます。また、テーブルレベルの `CHECK` 制約を定義することで、複数の列に `CHECK` 制約を適用することもできます。テーブル名を変更しても、`CHECK` 制約名は変更されません。テーブルを削除すると、そのテーブルに適用された `CHECK` 制約も同時に削除されます。

  `CHECK` 制約を作成する際に制約名を指定しない場合、システムは自動的に制約名を割り当てます。自動的に割り当てられる制約名は `テーブル名_OBCHECK_作成日時` の形式になります。例えば、`t1_OBCHECK_1629350823880271` のようになります。

単一の列を制約するには、その列の定義に制約キーワードを追加します。複数の列を制約するには、[CREATE TABLE](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001975088) ステートメントのすべての列のリストの後に、制約全体の定義を追加します。

以下は、その他の列制約を定義する際に従うべき要件です：

* NULL値が入らないことが明確なフィールドには、`NOT NULL` 制約を追加することを推奨します。

* 別のテーブルの値を参照する場合は、外部キー制約を使用してください。

* 複合主キーは外部キーとして使用することはできません。

* 列に重複値を許容しない場合は、一意制約を使用してください。

* `NOT NULL` 制約以外、その他の制約には明確な制約名を付けることを推奨します。たとえば、一意性制約は “UNI_xxx”、外部キー制約は “FK_xxx” と名付けられます。

例3：テーブル `tbl1` を作成し、列 `col1` にNOT NULL制約を設定します。

```sql
obclient [SYS]> CREATE TABLE tbl1(col1 NUMBER NOT NULL,col2 VARCHAR2(50));
Query OK, 0 rows affected

obclient [SYS]> DESC tbl1;
+-------+--------------+------+-----+---------+-------+
| FIELD | TYPE         | NULL | KEY | DEFAULT | EXTRA |
+-------+--------------+------+-----+---------+-------+
| COL1  | NUMBER       | NO   | NULL | NULL   | NULL  |
| COL2  | VARCHAR2(50) | YES  | NULL | NULL   | NULL  |
+-------+--------------+------+-----+---------+-------+
2 rows in set
```

例3では、以降のデータ挿入時に、列 `col1` には `NULL` 値を挿入できません。

例4：テーブル `tbl2` を作成し、列 `col1` に一意性制約を設定します。

```sql
obclient [SYS]> CREATE TABLE tbl2(col1 NUMBER UNIQUE,col2 VARCHAR2(50));
Query OK, 0 rows affected

obclient [SYS]> DESC tbl2;
+-------+--------------+------+-----+---------+-------+
| FIELD | TYPE         | NULL | KEY | DEFAULT | EXTRA |
+-------+--------------+------+-----+---------+-------+
| COL1  | NUMBER       | YES  | UNI | NULL    | NULL  |
| COL2  | VARCHAR2(50) | YES  | NULL| NULL    | NULL  |
+-------+--------------+------+-----+---------+-------+
2 rows in set
```

例4では、列 `col1` の値は重複してはいけません。

例5：テーブル `tbl3` に外部キー制約を作成します。

```sql
obclient [SYS]> CREATE TABLE test(c1 NUMBER, c2 NUMBER, CONSTRAINT PK_c1 PRIMARY KEY(c1));
Query OK, 0 rows affected

obclient [SYS]> CREATE TABLE tbl3(col1 NUMBER PRIMARY KEY,col2 NUMBER,CONSTRAINT FK_col2 FOREIGN KEY(col2) REFERENCES test(c1));
Query OK, 0 rows affected

obclient [SYS]> SELECT * FROM ALL_CONSTRAINTS\G
*************************** 1. row ***************************
            OWNER: SYS
  CONSTRAINT_NAME: FK_COL2
  CONSTRAINT_TYPE: R
       TABLE_NAME: TBL3
 SEARCH_CONDITION: NULL
          R_OWNER: SYS
R_CONSTRAINT_NAME: PK_C1
      DELETE_RULE: NO ACTION
           STATUS: ENABLED
       DEFERRABLE: NOT DEFERRABLE
         DEFERRED: IMMEDIATE
        VALIDATED: VALIDATED
        GENERATED: NULL
              BAD: NULL
             RELY: NULL
      LAST_CHANGE: NULL
      INDEX_OWNER: NULL
       INDEX_NAME: NULL
          INVALID: NULL
     VIEW_RELATED: NULL
*************************** 2. row ***************************
            OWNER: SYS
  CONSTRAINT_NAME: PK_C1
  CONSTRAINT_TYPE: P
       TABLE_NAME: TEST
 SEARCH_CONDITION: NULL
          R_OWNER: NULL
R_CONSTRAINT_NAME: NULL
      DELETE_RULE: NULL
           STATUS: ENABLED
       DEFERRABLE: NOT DEFERRABLE
         DEFERRED: IMMEDIATE
        VALIDATED: VALIDATED
        GENERATED: NULL
              BAD: NULL
             RELY: NULL
      LAST_CHANGE: NULL
      INDEX_OWNER: SYS
       INDEX_NAME: PK_C1
          INVALID: NULL
     VIEW_RELATED: NULL
*************************** 3. row ***************************
            OWNER: SYS
  CONSTRAINT_NAME: TBL3_OBPK_1666339106039791
  CONSTRAINT_TYPE: P
       TABLE_NAME: TBL3
 SEARCH_CONDITION: NULL
          R_OWNER: NULL
R_CONSTRAINT_NAME: NULL
      DELETE_RULE: NULL
           STATUS: ENABLED
       DEFERRABLE: NOT DEFERRABLE
         DEFERRED: IMMEDIATE
        VALIDATED: VALIDATED
        GENERATED: NULL
              BAD: NULL
             RELY: NULL
      LAST_CHANGE: NULL
      INDEX_OWNER: SYS
       INDEX_NAME: TBL3_OBPK_1666339106039791
          INVALID: NULL
     VIEW_RELATED: NULL
3 rows in set
```

例5では、テーブル `tbl3` の列 `col2` は、別のテーブル `test` の主キー列 `c1` と関連付けられています。作成が完了したら、`ALL_CONSTRAINTS`、`DBA_CONSTRAINTS` または `USER_CONSTRAINTS` ビューで確認できます。

例6：テーブル `tbl4` を作成し、列 `col1` の値が `10` より大きくなるように設定します。

```sql
obclient [SYS]> CREATE TABLE tbl4(col1 NUMBER CHECK(col1>10),col2 VARCHAR2(50));
Query OK, 0 rows affected

obclient [SYS]> INSERT INTO tbl4 VALUES(2,'CN');
OBE-02290: check constraint violated

obclient [SYS]> INSERT INTO tbl4 VALUES(11,'CN');
Query OK, 1 row affected
```

例6では、`col1` 列に `CHECK` 制約が追加されたため、`col1` 列に挿入される値が `10` 以下の場合、エラーが発生します。

その他の列制約の操作の詳細については、[列の制約タイプの定義](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001973623)を参照してください。

### パーティションスキームの選択

テーブル内のデータ量が多い場合は、テーブルをパーティション化することを推奨します。テーブルを作成する際には、テーブルのパーティション方式を明確にする必要があります。パーティションテーブルを作成する際には、テーブルに格納するデータに基づいて適切なパーティション方式を選択する必要があります。

OceanBaseデータベースのOracleモードでは、パーティション戦略に基づいて、パーティションテーブルはRangeパーティション、Listパーティション、Hashパーティション、およびコンポジット・パーティションに分類されます。パーティションの分割レベルに基づいて、パーティションテーブルはパーティションとサブパーティションに分けられます。サブパーティションはパーティションの二次分割です。そのため、パーティションテーブルには1つのパーティションキーがあり、コンポジット・パーティション・テーブルには2つのパーティションキーがあります。また、1回目と2回目の分割で異なるパーティション戦略を採用することも可能です。

パーティションの詳細については、[パーティションの概要](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001973607)を参照してください。

**Rangeパーティション**

Rangeパーティションは、最も一般的なパーティショニングタイプであり、通常は日付と組み合わせて使用されます。Rangeパーティションを行う際には、データベースはパーティションキーの値の範囲に基づいて行をパーティションにマッピングします。

Rangeパーティションを作成する際には、以下の要件を従うべきです：

* 各パーティションには、`VALUES LESS THAN(value)` 句が設定されており、その値自体は含まない上限値を定義します。パーティションキーの値に等しいかそれ以上の場合は、次のパーティションに割り当てられます。

* 最初のパーティションを除き、すべてのパーティションには暗黙的な下限値があり、それは前のパーティションの上限値に相当します。

* Rangeパーティションは、最も大きい範囲を扱うパーティションに `MAXVALUE` を定義することをサポートします。`MAXVALUE` は、仮想的な無限値を表し、パーティションキーの他の可能な値よりも大きい値として扱われます。`MAXVALUE` は最後のパーティションの上限値としてのみ許可されており、この値は具体的な数値を持たず、他のすべてのパーティションの上限値よりも大きく、NULL値もこのパーティションに含まれます。最後のRangeパーティションが `MAXVALUE` を指定している場合、新しいパーティションを追加することはできません。

例7：Rangeパーティションテーブルの作成

```sql
obclient [SYS]> CREATE TABLE tb1_r(col1 NUMBER,col2 NUMBER)
       PARTITION BY RANGE(col1)
        (PARTITION p0 VALUES LESS THAN(100),
         PARTITION p1 VALUES LESS THAN(200),
         PARTITION p2 VALUES LESS THAN(300)
        );
Query OK, 0 rows affected
```

例7では、`col1` をパーティションキーとして使用しています。パーティションテーブル `tb1_r` は、`100、200、300` の数値範囲に基づいてパーティション化されます。`p0、p1、p2` は指定されたパーティション名であり、任意に定義できますが、同じテーブル内の各パーティション名は重複しないようにする必要があります。

**Listパーティション**

Listパーティションを行う際には、システムは離散値リストを各パーティションのパーティションキーとして使用します。パーティションキーは、1つまたは複数の列で構成されます。

Listパーティションを作成する際には、以下の要件に従う必要があります：

* 各パーティションには、`VALUES (value_list)` 句が必要です。

* パーティション式で参照できる列は1つのみで、複数列（列ベクトル）を指定することはできません。

* 最後のListパーティションに `DEFAULT` を指定している場合、新しいパーティションを追加することはできません。

例8：Listパーティションテーブルの作成。

```sql
obclient [SYS]> CREATE TABLE tbl2_l (col1 NUMBER,col2 DATE)
         PARTITION BY LIST(col1)
          (PARTITION p0 VALUES (100),
           PARTITION p1 VALUES (200)
          );
Query OK, 0 rows affected
```

例8では、`col1` 列をパーティションキーとして使用し、tbl2_lテーブルは `100、200` の列値に基づいてパーティション化されます。

**Hashパーティション**

Hashパーティションを行う際には、システムはユーザーが指定したパーティションキーに対してハッシュアルゴリズムを適用し、その結果に基づいて行をパーティションにマッピングします。​Hashパーティションは、ノード間でデータを均等に分散する理想的な方法です。Hashパーティションは、Rangeパーティションの代替として使いやすい方法であり、特に、分割対象のデータが履歴データではない場合や、明確なパーティションキーが見当たらない場合に有効です。

例9：Hashパーティションテーブルの作成

```sql
obclient [SYS]> CREATE TABLE tbl3_h(col1 NUMBER,col2 NUMBER)
     PARTITION BY HASH(col1) PARTITIONS 2;
Query OK, 0 rows affected
```

例9では、`col1` をパーティションキーとして使用し、`tbl3_h` テーブルを2つのパーティションに分割しています。テーブル作成時にHashパーティションの名前を指定しなかった場合は、パーティションの命名はシステムが命名ルールに従って自動的に行い、それぞれのパーティションはp0、p1、...、pnと命名されます。

**コンポジット・パーティション（サブパーティション）**

コンポジット・パーティションは通常、最初に1つのパーティション戦略を適用し、次にサブパーティションに別のパーティション戦略を適用します。これは、ビジネステーブルのデータ量が非常に大きい場合に適しています。コンポジット・パーティションを使用すると、複数のパーティション戦略の長所を活かすことができます。

Rangeパーティション、Listパーティション、Hashパーティションはすべて、コンポジット・パーティションテーブルのサブパーティション戦略として使用できます。OceanBaseデータベースでは、コンポジット・パーティション・テーブルには、テンプレート化されたコンポジット・パーティション・テーブルと非型テンプレートコンポジット・パーティション・テーブルが含まれます。

以下に、いくつかの簡単な例を用いて、コンポジット・パーティション・テーブルの作成方法を簡単に紹介します。

例10：Range + Listパーティションのテンプレート化されたコンポジット・パーティション・テーブルを作成します。

```sql
obclient [SYS]> CREATE TABLE tbl4_m_rl(col1 NUMBER,col2 VARCHAR2(50))
       PARTITION BY RANGE(col1)
       SUBPARTITION BY LIST(col2)
       SUBPARTITION TEMPLATE
         (SUBPARTITION mp0 VALUES('01'),
          SUBPARTITION mp1 VALUES('02'),
          SUBPARTITION mp2 VALUES('03')
          )
         (PARTITION p0 VALUES LESS THAN(100),
          PARTITION p1 VALUES LESS THAN(200)
          );
Query OK, 0 rows affected
```

例10では、`SUBPARTITION TEMPLATE` キーワードを使用して、テンプレート化されたコンポジット・パーティション・テーブルを作成します。テンプレート化されたコンポジット・パーティション・テーブルにおいて、各パーティションの下にあるサブパーティションは、テンプレート内のサブパーティション定義に従うため、各パーティションの下にあるサブパーティション定義はすべて同じです。本例では、まずRangeパーティション方式でパーティションを作成し、次にListパーティション方式でサブパーティションを作成します。

さらに、テンプレート化されたサブパーティションを作成する際には、サブパーティションの定義が完了した後、各パーティションの名前を個別に指定する必要はなく、システムが命名ルールに従って一括で命名を行います。各サブパーティションの命名ルールは `($part_name)s($subpart_name)` です。例を以下に示します。

例11：List + Hashパーティションのテンプレート化されたコンポジット・パーティション・テーブルを作成する。

```sql
obclient [SYS]> CREATE TABLE tbl5_m_lh(col1 INT,col2 VARCHAR2(50))
     PARTITION BY LIST(col1)
     SUBPARTITION BY HASH(col2) SUBPARTITIONS 5
      (PARTITION p0 VALUES('01'),
       PARTITION p1 VALUES('02')
       );
Query OK, 0 rows affected

obclient [SYS]> SHOW CREATE TABLE tbl5_m_lh;
+-----------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| TABLE     | CREATE TABLE


                                                          |
+-----------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| TBL5_M_LH | CREATE TABLE "TBL5_M_LH" (
  "COL1" NUMBER(*,0),
  "COL2" VARCHAR2(50)
) COMPRESS FOR ARCHIVE REPLICA_NUM = 1 BLOCK_SIZE = 16384 USE_BLOOM_FILTER = FALSE TABLET_SIZE = 134217728 PCTFREE = 0
 partition by list(col1) subpartition by hash(col2) subpartition template (
subpartition P0,
subpartition P1,
subpartition P2,
subpartition P3,
subpartition P4)
(partition P0 values  (1),
partition P1 values  (2)) |
+-----------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set

obclient [SYS]> SELECT table_name,partition_name,subpartition_name FROM USER_TAB_SUBPARTITIONS WHERE table_name = 'TBL5_M_LH';
+------------+----------------+-------------------+
| TABLE_NAME | PARTITION_NAME | SUBPARTITION_NAME |
+------------+----------------+-------------------+
| TBL5_M_LH  | P0             | P0SP0             |
| TBL5_M_LH  | P0             | P0SP1             |
| TBL5_M_LH  | P0             | P0SP2             |
| TBL5_M_LH  | P0             | P0SP3             |
| TBL5_M_LH  | P0             | P0SP4             |
| TBL5_M_LH  | P1             | P1SP0             |
| TBL5_M_LH  | P1             | P1SP1             |
| TBL5_M_LH  | P1             | P1SP2             |
| TBL5_M_LH  | P1             | P1SP3             |
| TBL5_M_LH  | P1             | P1SP4             |
+------------+----------------+-------------------+
10 rows in set
```

例11では、Hashパーティションを使用してサブパーティションを作成する際に、パーティション名を指定しなかったため、システムが命名ルールに基づいてサブパーティション定義 `p0、p1、p2、p3、p4` を自動的に生成しました。次に、テンプレート化されたサブパーティションの命名ルールに基づき、パーティション `p0` に対応するパーティション名は `p0smp0`、`p0smp1`、`p0smp2`、`p0smp3`、`p0smp4` となります。

  <main id="notice" type='notice'>
    <h4>注意</h4>
    <p>Hashパーティションの場合、パーティション数を指定する方法（例：<code>SUBPARTITIONS 5</code>）でサブパーティションを行う場合、テンプレート化されたコンポジット・パーティション・テーブルの作成時に <code>SUBPARTITION TEMPLATE</code> キーワードを指定する必要はありません。</p>
  </main>

例12：ListパーティションとHashパーティションを組み合わせた非型テンプレートコンポジット・パーティション・テーブルを作成します。

```sql
obclient [SYS]> CREATE TABLE tbl6_f_lh(col1 NUMBER,col2 VARCHAR2(50))
       PARTITION BY LIST(col1)
       SUBPARTITION BY HASH(col2)
       (PARTITION p0 VALUES('01')
         (SUBPARTITION sp0,
          SUBPARTITION sp1
          ),
        PARTITION p1 VALUES('02')
         (SUBPARTITION sp2,
          SUBPARTITION sp3,
          SUBPARTITION sp4
          )
        );
Query OK, 0 rows affected
```

例12では、非型テンプレートコンポジット・パーティション・テーブルを作成するため、`SUBPARTITION TEMPLATE` キーワードを追加する必要はありません。非型テンプレートコンポジット・パーティション・テーブルでは、各パーティションの下にあるサブパーティションは自由に定義できます。つまり、各パーティションの下にあるサブパーティションの定義は、同一でも異なっていても構いません。本例では、最初にListパーティション方式でパーティションを作成し、次にHash方式でサブパーティションを作成します。

## レプリケーションテーブルの作成

レプリケーションテーブルはOceanBaseデータベースの特殊なテーブルです。このテーブルは、任意の「正常」なレプリカ上でデータの最新の更新を読み取ることができます。書き込み頻度が低く、読み込み頻度が高いシナリオでは、レプリケーションテーブルは非常によい選択肢です。

レプリケーションテーブルの詳細については、[テーブルの作成](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001973625) の **レプリケーションテーブルの作成** セクションを参照してください。

<main id="notice" type='notice'>
  <h4>注意</h4>
  <p>ユーザーテナントのみがレプリケーションテーブルを作成できます。<code>sys</code> テナントはレプリケーションテーブルを作成できません。</p>
</main>

レプリケーションテーブルを作成するSQL構文は次のとおりです：

```sql
CREATE TABLE table_name column_definition DUPLICATE_SCOPE='none | cluster';
```

パラメータの説明：

* `table_name`：テーブル名。
* `column_definition`：テーブルの列情報。例えば、列定義、主キー定義など。
* `DUPLICATE_SCOPE`：レプリケーションテーブルのプロパティを指定するために使用します。値は以下のとおりです：

  * `none`：このテーブルが通常のテーブルであることを示しています。
  * `cluster`：このテーブルはレプリケーションテーブルであり、Leaderはトランザクションを現在のテナントのすべてのFレプリカとRレプリカにレプリケートする必要があります。

例13：以下のSQLステートメントを使用して、レプリケーションテーブル `test_tbl13` を作成します。

```sql
CREATE TABLE test_tbl13 (col1 NUMBER,col2 NUMBER) DUPLICATE_SCOPE= 'cluster';
```

## 次の操作

テーブルの作成が完了したら、テーブルの使用と管理を最適化するために、次の操作を実行する必要があるかもしれません：

* テーブルを作成したら、`INSERT` ステートメントを使用してテーブルにデータを挿入できます。データの挿入に関する詳細については、[データの挿入](../400.write-data-of-oracle-mode/100.insert-data-of-oracle-mode-in-develop.md)を参照してください。

* クエリのパフォーマンスを向上させる必要がある場合は、テーブルの列にインデックスを作成できます。インデックスの作成に関する詳細については、[インデックスの作成](300.create-index-of-oracle-mode-in-develop.md)を参照してください。

## 関連ドキュメント

* テーブルのプロパティの詳細については、[テーブルの定義の確認](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001973622)を参照してください。
* テーブルの削除の詳細については、[テーブルの削除](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001973618)を参照してください。
* テーブル構造の変更に関する詳細については、[テーブルの変更](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001973621)を参照してください。
* パーティションテーブルの作成の詳細については、[パーティションテーブルの作成](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001973607)を参照してください。
