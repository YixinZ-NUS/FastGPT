|description||
|---|---|
|keywords||
|dir-name|SpringBatch|
|dir-name-en||
|tenant-type|Oracle Mode|

# SpringBatch

本記事では、SpringBatchフレームワークとOceanBaseデータベースを使用して、テーブルの作成、データの挿入、クエリなどの基本的な操作を実現するアプリケーションの構築方法について説明します。

<div role="videolist">
      <a role='link' href='https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/demo/java/java-oceanbase-springbatch/java-oceanbase-springbatch.zip'>
          <img src='https://file.oceanbase.com/doc/img/lQLPJyFovGIOcJQWFrAqhLlgRRsPvwU-H7hJ_i0A_22_22.png'/>
          クリックしてjava-oceanbase-springbatchサンプルプロジェクトをダウンロード
      </a>
      <!-- <a role='video' href='https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/video-center/video/video/07%20java-ob-springbatch_e07.mp4'>
          <img src='https://mdn.alipayobjects.com/huamei_22khvb/afts/img/A*DFPmToHK6hgAAAAAAAAAAAAADiGDAQ/original'/>
          SpringBatch 连接 OceanBase 数据库示例程序（Oracle 模式）
      </a> -->
</div>

## 前提条件

* OceanBaseデータベースがインストール済みであること。
* JDK 1.8とMavenがインストール済みであること。
* IntelliJ IDEAがインストール済みであること。

<main id="notice" type='explain'>
  <h4>説明</h4>
  <p>この記事でコードを実行するために使用したツールは、IntelliJ IDEA 2021.3.2（Community Edition）バージョンです。ご自身の好みに合わせて、適切なツールを選択してサンプルコードを実行することも可能です。</p>
</main>

## 操作手順

<main id="notice" type='explain'>
  <h4>説明</h4>
  <p>本記事で示されている操作手順は、Windows環境に基づいています。他のOS環境やコンパイラを使用している場合は、操作手順が若干異なる場合があります。 </p>
</main>

1. OceanBaseデータベースの接続文字列を取得します。
2. `java-oceanbase-springbatch` プロジェクトをIDEAにインポートします。
3. `java-oceanbase-springbatch` プロジェクト内のデータベース接続情報を修正します。
4. `java-oceanbase-springbatch` プロジェクトを実行します。

### ステップ１：OceanBaseデータベースの接続文字列を取得する

1. OceanBaseデータベースのデプロイ担当者または管理者から、該当するデータベース接続文字列を取得します。

    ```shell
    obclient -hxx.xx.xx.xx -P2883 -uroot@sys#cluster -p**** -A
    ```

2. デプロイ済みのOceanBaseデータベースに基づいて、以下のURLの対応する情報を入力します。

    <main id="notice" type='explain'>
    <h4>説明</h4>
    <p><code>application.properties</code> ファイルには、このURL情報が必要です。</p>
    </main>

    ```java
    jdbc:oceanbase://host:port/schema_name?user=$user_name&password=$password&characterEncoding=utf-8
    ```

    **パラメータの説明：**

    * `host`：OceanBaseデータベースへの接続IPアドレス。ODP接続方式ではODPアドレスを使用し、直接接続方式ではOBServerノードのIPアドレスを使用します。
    * `port`：OceanBaseデータベースへの接続ポート。ODP接続方式のデフォルトポートは`2883`で、ODPデプロイ時にカスタマイズ可能です。直接接続方式のデフォルトポートは`2881`で、OceanBaseデータベースのデプロイ時にカスタマイズ可能です。
    * `schema_name`：アクセスするスキーマ名です。
    * `user_name`：テナントの接続アカウント。ODP接続方式の一般的な形式には次の2種類があります：`ユーザー名@テナント名#クラスタ名` または `クラスタ名:テナント名:ユーザー名`。直接接続方式の形式：`ユーザー名@テナント名`。
    * `password`：アカウントのパスワード。
    * `characterEncoding`：文字エンコーディングを提供します。

その他のURLパラメータの説明情報については、[データベースURL](https://en.oceanbase.com/docs/common-oceanbase-connector-j-en-10000000002244946)を参照してください。

### ステップ2：`java-oceanbase-springbatch` プロジェクトをIDEAにインポートする

1. **IntelliJ IDEA** を開き、**File > Open...** オプションを選択します。

   ![file](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/demo/java/mybatis/file.jpg)

2. 表示された **Open File or Project** ウィンドウで、対応するプロジェクトファイルを選択し、**OK** をクリックしてプロジェクトファイルのインポートを完了します。

3. IntelliJ IDEAは、プロジェクト内のさまざまなファイルの種類を自動的に認識し、**Project** ツールウィンドウで、プロジェクトのディレクトリ構造、ファイルリスト、モジュールリスト、依存関係などの情報を確認できます。**Project** ツールウィンドウは通常、IntelliJ IDEA画面の左側にあり、デフォルトでは開いています。**Project** ツールウィンドウが閉じている場合は、メニューバーの **View > Tool Windows > Project** をクリックするか、ショートカットキー **Alt + 1** を使用して再表示できます。

    <main id="notice" type='explain'>
    <h4>説明</h4>
    <p>IntelliJ IDEAでプロジェクトをインポートすると、IntelliJ IDEAはプロジェクト内のpom.xmlファイルを自動的に検出し、ファイルに記述されている依存関係に基づいて必要な依存ライブラリを自動的にダウンロードし、プロジェクトに追加します。</p>
    </main>

4. プロジェクトの状況を確認します。

  ![springbatch](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/demo/java/java-oceanbase-springbatch/springbatch.jpg)

### ステップ3：`java-oceanbase-springbatch` プロジェクトのデータベース接続情報を修正する

**ステップ１：OceanBaseデータベースの接続文字列を取得する** に記載されている情報に基づいて、`application.properties` ファイル内のデータベース接続情報を修正します。

**例：**

* データベースドライバーの名前：`com.oceanbase.jdbc.Driver`
* OBServerノードのIPアドレスは `10.10.10.1` です。
* アクセスポートは2881を使用します。
* アクセスするスキーマ名は `sys` です。
* テナントの接続アカウントは `sys@xyoracle` です。`xyoracle` はOceanBaseデータベース内に作成されたOracleモードのユーザーテナントであり、`sys` はテナント `xyoracle` のユーザー名です。
* パスワードは `******` です。

**サンプルコードは以下のとおりです：**

```java
spring.datasource.driver-class-name=com.oceanbase.jdbc.Driver
spring.datasource.url=jdbc:oceanbase://10.10.10.1:2881/sys?characterEncoding=utf-8
spring.datasource.username=sys@xyoracle
spring.datasource.password=******

spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=update

spring.batch.job.enabled=false

logging.level.org.springframework=INFO
logging.level.com.example=DEBUG
```

### ステップ4：`java-oceanbase-springbatch` プロジェクトを実行する

* `AddDescPeopleWriterTest.java` ファイルを実行します。

    1. プロジェクト構造内の **src > test > java** から `AddDescPeopleWriterTest.java` ファイルを見つけます。
    2. ツールメニューバーで **Run > Run... > AddDescPeopleWriterTest.testWrite** を選択するか、右上の **緑色の三角形** を直接クリックして実行します。
    3. IDEAのコンソールを使用して、プロジェクトのログ情報と出力結果を確認します。

    ```java
    people_desc テーブルのデータ：
    PeopleDESC [name=John, age=25, desc=This is John with age 25]
    PeopleDESC [name=Alice, age=30, desc=This is Alice with age 30]
    Batch Job execution completed.
    ```

* `AddPeopleWriterTest.java` ファイルを実行します。

    1. プロジェクト構造内の **src > test > java** から `AddDescPeopleWriterTest.java` ファイルを見つけます。
    2. ツールメニューバーで **Run > Run... > AddPeopleWriterTest.testWrite** を選択するか、右上の **緑色の三角形** を直接クリックして実行します。
    3. IDEAのコンソールを使用して、プロジェクトのログ情報と出力結果を確認します。

    ```java
    peopleテーブルのデータ：
    People [name=zhangsan, age=27]
    People [name=lisi, age=35]
    Batch Job execution completed.
    ```

## プロジェクトコードについて

[java-oceanbase-springbatch](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/demo/java/java-oceanbase-springbatch/java-oceanbase-springbatch.zip) をクリックしてプロジェクトコードをダウンロードします。これは `java-oceanbase-springbatch` という名前の圧縮ファイルです。

解凍すると、`java-oceanbase-springbatch` という名前のフォルダが作成されます。ディレクトリ構造は以下のとおりです：

```java
│  pom.xml
│
├─.idea
│
├─src
│  ├─main
│  │  ├─java
│  │  │  └─com
│  │  │      └─oceanbase
│  │  │          └─example
│  │  │              └─batch
│  │  │                  │──BatchApplication.java
│  │  │                  │
│  │  │                  ├─config
│  │  │                  │   └─BatchConfig.java
│  │  │                  │
│  │  │                  ├─model
│  │  │                  │   ├─People.java
│  │  │                  │   └─PeopleDESC.java
│  │  │                  │
│  │  │                  ├─processor
│  │  │                  │   └─AddPeopleDescProcessor.java
│  │  │                  │
│  │  │                  └─writer
│  │  │                      ├─AddDescPeopleWriter.java
│  │  │                      └─AddPeopleWriter.java
│  │  │
│  │  └─resources
│  │      └─application.properties
│  │
│  └─test
│      └─java
│          └─com
│              └─oceanbase
│                  └─example
│                      └─batch
│                          ├─config
│                          │   └─BatchConfigTest.java
│                          │
│                          ├─processor
│                          │   └─AddPeopleDescProcessorTest.java
│                          │
│                          └─writer
│                              ├─AddDescPeopleWriterTest.java
│                              └─AddPeopleWriterTest.java
│
└─target
```

**ファイルの説明：**

* `pom.xml`：Mavenプロジェクトの設定ファイルは、プロジェクトの依存関係、プラグイン、ビルドなどの情報が含まれます。
* `.idea`：IDE（統合開発環境）で使用されるディレクトリで、プロジェクト関連の設定情報を格納するために使用されます。
* `src`：通常、プロジェクトのソースコードを格納するディレクトリを表すために使用されます。
* `main`： 主要なソースコードとリソースファイルを格納するディレクトリ。
* `java`： Javaソースコードを格納するディレクトリ。
* `com`： Javaパッケージを格納するルートディレクトリ。
* `oceanbase`： プロジェクトを格納するルートディレクトリ。
* `example`： プロジェクトを格納するルートディレクトリ。
* `batch`： プロジェクトのメインパッケージ名。
* `BatchApplication.java`：アプリケーションのエントリクラスで、アプリケーションのmainメソッドが含まれます。
* `config`：設定クラスのフォルダで、アプリケーションの設定クラスが含まれます。
* `BatchConfig.java`：アプリケーションの設定クラスで、アプリケーションの一部のプロパティと動作を設定するために使用されます。
* `model`：モデルクラスのフォルダで、アプリケーションのデータモデルクラスが含まれます。
* `People.java`：人員データのモデルクラスです。
* `PeopleDESC.java`：人員DESCデータのモデルクラスです。
* `processor`：プロセッサクラスのフォルダで、アプリケーションのプロセッサクラスが含まれます。
* `AddPeopleDescProcessor.java`：人員DESC情報を追加するプロセッサクラスです。
* `writer`：ライタークラスのフォルダで、アプリケーションのライタークラスが含まれます。
* `AddDescPeopleWriter.java`：人員DESC情報を書き込むライタークラスです。
* `AddPeopleWriter.java`：人員情報を書き込むライタークラスです。
* `resources`：リソースのフォルダで、アプリケーションの設定ファイルとその他の静的リソースファイルが含まれます。
* `application.properties`：アプリケーションの設定ファイルで、アプリケーションのプロパティを設定するために使用されます。
* `test`： テストコードとリソースファイルを格納するディレクトリ。
* `BatchConfigTest.java`：アプリケーション設定クラスのテストクラスです。
* `AddPeopleDescProcessorTest.java`：人員DESCを追加するプロセッサのテストクラスです。
* `AddDescPeopleWriterTest.java`：人員DESC情報を書き込むライターのテストクラスです。
* `AddPeopleWriterTest.java`：人員情報を書き込むライターのテストクラスです。
* `target`： コンパイル済みのClassファイル、Jarパッケージなどのファイルを格納するディレクトリ。

### pom.xmlコードの紹介

<main id="notice" type='explain'>
  <h4>説明</h4>
  <p>例を確認するだけの場合、デフォルトコードを使用してください。変更する必要はありません。以下の説明に従って、必要に応じて <code>pom.xml</code> ファイルを変更することもできます。</p>
</main>

`pom.xml` 設定ファイルの内容は以下のとおりです：

1. ファイル宣言ステートメントです。

    このファイルがXMLファイルであり、使用しているXMLのバージョンが `1.0` で、文字エンコーディング方式が `UTF-8` であることを宣言しています。

    **コード：**

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    ```

2. POMのネームスペースとPOMモデルのバージョンを設定します。

   1. `xmlns` を使用して、POMのネームスペースを `http://maven.apache.org/POM/4.0.0` と指定します。
   2. `xmlns:xsi` を使用して、XMLネームスペースを `http://www.w3.org/2001/XMLSchema-instance` と指定します。
   3. `xsi:schemaLocation` を使用して、POMのネームスペースを `http://maven.apache.org/POM/4.0.0`、POMのXSDファイルの場所を `https://maven.apache.org/xsd/maven-4.0.0.xsd` と指定します。
   4. `<modelVersion>` 要素を使用して、このPOMファイルで使用されるPOMモデルのバージョンを `4.0.0` と指定します。

   **コード：**

   ```xml
    <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
        <modelVersion>4.0.0</modelVersion>
   </project>
   ```

3. 親要素の情報を設定します。

   1. `<groupId>` を使用して、親要素の識別子を `org.springframework.boot` と指定します。
   2. `<artifactId>` を使用して、親要素の依存関係を `spring-boot-starter-parent` と指定します。
   3. `<version>` を使用して、親要素のバージョンを `2.7.11` と指定します。
   4. `relativePath` を使用して、親要素のパスが空であることを示します。

   **コード：**

   ```xml
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.7.11</version>
        <relativePath/>
    </parent>
   ```

4. 基本情報を設定します。

   1. `<groupId>` を使用して、プロジェクト識別子を `com.oceanbase` と指定します。
   2. `<artifactId>` を使用して、プロジェクト依存関係を `java-oceanbase-springboot` と指定します。
   3. `<version>` を使用して、プロジェクトのバージョン番号を `0.0.1-SNAPSHOT` と指定します。
   4. `description` を使用して、プロジェクトの情報を `Demo project for Spring Batch` として紹介します。

   **コード：**

   ```xml
    <groupId>com.oceanbase</groupId>
    <artifactId>java-oceanbase-springboot</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>java-oceanbase-springbatch</name>
    <description>Demo project for Spring Batch</description>
   ```

5. Javaバージョンを設定します。

    プロジェクトで使用するJavaバージョンを1.8と指定します。

    **コード：**

    ```xml
      <properties>
          <java.version>1.8</java.version>
      </properties>
    ```

6. コア依存関係を設定します。

   1. 依存関係が所属する組織を `org.springframework.boot`、名前を `spring-boot-starter` と指定します。この依存関係によりSpring Bootがデフォルトでサポートするコンポーネントの依存関係を利用でき、Web、データ処理、セキュリティ、Testなどの機能がサポートされます。

        **コード：**

        ```xml
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>
        ```

   2. 依存関係が所属する組織を `org.springframework.boot`、名前を `spring-boot-starter-jdbc` と指定します。この依存関係により、Spring Bootが提供するJDBC関連機能（接続プール、データソース設定など）を利用できます。

        **コード：**

        ```xml
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-jdbc</artifactId>
        </dependency>
        ```

   3. 依存関係が所属する組織を `org.springframework.boot`、名前を `spring-boot-starter-test`、スコープを `test` と指定します。この依存関係により、JUnit、Mockito、HamcrestなどのSpring Bootが提供するテストフレームワークとツールを利用できます。

        **コード：**

        ```xml
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        ```

   4. 依存関係が属する組織を `com.oceanbase`、名前を `oceanbase-client`、バージョン番号を `2.4.3` と指定します。この依存関係を使用することで、OceanBaseが提供するクライアント機能（接続、クエリ、トランザクションなど）を利用できます。

      **コード：**

        ```xml
            <dependency>
                <groupId>com.oceanbase</groupId>
                <artifactId>oceanbase-client</artifactId>
                <version>2.4.3</version>
            </dependency>
        ```

   5. 依存関係が所属する組織を `org.springframework.boot`、名前を `spring-boot-starter-batch` と指定します。この依存関係により、Spring Bootが提供するバッチ処理機能を利用できます。

      **コード：**

        ```xml
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-batch</artifactId>
        </dependency>
        ```

   6. 依存関係が所属する組織を `org.springframework.boot`、名前を `spring-boot-starter-data-jpa` と指定します。この依存関係により、JPAを使用したデータアクセスに必要な依存関係と設定を利用できます。Spring Boot Starter Data JPAはSpring Bootのスターターです。

        **コード：**

        ```xml
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        ```

   7. 依存関係が所属する組織を `org.apache.tomcat`、名前を `tomcat-jdbc` と指定します。この依存関係により、Tomcatが提供するJDBC接続プール機能を利用できます。接続プールの設定、接続の取得と解放、接続の管理などが含まれます。

        **コード：**

        ```xml
        <dependency>
            <groupId>org.apache.tomcat</groupId>
            <artifactId>tomcat-jdbc</artifactId>
        </dependency>
        ```

   8. 依存関係の所属するテストアーキテクチャを `junit`、名前を `junit`、バージョン番号を `4.10`、スコープを `test` と設定します。この依存関係により、JUnit単体テスト依存関係の設定を追加できます。

        **コード：**

        ```xml
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.10</version>
            <scope>test</scope>
        </dependency>
        ```

   9. 依存関係が所属する組織を `javax.activation`、名前を `javax.activation-api`、バージョン番号を `1.2.0` と指定します。この依存関係により、Java Activation Framework（JAF）ライブラリを導入できます。

        **コード：**

        ```xml
        <dependency>
            <groupId>javax.activation</groupId>
            <artifactId>javax.activation-api</artifactId>
            <version>1.2.0</version>
        </dependency>
        ```

   10. 依存関係が所属する組織を `jakarta.persistence`、名前を `jakarta.persistence-api`、バージョン番号を `2.2.3` と指定します。この依存関係により、Jakarta Persistence API依存関係の設定を追加できます。
        **コード：**

        ```xml
        <dependency>
            <groupId>jakarta.persistence</groupId>
            <artifactId>jakarta.persistence-api</artifactId>
            <version>2.2.3</version>
        </dependency>
        ```

7. Mavenプラグインを設定します。

   依存関係が所属する組織を `org.springframework.boot`、名前を `spring-boot-maven-plugin` と指定します。このプラグインはSpring Bootアプリケーションを実行可能なJARパッケージまたはWARパッケージにパッケージ化するために使用され、直接実行できます。

   **コード：**

   ```xml
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
   ```

### application.propertiesファイルの紹介

`application.properties` ファイルは、データベース接続およびその他の関連構成パラメータを設定するために使用されます。データベースドライバープログラム、接続URL、ユーザー名、パスワードなど。また、JPA（Java Persistence API）とSpring Batchに関する一部の設定、ログレベルの設定も含まれます。

1. データベースの接続設定を行います。

    * `spring.datasource.driver` を使用して、データベースドライバープログラムを `com.oceanbase.jdbc.Driver` と指定します。OceanBaseデータベースとの接続を確立するために使用されます。
    * `spring.datasource.url` を使用して、データベース接続用のURLを指定します。
    * `spring.datasource.username` を使用して、データベース接続用のユーザー名を指定します。
    * `spring.datasource.password` を使用して、データベース接続用のパスワードを指定します。

    **コード：**

    ```java
    spring.datasource.driver-class-name=com.oceanbase.jdbc.Driver
    spring.datasource.url=jdbc:oceanbase://host:port/schema_name?characterEncoding=utf-8
    spring.datasource.username=user_name
    spring.datasource.password=******
    ```

2. JPAを設定します。

    * `spring.jpa.show-sql` を使用して、ログにSQLステートメントを表示するかどうかを指定します。`true` に設定するとSQLステートメントが表示されます。
    * `spring.jpa.hibernate.ddl-auto` を使用して、HibernateのDDL操作の動作を指定します。ここでは `update` に設定し、アプリケーション起動時にデータベース構造を自動的に更新することを示します。

    **コード：**

    ```java
    spring.jpa.show-sql=true
    spring.jpa.hibernate.ddl-auto=update
    ```

3. Spring Batch設定：

    `spring.batch.job.enabled` を使用して、Spring Batchジョブを有効にするかどうかを指定します。ここでは `false` に設定し、Spring Batchジョブを無効にすることを示します。

    **コード：**

    ```java
    spring.batch.job.enabled=false
    ```

4. ログ設定：

    * `logging.level.org.springframework` を使用して、Springフレームワークのログレベルを `INFO` と指定します。
    * `logging.level.com.example` を使用して、アプリケーションのカスタムコードのログレベルを `DEBUG` と指定します。

    **コード：**

    ```java
    logging.level.org.springframework=INFO
    logging.level.com.example=DEBUG
    ```

### BatchApplication.javaファイルの紹介

`BatchApplication.java` ファイルは、Spring Bootアプリケーションのエントリファイルです。

`BatchApplication.java` ファイルのコードには、主に以下の部分が含まれます：

1. 他のクラスとインターフェースをインポートします。

    このファイルに以下のインターフェースとクラスが含まれていることを宣言します：

    * `SpringApplication` クラス：Spring Bootアプリケーションを起動するために使用されます。
    * `SpringBootApplication` アノテーション：このクラスをSpring Bootアプリケーションのエントリとしてマークするために使用されます。

    **コード：**

    ```java
        import org.springframework.boot.SpringApplication;
        import org.springframework.boot.autoconfigure.SpringBootApplication;
    ```

2. `BatchApplication` クラスを定義します。

   `@SpringBootApplication` アノテーションを使用して、`BatchApplication` クラスをSpring Bootアプリケーションのエントリポイントとしてマークします。`BatchApplication` クラスでは、アプリケーションのエントリポイントとして、静的な `main` メソッドが定義されています。このメソッドでは、`SpringApplication.run` メソッドを使用してSpring Bootアプリケーションを起動します。また、バッチ処理ジョブを実行するための `runBatchJob` という名前のメソッドも定義されています。

    **コード：**

    ```java


        @SpringBootApplication
        public class BatchApplication {
            public static void main(String[] args) {
                SpringApplication.run(BatchApplication.class, args);
            }

            public void runBatchJob() {
            }
        }
    ```

### BatchConfig.javaファイルの紹介

`BatchConfig.java` ファイルは、バッチ処理ジョブのステップ、リーダー、プロセッサ、ライターなどのコンポーネントを設定するために使用されます。

`BatchConfig.java` ファイルのコードには、主に以下の部分が含まれます：

1. 他のクラスとインターフェースをインポートします。

    このファイルに以下のインターフェースとクラスが含まれていることを宣言します：

    * `People` クラス：データベースから読み取った人員情報を格納するために使用されます。
    * `PeopleDESC` クラス：人員情報を変換または処理した後の説明情報を格納するために使用されます。
    * `AddPeopleDescProcessor` クラス：読み取った `People` オブジェクトを `PeopleDESC` オブジェクトに変換する、`ItemProcessor` インターフェースの実装クラス。
    * `AddDescPeopleWriter` クラス：`PeopleDESC` オブジェクトをターゲット位置に書き込む `ItemWriter` インターフェースの実装クラス。
    * `Job` インターフェース：バッチ処理ジョブを表します。
    * `Step` インターフェース：ジョブ内のステップを表します。
    * `EnableBatchProcessing` アノテーション：Spring Batchの設定アノテーションで、Spring Batch処理機能を有効にして設定するために使用されます。
    * `JobBuilderFactory` クラス：ジョブの作成と設定に使用されます。
    * `StepBuilderFactory` クラス：ステップの作成と設定に使用されます。
    * `RunIdIncrementer` クラス：Spring Batchの実行ID（Run ID）自動インクリメンターで、ジョブを実行するたびに実行IDを増加させるために使用されます。
    * `ItemProcessor` インターフェース：読み取ったアイテムを処理または変換するために使用されます。
    * `ItemReader` インターフェース：データソースからアイテムを読み取るために使用されます。
    * `ItemWriter` インターフェース：処理または変換後のアイテムを指定されたターゲット位置に書き込むために使用されます。
    * `JdbcCursorItemReader` クラス：データベースからデータを読み取り、カーソル結果セットを返すために使用されます。
    * `Autowired` アノテーション：依存性注入を行うために使用されます。
    * `Bean` アノテーション：Beanの作成と設定に使用されます。
    * `ComponentScan` アノテーション：コンポーネントスキャンを行うパッケージまたはクラスを指定するために使用されます。
    * `Configuration` アノテーション：クラスを設定クラスとしてマークするために使用します。
    * `EnableAutoConfiguration` アノテーション：Spring Bootの自動設定を有効にするために使用されます。
    * `SpringBootApplication` アノテーション：このクラスをSpring Bootアプリケーションのエントリとしてマークするために使用されます。
    * `DataSource` インターフェース：データベースへの接続を表すために使用されます。

    **コード：**

    ```java
    import com.oceanbase.example.batch.model.People;
    import com.oceanbase.example.batch.model.PeopleDESC;
    import com.oceanbase.example.batch.processor.AddPeopleDescProcessor;
    import com.oceanbase.example.batch.writer.AddDescPeopleWriter;
    import org.springframework.batch.core.Job;
    import org.springframework.batch.core.Step;
    import org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;
    import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
    import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
    import org.springframework.batch.core.launch.support.RunIdIncrementer;
    import org.springframework.batch.item.ItemProcessor;
    import org.springframework.batch.item.ItemReader;
    import org.springframework.batch.item.ItemWriter;
    import org.springframework.batch.item.database.JdbcCursorItemReader;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
    import org.springframework.boot.autoconfigure.SpringBootApplication;
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.ComponentScan;
    import org.springframework.context.annotation.Configuration;
    import org.springframework.jdbc.core.BeanPropertyRowMapper;

    import javax.sql.DataSource;
    ```

2. `BatchConfig` クラスを定義します。

    シンプルなSpring Batchバッチ処理ジョブです。データの読み取り、処理、書き込みメソッドを定義し、これらのステップを1つのジョブとしてカプセル化します。Spring Batchのアノテーションと自動設定機能を使用して、設定クラスの各 `@Bean` メソッドで対応するコンポーネントインスタンスを作成し、`step1` でこれらのコンポーネントを使用してデータの読み取り、処理、書き込みを実行します。

    * `@Configuration` を使用して、このクラスが設定クラスであることを示します。
    * `@EnableBatchProcessing` を使用して、Spring Batchの処理機能を有効にします。このアノテーションは、必要な `bean`（`JobRepository`、`JobLauncher` など）を自動的に作成します。
    * `@SpringBootApplication` は、Spring Bootアプリケーションのメインクラスに使用されるアノテーションで、Spring Bootアプリケーションの起動ポイントです。
    * `@ComponentScan` を使用して、コンポーネントスキャンを行うパッケージを指定し、このパッケージとサブパッケージ内のすべてのコンポーネントをスキャンして登録するようSpringに指示します。
    * `@EnableAutoConfiguration` を使用して、Spring Bootアプリケーションのインフラストラクチャを自動設定します。

    **コード：**

    ```java
     @Configuration
     @EnableBatchProcessing
     @SpringBootApplication
     @ComponentScan("com.oceanbase.example.batch.writer")
     @EnableAutoConfiguration
     public class BatchConfig {
     }
     ```

   1. `@Autowired` アノテーションを定義します。

      `@Autowired` アノテーションを使用して、`JobBuilderFactory`、`StepBuilderFactory`、`DataSource` を `BatchConfig` クラスのメンバ変数に注入します。`JobBuilderFactory` は、ジョブ（Job）を作成および設定するためのファクトリクラスです。`StepBuilderFactory` は、ステップ（Step）を作成および設定するためのファクトリクラスです。`DataSource` は、データベース接続を取得するためのインターフェースです。

        **コード：**

        ```java
        @Autowired
        private JobBuilderFactory jobBuilderFactory;

        @Autowired
        private StepBuilderFactory stepBuilderFactory;

        @Autowired
        private DataSource dataSource;
        ```

   2. `@Bean` アノテーションを定義します。

      `@Bean` アノテーションを使用して、バッチ処理ジョブのリーダー、プロセッサ、ライター、ステップ、ジョブを作成するためのいくつかのメソッドを定義します。

      * `peopleReader` メソッドを使用して、`ItemReader` コンポーネントのインスタンスを作成します。このコンポーネントは、`JdbcCursorItemReader` を使用してデータベース内の `People` オブジェクトデータを読み取ります。データソース `dataSource` を設定します。データベース行を `People` オブジェクトにマッピングするために `RowMapper` を設定し、SQLクエリステートメントを `SELECT * FROM people` に設定します。
      * `addPeopleDescProcessor` メソッドを使用して、`ItemProcessor` コンポーネントのインスタンスを作成します。このコンポーネントは、`AddPeopleDescProcessor` を使用して `People` オブジェクトを処理し、`PeopleDESC` オブジェクトに変換して返します。
      * `addDescPeopleWriter` メソッドを使用して、`ItemWriter` コンポーネントのインスタンスを作成します。このコンポーネントは、`AddDescPeopleWriter` を使用して `PeopleDESC` オブジェクトをターゲット位置に書き込みます。
      * `step1` メソッドを使用して、`Step` コンポーネントのインスタンスを作成します。このステップの名前は `step1` です。`stepBuilderFactory.get` を使用してステップビルダーを取得し、リーダーを `ItemReader` コンポーネントに、プロセッサを `ItemProcessor` コンポーネントに、ライターを `ItemWriter` コンポーネントに設定します。`chunk` サイズを `10` に設定し、最後に `build` を呼び出すと、設定済みの `Step` をビルドして返します。
      * `importJob` メソッドを使用して、`Job` コンポーネントのインスタンスを作成します。このジョブの名前は `importJob` です。`jobBuilderFactory.get` を使用してジョブビルダーを取得し、インクリメンターを `RunIdIncrementer` に、ジョブ `flow` の最初のステップを `Step` に設定し、最後に `build` を呼び出すと、設定済みの `Job` をビルドして返します。

        **コード：**

        ```java
        @Bean
        public ItemReader<People> peopleReader() {
            JdbcCursorItemReader<People> reader = new JdbcCursorItemReader<>();
            reader.setDataSource((javax.sql.DataSource) dataSource);
            reader.setRowMapper(new BeanPropertyRowMapper<>(People.class));
            reader.setSql("SELECT * FROM people");
            return reader;
        }

        @Bean
        public ItemProcessor<People, PeopleDESC> addPeopleDescProcessor() {
            return new AddPeopleDescProcessor();
        }

        @Bean
        public ItemWriter<PeopleDESC> addDescPeopleWriter() {
            return new AddDescPeopleWriter();
        }

        @Bean
        public Step step1(ItemReader<People> reader, ItemProcessor<People, PeopleDESC> processor,
                        ItemWriter<PeopleDESC> writer) {
            return stepBuilderFactory.get("step1")
                    .<People, PeopleDESC>chunk(10)
                    .reader(reader)
                    .processor(processor)
                    .writer(writer)
                    .build();
        }

        @Bean
        public Job importJob(Step step1) {
            return jobBuilderFactory.get("importJob")
                    .incrementer(new RunIdIncrementer())
                    .flow(step1)
                    .end()
                    .build();
        }
        ```

### People.javaファイルの紹介

`People.java` ファイルは、人物の情報を表す `People` クラスのデータモデルを作成したものです。このクラスには、`name` と `age` の2つのプライベートメンバ変数と、対応する `getter` と `setter` メソッドが含まれます。最後に、オブジェクトの情報を出力するために `toString` メソッドをオーバーライドします。ここで、`name` は人の氏名、`age` は人の年齢を表します。`getter` および `setter` メソッドを使用して、これらのプロパティの値を取得および設定できます。

このクラスの役割は、バッチ処理プログラムの入力と出力に対し、データを格納および転送する方法を提供することです。バッチ処理の読み取りと書き込み操作では、`People` オブジェクトを使用してデータを格納し、`setter` メソッドでデータを設定、`getter` メソッドでデータを取得します。

**コード：**

```java
    public class People {
        private String name;
        private int age;

            // getters and setters

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public int getAge() {
            return age;
        }

        public void setAge(int age) {
            this.age = age;
        }
        @Override
        public String toString() {
            return "People [name=" + name + ", age=" + age + "]";
        }
        // Getters and setters
    }
```

### PeopleDESC.javaファイルの紹介

`PeopleDESC.java` ファイルは、人物の情報を表すために使用される `PeopleDESC` クラスのデータモデルを作成します。`PeopleDESC` クラスには4つのプロパティ（`name`、`age`、`desc`、`id`）があり、それぞれ人物の氏名、年齢、説明、識別子を表します。このクラスには、プロパティの値へのアクセスと設定を行うための `getter` および `setter` メソッドが含まれます。`toString` メソッドをオーバーライドして、氏名、年齢、説明を含むクラスの文字列表現を返します。

`People` クラスと同様に、`PeopleDESC` クラスもバッチ処理プログラムの入力と出力でデータを格納および転送するために使用されます。

**コード：**

```java
    public class PeopleDESC {
        private String name;
        private int age;
        private String desc;
        private int id;

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public int getAge() {
            return age;
        }

        public void setAge(int age) {
            this.age = age;
        }

        public String getDesc() {
            return desc;
        }

        public void setDesc(String desc) {
            this.desc = desc;
        }

        public int getId() {
            return id;
        }

        public void setId(int id) {
            this.id = id;
        }

        @Override
        public String toString() {
            return "PeopleDESC [name=" + name + ", age=" + age + ", desc=" + desc + "]";
        }
    }
```

### AddPeopleDescProcessor.javaファイルの紹介

`AddPeopleDescProcessor.java` ファイルは、`ItemProcessor` インターフェースを実装する `AddPeopleDescProcessor` という名前のクラスを定義し、`People` オブジェクトを `PeopleDESC` オブジェクトに変換するために使用されます。

`AddPeopleDescProcessor.java` ファイルのコードには、主に以下の部分が含まれます：

1. 他のクラスとインターフェースをインポートします。

    このファイルに以下のインターフェースとクラスが含まれていることを宣言します：

    * `People` クラス：データベースから読み取った人員情報を格納するために使用されます。
    * `PeopleDESC` クラス：人員情報を変換または処理した後の説明情報を格納するために使用されます。
    * `ItemProcessor` インターフェース：読み取ったアイテムを処理または変換するために使用されます。

    **コード：**

    ```java
    import com.oceanbase.example.batch.model.People;
    import com.oceanbase.example.batch.model.PeopleDESC;
    import org.springframework.batch.item.ItemProcessor;
    ```

2. `AddPeopleDescProcessor` クラスを定義します。

    `ItemProcessor` インターフェースの `AddPeopleDescProcessor` クラスは、`People` オブジェクトを `PeopleDESC` オブジェクトに変換するために使用されます。バッチ処理プロセスにおける入力データの処理ロジックを実装します。

    このクラスの `process` メソッドでは、最初に `PeopleDESC` オブジェクト `desc` を作成し、次に `item` パラメータから `People` オブジェクトのプロパティ（`name` と `age`）を取得し、これらのプロパティを `desc` オブジェクトに設定します。同時に、`desc` オブジェクトの `desc` プロパティにも値を代入します。代入ロジックは `People` オブジェクトのプロパティに基づいて説明情報を生成します。最後に、処理後の `PeopleDESC` オブジェクトを返します。

    **コード：**

    ```java
    public class AddPeopleDescProcessor implements ItemProcessor<People, PeopleDESC> {
        @Override
        public PeopleDESC process(People item) throws Exception {
            PeopleDESC desc = new PeopleDESC();
            desc.setName(item.getName());
            desc.setAge(item.getAge());
            desc.setDesc("This is " + item.getName() + " with age " + item.getAge());
            return desc;
        }
    }
     ```

### AddDescPeopleWriter.javaファイルの紹介

`AddDescPeopleWriter.java` ファイルは、`ItemWriter` インターフェースの `AddDescPeopleWriter` クラスを実装しており、`People` オブジェクトをデータベースに書き込むために使用されます。

`AddDescPeopleWriter.java` ファイルのコードには、主に以下の部分が含まれます：

1. 他のクラスとインターフェースをインポートします。

    このファイルに以下のインターフェースとクラスが含まれていることを宣言します：

    * `PeopleDESC` クラス：人員情報を変換または処理した後の説明情報を格納するために使用されます。
    * `ItemWriter` インターフェース：処理または変換後のアイテムを指定されたターゲット位置に書き込むために使用されます。
    * `Autowired` アノテーション：依存性注入を行うために使用されます。
    * `JdbcTemplate` クラス：SQLステートメントを実行するメソッドを提供します。
    * `List` インターフェース：クエリ結果セットを操作するために使用されます。

    **コード：**

    ```java
    import com.oceanbase.example.batch.model.PeopleDESC;
    import org.springframework.batch.item.ItemWriter;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.jdbc.core.JdbcTemplate;

    import java.util.List;
    ```

2. `AddDescPeopleWriter` クラスを定義します。

   1. `@Autowired` アノテーションを使用して、`JdbcTemplate` インスタンスを自動注入し、データ書き込み時にこのインスタンスを使用してデータベース操作を実行します。

        **コード：**

        ```java
            @Autowired
            private JdbcTemplate jdbcTemplate;
        ```

   2. `write` メソッドで、渡された `List<? extends PeopleDESC>` をイテレーションし、各 `PeopleDESC` オブジェクトを順番に取り出します。最初に、SQLステートメント `DROP TABLE people_desc` を実行して、既に存在する可能性のある `people_desc` という名前のテーブルを削除します。次に、SQLステートメント `CREATE TABLE people_desc (id INT PRIMARY KEY, name VARCHAR2(255), age INT, description VARCHAR2(255))` を実行して、`id`、`name`、`age`、`description` の4つの列を含む `people_desc` という名前のテーブルを作成します。その後、SQLステートメント `INSERT INTO people_desc (id, name, age, description) VALUES (?, ?, ?, ?)` を使用して、各 `PeopleDESC` オブジェクトのプロパティ値をそれぞれ `people_desc` テーブルに挿入します。

        **コード：**

        ```java
            @Override
            public void write(List<? extends PeopleDESC> items) throws Exception {
                // 存在する可能性のあるテーブルを削除する
                jdbcTemplate.execute("DROP TABLE people_desc");
                // テーブル作成ステートメント
                String createTableSql = "CREATE TABLE people_desc (id INT PRIMARY KEY, name VARCHAR2(255), age INT, description VARCHAR2(255))";
                jdbcTemplate.execute(createTableSql);
                for (PeopleDESC item : items) {
                    String sql = "INSERT INTO people_desc (id, name, age, description) VALUES (?, ?, ?, ?)";
                    jdbcTemplate.update(sql, item.getId(), item.getName(), item.getAge(), item.getDesc());
                }
            }
        ```

### AddPeopleWriter.javaファイルの紹介

`AddPeopleWriter.java` ファイルは、`ItemWriter` インターフェースの `AddDescPeopleWriter` クラスを実装しており、`PeopleDESC` オブジェクトをデータベースに書き込むために使用されます。

`AddPeopleWriter.java` ファイルのコードには、主に以下の部分が含まれます：

1. 他のクラスとインターフェースをインポートします。

    このファイルに以下のインターフェースとクラスが含まれていることを宣言します：

    * `People` クラス：データベースから読み取った人員情報を格納するために使用されます。
    * `ItemWriter` インターフェース：処理または変換後のアイテムを指定されたターゲット位置に書き込むために使用されます。
    * `Autowired` アノテーション：依存性注入を行うために使用されます。
    * `JdbcTemplate` クラス：SQLステートメントを実行するメソッドを提供します。
    * `Component` アノテーション：このクラスをSpringコンポーネントとしてマークするために使用されます。
    * `List` インターフェース：クエリ結果セットを操作するために使用されます。

    **コード：**

    ```java
    import com.oceanbase.example.batch.model.People;
    import org.springframework.batch.item.ItemWriter;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.jdbc.core.JdbcTemplate;
    import org.springframework.stereotype.Component;

    import java.util.List;
    ```

2. `AddPeopleWriter` クラスを定義します。

   1. `@Autowired` アノテーションを使用して、`JdbcTemplate` インスタンスを自動注入し、データ書き込み時にこのインスタンスを使用してデータベース操作を実行します。

        **コード：**

        ```java
            @Autowired
            private JdbcTemplate jdbcTemplate;
        ```

   2. `write` メソッドで、渡された `List<? extends People>` をイテレーションし、各 `People` オブジェクトを順番に取り出します。最初に、SQLステートメント `DROP TABLE people` を実行して、既に存在する可能性のある `people` という名前のテーブルを削除します。次に、SQLステートメント `CREATE TABLE people (name VARCHAR2(255), age INT)` を実行して、`name` と `age` の2つの列を含む `people` という名前のテーブルを作成します。その後、SQLステートメント `INSERT INTO people (name, age) VALUES (?, ?)` を使用して、各 `People` オブジェクトのプロパティ値をそれぞれ `people` テーブルに挿入します。

        **コード：**

        ```java
        @Override
        public void write(List<? extends People> items) throws Exception {
            // 存在する可能性のあるテーブルを削除する
            jdbcTemplate.execute("DROP TABLE people");
            // テーブル作成ステートメント
            String createTableSql = "CREATE TABLE people (name VARCHAR2(255), age INT)";
            jdbcTemplate.execute(createTableSql);
            for (People item : items) {
                String sql = "INSERT INTO people (name, age) VALUES (?, ?)";
                jdbcTemplate.update(sql, item.getName(), item.getAge());
            }
        }
        ```

### BatchConfigTest.javaファイルの紹介

`BatchConfigTest.java` ファイルは、JUnitを使用してテストを行うクラスで、Spring Batchのジョブ設定をテストするために使用されます。

`BatchConfigTest.java` ファイルのコードには、主に以下の部分が含まれます：

1. 他のクラスとインターフェースをインポートします。

    このファイルに以下のインターフェースとクラスが含まれていることを宣言します：

    * `Assert` クラス：テスト結果をアサートするために使用されます。
    * `Test` アノテーション：テストメソッドをマークするために使用されます。
    *`RunWith` アノテーション：テストランナーを指定するために使用されます。
    * `Job` インターフェース：バッチ処理ジョブを表します。
    * `JobExecution` クラス：バッチ処理ジョブの実行を表すために使用されます。
    * `JobParameters` クラス：バッチ処理ジョブのパラメータを表すために使用されます。
    * `JobParametersBuilder` クラス：バッチ処理ジョブのパラメータを構築するために使用されます。
    * `JobLauncher` インターフェース：バッチ処理ジョブを開始するために使用されます。
    * `Autowired` アノテーション：依存性注入を行うために使用されます。
    * `SpringBootTest` アノテーション：テストクラスをSpring Bootテストとして指定するために使用されます。
    * `SpringRunner` クラス：テストランナーをSpringRunnerとして指定するために使用されます。

    **コード：**

    ```java
    import org.junit.Assert;
    import org.junit.jupiter.api.Test;
    import org.junit.runner.RunWith;
    import org.springframework.batch.core.Job;
    import org.springframework.batch.core.JobExecution;
    import org.springframework.batch.core.JobParameters;
    import org.springframework.batch.core.JobParametersBuilder;
    import org.springframework.batch.core.launch.JobLauncher;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.test.context.SpringBootTest;
    import org.springframework.test.context.junit4.SpringRunner;

    import javax.batch.runtime.BatchStatus;
    ```

2. `BatchConfigTest` クラスを定義します。

   `SpringBootTest` アノテーションと `SpringRunner` ランナーを使用することで、Spring Bootの統合テストを実行できます。`testJob` メソッドにおいて、`JobLauncherTestUtils` ヘルパークラスを使用してバッチ処理ジョブを開始し、アサーションを使用してジョブの実行状態を検証します。

   1. `@Autowired` アノテーションを使用して `JobLauncherTestUtils` インスタンスを自動注入します。

        **コード：**

        ```java
        @Autowired
        private JobLauncherTestUtils jobLauncherTestUtils;
        ```

   2. `@Test` アノテーションを使用して、`testJob` メソッドをテストメソッドとしてマークします。このメソッドでは、最初に `JobParameters` オブジェクトを作成し、次に `jobLauncherTestUtils.launchJob` メソッドを使用してバッチ処理ジョブを開始します。また、`Assert.assertEquals` メソッドを使用して、ジョブの実行状態が `COMPLETED` であることのアサーションを行います。

        **コード：**

        ```java
        @Test
        public void testJob() throws Exception {
            JobParameters jobParameters = new JobParametersBuilder()
                    .addString("jobParam", "paramValue")
                    .toJobParameters();

            JobExecution jobExecution = jobLauncherTestUtils.launchJob(jobParameters);

            Assert.assertEquals(BatchStatus.COMPLETED, jobExecution.getStatus());
        }
        ```

   3. `@Autowired` アノテーションを使用して、`JobLauncher` インスタンスを自動注入します。

        **コード：**

        ```java
        @Autowired
        private JobLauncher jobLauncher;
        ```

   4. `@Autowired` アノテーションを使用して、`Job` インスタンスを自動注入します。

        **コード：**

        ```java
        @Autowired
        private Job job;
        ```

   5. バッチ処理ジョブの開始を補助するために、`JobLauncherTestUtils` という名前の内部クラスを定義します。このクラスでは、バッチ処理ジョブを開始するために `launchJob` メソッドを定義します。このメソッドでは、`jobLauncher.run` メソッドを使用してジョブを開始し、ジョブの実行結果を返します。

        **コード：**

        ```java
        private class JobLauncherTestUtils {
            public JobExecution launchJob(JobParameters jobParameters) throws Exception {
                return jobLauncher.run(job, jobParameters);
            }
        }
        ```

### AddPeopleDescProcessorTest.javaファイルの紹介

`AddPeopleDescProcessorTest.java` ファイルは、JUnitを使用してテストを行うクラスで、Spring Batchのジョブ設定をテストするために使用されます。

`AddPeopleDescProcessorTest.java` ファイルのコードには、主に以下の部分が含まれます：

1. 他のクラスとインターフェースをインポートします。

    このファイルに以下のインターフェースとクラスが含まれていることを宣言します：

    * `People` クラス：データベースから読み取った人員情報を格納するために使用されます。
    * `PeopleDESC` クラス：人員情報を変換または処理した後の説明情報を格納するために使用されます。
    * `Test` アノテーション：テストメソッドをマークするために使用されます。
    *`RunWith` アノテーション：テストランナーを指定するために使用されます。
    * `Autowired` アノテーション：依存性注入を行うために使用されます。
    * `SpringBootTest` アノテーション：テストクラスをSpring Bootテストとして指定するために使用されます。
    * `SpringRunner` クラス：テストランナーをSpringRunnerとして指定するために使用されます。

    **コード：**

    ```java
    import com.oceanbase.example.batch.model.People;
    import com.oceanbase.example.batch.model.PeopleDESC;
    import org.junit.jupiter.api.Test;
    import org.junit.runner.RunWith;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.test.context.SpringBootTest;
    import org.springframework.test.context.junit4.SpringRunner;
    ```

2. `AddPeopleDescProcessorTest` クラスを定義します。

   `SpringBootTest` アノテーションと `SpringRunner` ランナーを使用して、Spring Bootの統合テストを行います。

   1. `@Autowired` アノテーションを使用して、`AddPeopleDescProcessor` インスタンスを自動注入します。

      **コード：**

        ```java
        @Autowired
        private AddPeopleDescProcessor processor;
        ```

   2. `@Test` アノテーションを使用して、`testProcess` メソッドをテストメソッドとしてマークします。このメソッドでは、最初に `People` オブジェクトを作成し、次に `processor.process` メソッドを使用してそのオブジェクトを処理し、結果を `PeopleDESC` オブジェクトに代入します。

        **コード：**

        ```java
        @Test
        public void testProcess() throws Exception {
            People people = new People();
            PeopleDESC desc = processor.process(people);
        }
        ```

### AddDescPeopleWriterTest.javaファイルの紹介

`AddDescPeopleWriterTest.java` ファイルは、JUnitを使用してテストを行うクラスで、`AddDescPeopleWriter` の書き込みロジックをテストするために使用されます。

`AddDescPeopleWriterTest.java` ファイルのコードには、主に以下の部分が含まれます：

1. 他のクラスとインターフェースをインポートします。

    このファイルに以下のインターフェースとクラスが含まれていることを宣言します：

    * `PeopleDESC` クラス：人員情報を変換または処理した後の説明情報を格納するために使用されます。
    * `Assert` クラス：テスト結果をアサートするために使用されます。
    * `Test` アノテーション：テストメソッドをマークするために使用されます。
    *`RunWith` アノテーション：テストランナーを指定するために使用されます。
    * `Autowired` アノテーション：依存性注入を行うために使用されます。
    * `SpringBootTest` アノテーション：テストクラスをSpring Bootテストとして指定するために使用されます。
    * `JdbcTemplate` クラス：SQLステートメントを実行するメソッドを提供します。
    * `SpringRunner` クラス：テストランナーをSpringRunnerとして指定するために使用されます。
    * `ArrayList` クラス：空のリストを作成するために使用されます。
    * `List` インターフェース：クエリ結果セットを操作するために使用されます。

    **コード：**

    ```java
    import com.oceanbase.example.batch.model.PeopleDESC;
    import org.junit.Assert;
    import org.junit.jupiter.api.Test;
    import org.junit.runner.RunWith;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.test.context.SpringBootTest;
    import org.springframework.jdbc.core.JdbcTemplate;
    import org.springframework.test.context.junit4.SpringRunner;

    import java.util.ArrayList;
    import java.util.List;
    ```

2. `AddDescPeopleWriterTest` クラスを定義します。

   `SpringBootTest` アノテーションと `SpringRunner` ランナーを使用して、Spring Bootの統合テストを行います。

   1. `@Autowired` を使用して、インスタンスを注入します。
      `@Autowired` アノテーションを使用して、`AddPeopleDescProcessor` および `JdbcTemplate` インスタンスを自動注入します。

      **コード：**

        ```java
        @Autowired
        private AddDescPeopleWriter writer;
        @Autowired
        private JdbcTemplate jdbcTemplate;
        ```

   2. `@Test` を使用して、データの挿入と出力をテストします。
      `@Test` アノテーションを使用して、`testWrite` メソッドをテストメソッドとしてマークします。このメソッドでは、最初に空の `peopleDescList` リストを作成し、リストに2つの `PeopleDESC` オブジェクトを追加します。次に、`writer.write` メソッドを使用して、リスト内のデータをデータベースに書き込みます。その後、`jdbcTemplate` を使用してクエリステートメントを実行し、`people_desc` テーブル内のデータを取得します。また、アサーションステートメントを使用して、データの正確性を検証します。最後に、クエリ結果をコンソールに出力して、ジョブの実行完了メッセージを出力します。

      1. `people_desc` テーブルにデータを挿入します。
         最初に、空の `PeopleDESC` オブジェクトリスト `peopleDescList` を作成します。次に、2つの `PeopleDESC` オブジェクト `desc1` と `desc2` を作成し、それぞれのプロパティ値を設定します。`desc1` と `desc2` を `peopleDescList` リストに追加します。それから、`writer` の `write` メソッドを呼び出して、`peopleDescList` 内のオブジェクトをデータベースの `people_desc` テーブルに書き込みます。その後、`JdbcTemplate` を使用してクエリステートメント `SELECT COUNT(*) FROM people_desc` を実行し、`people_desc` テーブル内のレコード数を取得して、結果を変数 `count` に代入します。最後に、`Assert.assertEquals` メソッドを使用してアサーションを行い、`count` の値が `2` と等しいかどうかを検証します。

         **コード：**

         ```java
            List<PeopleDESC> peopleDescList = new ArrayList<>();
            PeopleDESC desc1 = new PeopleDESC();
            desc1.setId(1);
            desc1.setName("John");
            desc1.setAge(25);
            desc1.setDesc("This is John with age 25");
            peopleDescList.add(desc1);
            PeopleDESC desc2 = new PeopleDESC();
            desc2.setId(2);
            desc2.setName("Alice");
            desc2.setAge(30);
            desc2.setDesc("This is Alice with age 30");
            peopleDescList.add(desc2);
            writer.write(peopleDescList);

            String selectSql = "SELECT COUNT(*) FROM people_desc";
            int count = jdbcTemplate.queryForObject(selectSql, Integer.class);
            Assert.assertEquals(2, count);
         ```

      2. `people_desc` テーブルのデータを出力します。
         最初に、`JdbcTemplate` を使用してクエリステートメント `SELECT * FROM people_desc` を実行し、`lambda` 式を使用してクエリ結果を処理します。`lambda` 式では、`rs.getInt`、`rs.getString` などのメソッドを使用してクエリ結果セット内のフィールド値を取得し、フィールド値を新しく作成した `PeopleDESC` オブジェクトに設定します。新しく作成した各 `PeopleDESC` オブジェクトを結果リスト `resultDesc` に追加します。それから、プロンプトメッセージとして `people_desc テーブル内のデータ：` という1行を出力します。次に `for` ループを使用して `resultDesc` リスト内の各 `PeopleDESC` オブジェクトをイテレーションし、`System.out.println` を使用して各オブジェクトの内容を出力します。最後に、ジョブの実行完了メッセージを出力します。

         **コード：**

         ```java
         List<PeopleDESC> resultDesc = jdbcTemplate.query("SELECT * FROM people_desc", (rs, rowNum) -> {
            PeopleDESC desc = new PeopleDESC();
            desc.setId(rs.getInt("id"));
            desc.setName(rs.getString("name"));
            desc.setAge(rs.getInt("age"));
            desc.setDesc(rs.getString("description"));
            return desc;
         });

         System.out.println("people_descテーブル内のデータ：");
         for (PeopleDESC desc : resultDesc) {
            System.out.println(desc);
         }

         // ジョブの実行完了メッセージを出力
         System.out.println("Batch Job execution completed.");
         ```

### AddPeopleWriterTest.javaファイルの紹介

`AddPeopleWriterTest.java` ファイルは、JUnitを使用してテストを行うクラスで、`AddPeopleWriterTest` の書き込みロジックをテストするために使用されます。

`AddPeopleWriterTest.java` ファイルのコードには、主に以下の部分が含まれます：

1. 他のクラスとインターフェースをインポートします。

    このファイルに以下のインターフェースとクラスが含まれていることを宣言します：

    * `People` クラス：データベースから読み取った人員情報を格納するために使用されます。
    * `Test` アノテーション：テストメソッドをマークするために使用されます。
    *`RunWith` アノテーション：テストランナーを指定するために使用されます。
    * `Autowired` アノテーション：依存性注入を行うために使用されます。
    * `SpringBootApplication` アノテーション：このクラスをSpring Bootアプリケーションのエントリとしてマークするために使用されます。
    * `SpringBootTest` アノテーション：テストクラスをSpring Bootテストとして指定するために使用されます。
    * `ComponentScan` アノテーション：コンポーネントスキャンを行うパッケージまたはクラスを指定するために使用されます。
    * `JdbcTemplate` クラス：SQLステートメントを実行するメソッドを提供します。
    * `SpringRunner` クラス：テストランナーを `SpringRunner` として指定するために使用されます。
    * `ArrayList` クラス：空のリストを作成するために使用されます。
    * `List` インターフェース：クエリ結果セットを操作するために使用されます。

    **コード：**

    ```java
    import com.oceanbase.example.batch.model.People;
    import org.junit.jupiter.api.Test;
    import org.junit.runner.RunWith;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.autoconfigure.SpringBootApplication;
    import org.springframework.boot.test.context.SpringBootTest;
    import org.springframework.context.annotation.ComponentScan;
    import org.springframework.jdbc.core.JdbcTemplate;
    import org.springframework.test.context.junit4.SpringRunner;

    import java.util.ArrayList;
    import java.util.List;
    ```

2. `AddPeopleWriterTest` クラスを定義します。

   `SpringBootTest` アノテーションと `SpringRunner` ランナーを使用してSpring Bootの統合テストを実行し、`@ComponentScan` アノテーションを使用してスキャンするパッケージパスを指定します。

   1. `@Autowired` を使用して、インスタンスを注入します。
      `@Autowired` アノテーションを使用して、`addPeopleWriter` および `JdbcTemplate` インスタンスを自動注入します。

      **コード：**

        ```java
        @Autowired
        private AddPeopleWriter addPeopleWriter;
        @Autowired
        private JdbcTemplate jdbcTemplate;
        ```

   2. `@Test` を使用して、データの挿入と出力をテストします。

      1. `people` テーブルにデータを挿入します。
         最初に、空の `People` オブジェクトリスト `peopleList` を作成します。次に、2つの `People` オブジェクト `person1` と `person2` を作成し、それぞれの名前と年齢のプロパティを設定します。続いて、この2つの `People` オブジェクトを `peopleList` リストに追加します。その後、`addPeopleWriter` の `write` メソッドを呼び出して、`peopleList` をそのメソッドのパラメータとして渡し、これらの `People` オブジェクトをデータベースに書き込みます。

         **コード：**

         ```java
            List<People> peopleList = new ArrayList<>();
            People person1 = new People();
            person1.setName("zhangsan");
            person1.setAge(27);
            peopleList.add(person1);
            People person2 = new People();
            person2.setName("lisi");
            person2.setAge(35);
            peopleList.add(person2);
            addPeopleWriter.write(peopleList);
         ```

      2. `people` テーブルのデータを出力します。
         最初に、`JdbcTemplate` を使用してクエリステートメント `SELECT * FROM people` を実行し、`lambda` 式を使用してクエリ結果を処理します。`lambda` 式では、`rs.getString` と `rs.getInt` メソッドを使用してクエリ結果セット内のフィールド値を取得し、フィールド値を新しく作成した `People` オブジェクトに設定します。新しく作成した各 `People` オブジェクトを結果リスト `result` に追加します。続いて、プロンプトメッセージとして `peopleテーブル内のデータ：` という1行を出力します。それから、`for` ループを使用して `result` リスト内の各 `People` オブジェクトをイテレーションし、`System.out.println` を使用して各オブジェクトの内容を出力します。最後に、ジョブの実行完了メッセージを出力します。

         **コード：**

         ```java
            List<People> result = jdbcTemplate.query("SELECT * FROM people", (rs, rowNum) -> {
                People person = new People();
                person.setName(rs.getString("name"));
                person.setAge(rs.getInt("age"));
                return person;
            });

            System.out.println("peopleテーブル内のデータ：");
            for (People person : result) {
                System.out.println(person);
            }

            // ジョブの実行完了メッセージを出力
            System.out.println("Batch Job execution completed.");
         ```

### 全コード表示

:::tab
tab pom.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.7.11</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.oceanbase</groupId>
    <artifactId>java-oceanbase-springboot</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>java-oceanbase-springbatch</name>
    <description>Demo project for Spring Batch</description>
    <properties>
        <java.version>1.8</java.version>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>
        <dependency>
            <groupId>com.oceanbase</groupId>
            <artifactId>oceanbase-client</artifactId>
            <version>2.4.3</version>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-jdbc</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-batch</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.apache.tomcat</groupId>
            <artifactId>tomcat-jdbc</artifactId>
        </dependency>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.10</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>javax.activation</groupId>
            <artifactId>javax.activation-api</artifactId>
            <version>1.2.0</version>
        </dependency>
        <dependency>
            <groupId>jakarta.persistence</groupId>
            <artifactId>jakarta.persistence-api</artifactId>
            <version>2.2.3</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>

```

tab application.properties

```properties
#configuration database

spring.datasource.driver-class-name=com.oceanbase.jdbc.Driver
spring.datasource.url=jdbc:oceanbase://host:port/schema_name?characterEncoding=utf-8
spring.datasource.username=user_name
spring.datasource.password=

# JPA
spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=update

# Spring Batch
spring.batch.job.enabled=false

#
logging.level.org.springframework=INFO
logging.level.com.example=DEBUG
```

tab BatchApplication.java

```java
package com.oceanbase.example.batch;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class BatchApplication {
    public static void main(String[] args) {
        SpringApplication.run(BatchApplication.class, args);
    }

    public void runBatchJob() {
    }
}

```

tab BatchConfig.java

```java
package com.oceanbase.example.batch.config;

import com.oceanbase.example.batch.model.People;
import com.oceanbase.example.batch.model.PeopleDESC;
import com.oceanbase.example.batch.processor.AddPeopleDescProcessor;
import com.oceanbase.example.batch.writer.AddDescPeopleWriter;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;
import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.batch.core.launch.support.RunIdIncrementer;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.batch.item.ItemReader;
import org.springframework.batch.item.ItemWriter;
import org.springframework.batch.item.database.JdbcCursorItemReader;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.BeanPropertyRowMapper;

import javax.sql.DataSource;
//import javax.activation.DataSource;

@Configuration
@EnableBatchProcessing
@SpringBootApplication
@ComponentScan("com.oceanbase.example.batch.writer")
@EnableAutoConfiguration
public class BatchConfig {
    @Autowired
    private JobBuilderFactory jobBuilderFactory;

    @Autowired
    private StepBuilderFactory stepBuilderFactory;

    @Autowired
    private DataSource dataSource; // Spring Bootの自動設定で提供されるデフォルトのdataSourceを使用



    @Bean
    public ItemReader<People> peopleReader() {
        JdbcCursorItemReader<People> reader = new JdbcCursorItemReader<>();
        reader.setDataSource((javax.sql.DataSource) dataSource);
        reader.setRowMapper(new BeanPropertyRowMapper<>(People.class));
        reader.setSql("SELECT * FROM people");
        return reader;
    }

    @Bean
    public ItemProcessor<People, PeopleDESC> addPeopleDescProcessor() {
        return new AddPeopleDescProcessor();
    }

    @Bean
    public ItemWriter<PeopleDESC> addDescPeopleWriter() {
        return new AddDescPeopleWriter();
    }

    @Bean
    public Step step1(ItemReader<People> reader, ItemProcessor<People, PeopleDESC> processor,
                      ItemWriter<PeopleDESC> writer) {
        return stepBuilderFactory.get("step1")
                .<People, PeopleDESC>chunk(10)
                .reader(reader)
                .processor(processor)
                .writer(writer)
                .build();
    }

    @Bean
    public Job importJob(Step step1) {
        return jobBuilderFactory.get("importJob")
                .incrementer(new RunIdIncrementer())
                .flow(step1)
                .end()
                .build();
    }
}
```

tab People.java

```java
package com.oceanbase.example.batch.model;

public class People {
    private String name;
    private int age;

        // getters and setters

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
    @Override
    public String toString() {
        return "People [name=" + name + ", age=" + age + "]";
    }
    // Getters and setters
}
```

tab PeopleDESC.java

```java
package com.oceanbase.example.batch.model;

public class PeopleDESC {
    private String name;
    private int age;
    private String desc;
    private int id;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getDesc() {
        return desc;
    }

    public void setDesc(String desc) {
        this.desc = desc;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    @Override
    public String toString() {
        return "PeopleDESC [name=" + name + ", age=" + age + ", desc=" + desc + "]";
    }
}
```

tab AddPeopleDescProcessor.java

```java
package com.oceanbase.example.batch.processor;

import com.oceanbase.example.batch.model.People;
import com.oceanbase.example.batch.model.PeopleDESC;
import org.springframework.batch.item.ItemProcessor;


public class AddPeopleDescProcessor implements ItemProcessor<People, PeopleDESC> {
    @Override
    public PeopleDESC process(People item) throws Exception {
        PeopleDESC desc = new PeopleDESC();
        desc.setName(item.getName());
        desc.setAge(item.getAge());
        desc.setDesc("This is " + item.getName() + " with age " + item.getAge());
        return desc;
    }
}
```

tab AddDescPeopleWriter.java

```java
package com.oceanbase.example.batch.writer;

import com.oceanbase.example.batch.model.PeopleDESC;
import org.springframework.batch.item.ItemWriter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;

import java.util.List;

public class AddDescPeopleWriter implements ItemWriter<PeopleDESC> {
    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Override
    public void write(List<? extends PeopleDESC> items) throws Exception {
        // 存在する可能性のあるテーブルを削除する
        jdbcTemplate.execute("DROP TABLE people_desc");
        // テーブル作成ステートメント
        String createTableSql = "CREATE TABLE people_desc (id INT PRIMARY KEY, name VARCHAR2(255), age INT, description VARCHAR2(255))";
        jdbcTemplate.execute(createTableSql);
        for (PeopleDESC item : items) {
            String sql = "INSERT INTO people_desc (id, name, age, description) VALUES (?, ?, ?, ?)";
            jdbcTemplate.update(sql, item.getId(), item.getName(), item.getAge(), item.getDesc());
        }
    }
}
```

tab AddPeopleWriter.java

```java
package com.oceanbase.example.batch.writer;

import com.oceanbase.example.batch.model.People;
import org.springframework.batch.item.ItemWriter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

import java.util.List;

@Component
public class AddPeopleWriter implements ItemWriter<People> {
    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Override
    public void write(List<? extends People> items) throws Exception {
        // 存在する可能性のあるテーブルを削除する
        jdbcTemplate.execute("DROP TABLE people");
        // テーブル作成ステートメント
        String createTableSql = "CREATE TABLE people (name VARCHAR2(255), age INT)";
        jdbcTemplate.execute(createTableSql);
        for (People item : items) {
            String sql = "INSERT INTO people (name, age) VALUES (?, ?)";
            jdbcTemplate.update(sql, item.getName(), item.getAge());
        }
    }
}

```

tab BatchConfigTest.java

```java
package com.oceanbase.example.batch.config;

import org.junit.Assert;
import org.junit.jupiter.api.Test;
import org.junit.runner.RunWith;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobParameters;
import org.springframework.batch.core.JobParametersBuilder;
import org.springframework.batch.core.launch.JobLauncher;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

import javax.batch.runtime.BatchStatus;

@RunWith(SpringRunner.class)
@SpringBootTest
public class BatchConfigTest {
    @Autowired
    private JobLauncherTestUtils jobLauncherTestUtils;

    @Test
    public void testJob() throws Exception {
        JobParameters jobParameters = new JobParametersBuilder()
                .addString("jobParam", "paramValue")
                .toJobParameters();

        JobExecution jobExecution = jobLauncherTestUtils.launchJob(jobParameters);

        Assert.assertEquals(BatchStatus.COMPLETED, jobExecution.getStatus());
    }

    @Autowired
    private JobLauncher jobLauncher;

    @Autowired
    private Job job;

    private class JobLauncherTestUtils {
        public JobExecution launchJob(JobParameters jobParameters) throws Exception {
            return jobLauncher.run(job, jobParameters);
        }
    }
}
```

tab AddPeopleDescProcessorTest.java

```java
package com.oceanbase.example.batch.processor;

import com.oceanbase.example.batch.model.People;
import com.oceanbase.example.batch.model.PeopleDESC;
import org.junit.jupiter.api.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

@RunWith(SpringRunner.class)
@SpringBootTest
public class AddPeopleDescProcessorTest {
    @Autowired
    private AddPeopleDescProcessor processor;

    @Test
    public void testProcess() throws Exception {
        People people = new People();
  //      people.setName("John");
  //      people.setAge(25);

        PeopleDESC desc = processor.process(people);

//      Assert.assertEquals("John", desc.getName());
//        Assert.assertEquals(25, desc.getAge());
 //       Assert.assertEquals("This is John with age 25", desc.getDesc());
    }
}

```

tab AddDescPeopleWriterTest.java

```java
package com.oceanbase.example.batch.writer;

import com.oceanbase.example.batch.model.PeopleDESC;
import org.junit.Assert;
import org.junit.jupiter.api.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.test.context.junit4.SpringRunner;

import java.util.ArrayList;
import java.util.List;

@RunWith(SpringRunner.class)
@SpringBootTest
public class AddDescPeopleWriterTest {
    @Autowired
    private AddDescPeopleWriter writer;
    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Test
    public void testWrite() throws Exception {


        // people_descテーブルにデータを挿入
        List<PeopleDESC> peopleDescList = new ArrayList<>();
        PeopleDESC desc1 = new PeopleDESC();
        desc1.setId(1);
        desc1.setName("John");
        desc1.setAge(25);
        desc1.setDesc("This is John with age 25");
        peopleDescList.add(desc1);
        PeopleDESC desc2 = new PeopleDESC();
        desc2.setId(2);
        desc2.setName("Alice");
        desc2.setAge(30);
        desc2.setDesc("This is Alice with age 30");
        peopleDescList.add(desc2);
        writer.write(peopleDescList);

        String selectSql = "SELECT COUNT(*) FROM people_desc";
        int count = jdbcTemplate.queryForObject(selectSql, Integer.class);
        Assert.assertEquals(2, count);

        // people_descテーブルのデータを出力
        List<PeopleDESC> resultDesc = jdbcTemplate.query("SELECT * FROM people_desc", (rs, rowNum) -> {
            PeopleDESC desc = new PeopleDESC();
            desc.setId(rs.getInt("id"));
            desc.setName(rs.getString("name"));
            desc.setAge(rs.getInt("age"));
            desc.setDesc(rs.getString("description"));
            return desc;
        });

        System.out.println("people_descテーブル内のデータ：");
        for (PeopleDESC desc : resultDesc) {
            System.out.println(desc);
        }

        // ジョブの実行完了メッセージを出力
        System.out.println("Batch Job execution completed.");
    }
}
```

tab AddPeopleWriterTest.java

```java
package com.oceanbase.example.batch.writer;

import com.oceanbase.example.batch.model.People;
import org.junit.jupiter.api.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.test.context.junit4.SpringRunner;

import java.util.ArrayList;
import java.util.List;

@RunWith(SpringRunner.class)
@SpringBootTest
@SpringBootApplication
@ComponentScan("com.oceanbase.example.batch.writer")
public class AddPeopleWriterTest {

    @Autowired
    private AddPeopleWriter addPeopleWriter;
    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Test
    public void testWrite() throws Exception {
        // peopleテーブルにデータを挿入
        List<People> peopleList = new ArrayList<>();
        People person1 = new People();
        person1.setName("zhangsan");
        person1.setAge(27);
        peopleList.add(person1);
        People person2 = new People();
        person2.setName("lisi");
        person2.setAge(35);
        peopleList.add(person2);
        addPeopleWriter.write(peopleList);

        // クエリの実行と結果を出力
        List<People> result = jdbcTemplate.query("SELECT * FROM people", (rs, rowNum) -> {
            People person = new People();
            person.setName(rs.getString("name"));
            person.setAge(rs.getInt("age"));
            return person;
        });

        System.out.println("peopleテーブル内のデータ：");
        for (People person : result) {
            System.out.println(person);
        }

        // ジョブの実行完了メッセージを出力
        System.out.println("Batch Job execution completed.");
    }
}

```

:::

## 関連ドキュメント

その他のOceanBase Connector/Jに関する情報は、[OceanBase JDBCドライバー](https://en.oceanbase.com/docs/common-oceanbase-connector-j-en)を参照してください。
