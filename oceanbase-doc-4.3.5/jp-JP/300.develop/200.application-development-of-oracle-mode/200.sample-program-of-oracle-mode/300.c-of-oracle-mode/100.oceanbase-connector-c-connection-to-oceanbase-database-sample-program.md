|description||
|---|---|
|keywords||
|dir-name|OceanBase Connector/C|
|dir-name-en||
|tenant-type|Oracle Mode|

# OceanBase Connector/C

本記事では、OceanBase Connector/CとOceanBaseデータベースを使用してアプリケーションを構築し、テーブルの作成、データの挿入、データのクエリなどの基本操作を実装する方法について説明します。

<div role="videolist">
      <a role='link' href='https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/demo/C%26C%2B%2B/vs-c-ob-capi/c-oceanbase-capi.zip'>
          <img src='https://file.oceanbase.com/doc/img/lQLPJyFovGIOcJQWFrAqhLlgRRsPvwU-H7hJ_i0A_22_22.png'/>
          クリックしてc-oceanbase-capiサンプルプロジェクトをダウンロード
      </a>
      <!-- <a role='video' href='https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/video-center/video/video/06%20c-oceanbase-capi.mp4'>
          <img src='https://mdn.alipayobjects.com/huamei_22khvb/afts/img/A*DFPmToHK6hgAAAAAAAAAAAAADiGDAQ/original'/>
          OceanBase Connector/C 连接 OceanBase 数据库示例程序（Oracle 模式）
      </a> -->
</div>

## 前提条件

* OceanBaseデータベースがインストール済みで、Oracleモードのユーザーテナントが作成済みであること。OceanBaseデータベースのインストールの詳細については、[デプロイの概要](../../../../400.deploy/100.deploy-overview.md)を参照してください。
* OceanBase Connector/Cドライバーがインストール済みであること。OceanBase Connector/CドライバープログラムのWindows版のインストールパッケージを入手するには、テクニカルサポートにお問い合わせください。
* Visual Studioがインストール済みであること。

## 操作手順

<main id="notice" type='explain'>
  <h4>説明</h4>
  <p>本記事で示されている操作手順は、Windows環境下でVisual Studio Community 2019を使用して、このプロジェクトをコンパイルおよび実行する方法です。他のOS環境やコンパイラを使用している場合は、操作手順が若干異なる場合があります。</p>
</main>

1. `c-oceanbase-capi` プロジェクトを開きます。
2. `c-oceanbase-capi` プロジェクトのプロパティを設定します。
3. OceanBaseデータベースの接続情報を取得します。
4. `c-oceanbase-capi` プロジェクト内のデータベース接続情報を修正します。
5. プロジェクトをビルドします。
6. アプリケーションを実行します。
7. 出力結果を確認します。

### ステップ１：c-oceanbase-capiプロジェクトを開く

1. Visual Studio Community 2019を起動します。

2. 既存のプロジェクトを開きます。

   1. Visual Studio Community 2019の開始画面で、「使用を開始する」の下にある **プロジェクトまたはソリューションを開く(P)** ボタンをクリックします。または、Visual Studio Community 2019の開始画面で、「使用を開始する」の下にある **コードなしで続行(W)** ボタンをクリックするか、上部のメニューバーから **ファイル** -> **開く** -> **プロジェクト / ソリューション(P)** を選択します。

      <!-- ![1](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/demo/C%26C%2B%2B/vs-c-ob-capi/1%E6%89%93%E5%BC%80%E9%A1%B9%E7%9B%AE.png) -->

   2. **c-oceanbase-capi プロジェクト** のフォルダに移動し、プロジェクトファイル（`c-oceanbase-capi.sln` または `c-oceanbase-capi.vcxproj`）を選択して、**開く** をクリックします。

      <!-- ![2](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/demo/C%26C%2B%2B/vs-c-ob-capi/1%E6%89%93%E5%BC%80%E9%A1%B9%E7%9B%AE_%E9%80%89%E6%8B%A9%E9%A1%B9%E7%9B%AE.png) -->

### ステップ2：c-oceanbase-capiプロジェクトのプロパティの設定

1. プロジェクトのプロパティページを開きます。

    **ソリューションエクスプローラー** で選択したプロジェクトを右クリックし、コンテキストメニューで **プロパティ** を選択するか、Visual Studioの上部メニューバーで **プロジェクト** -> **プロパティ** を選択するか、ショートカットキー <kbd>Alt</kbd> + <kbd>Enter</kbd> を使用します。

2. 構成マネージャーの設定を行います。

   1. プロパティページで、上部にある **設定(C)** ドロップダウンメニューを選択します。ドロップダウンメニューで、**Debug** を選択します。

   2. プロパティページで、上部にある **プラットフォーム(P)** のドロップダウンメニューを選択します。ドロップダウンメニューで、**x64** を選択します。

   <!-- ![3](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/demo/C%26C%2B%2B/vs-c-ob-capi/4%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E5%99%A8.png) -->

3. コンパイラのヘッダーファイルのパスを設定します。

    プロパティページで **VC++ディレクトリ** タブを選択し、**インクルードディレクトリ**の項目を見つけて、OceanBase Connector/Cライブラリのヘッダーファイルのパスを追加します。

    <!-- ![4](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/demo/C%26C%2B%2B/vs-c-ob-capi/2%E5%AF%BC%E5%85%A5%E5%8C%85%E5%90%AB%E7%9B%AE%E5%BD%95.png) -->

4. コンパイラのリンクライブラリパスを設定します。

    プロパティページで **VC++ディレクトリ** タブを選択し、**ライブラリディレクトリ** の項目を見つけて、OceanBase Connector/Cライブラリのリンクライブラリのパスを追加します。

    <!-- ![5](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/demo/C%26C%2B%2B/vs-c-ob-capi/3%E5%AF%BC%E5%85%A5%E5%BA%93%E7%9B%AE%E5%BD%95.png) -->

5. 文字セットの設定を行います。

    プロパティページで **詳細設定** タブを選択し、**文字セット** 項目を見つけます。ドロップダウンメニューで **マルチバイト文字セットを使用する** を選択します。

    <!-- ![6](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/demo/C%26C%2B%2B/vs-c-ob-capi/5%E5%AD%97%E7%AC%A6%E9%9B%86%E8%AE%BE%E7%BD%AE.png) -->

### ステップ3：OceanBaseデータベース接続情報を取得する

OceanBaseデータベースのデプロイ担当者または管理者から、該当するデータベース接続文字列を取得します。

**例：**

```shell
obclient -hxxx.xxx.xxx.xxx -P2881 -usys@oracle001 -p******
```

**パラメータの説明：**

* `-h`：OceanBaseデータベースの接続IPアドレスを提供します。ODP接続方式ではODPアドレスを使用し、直接接続方式ではOBServerノードのIPアドレスを使用します。
* `-P`：OceanBaseデータベースの接続ポートを提供します。ODP接続方式のデフォルトポートは `2883` で、ODPデプロイ時にカスタマイズすることができます。直接接続方式のデフォルトポートは `2881` で、OceanBaseデータベースのデプロイ時にカスタマイズすることができます。
* `-u`：テナントの接続アカウント。ODP接続の一般的な形式：`ユーザー名@テナント名#クラスタ名`または`クラスタ名:テナント名:ユーザー名`。直接接続方式の形式：`ユーザー名@テナント名`。
* `-p`：アカウントのパスワード。

その他の接続文字列の詳細については、[OBClientを使用してOceanBaseテナントに接続する](../../100.connect-to-oceanbase-database-of-oracle-mode/200.connect-to-an-oceanbase-tenant-by-using-obclient-of-oracle-mode.md)を参照してください。

### ステップ4：c-oceanbase-capiプロジェクト内のデータベース接続情報の修正

**ステップ3：OceanBaseデータベース接続情報を取得する** に記載されている情報に基づいて、`test_tbl1.cpp` ファイル内のデータベース接続情報を修正します。

**例：**

```c
if (NULL == mysql_real_connect(&con_oboracle, "xxx.xxx.xxx.xxx", "sys@oracle001", "******", "sys", 2881, NULL, 0))
```

<!-- ![6](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/demo/C%26C%2B%2B/vs-c-ob-capi/6%E8%BF%9E%E6%8E%A5%E4%BF%A1%E6%81%AF.png) -->

### ステップ5：プロジェクトをビルドする

**ビルド** メニューを選択し、**ソリューションのビルド** を選択します。ビルドプロセス中にコンパイラの出力とエラーや警告情報が表示されます。

<!-- ![7](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/demo/C%26C%2B%2B/vs-c-ob-capi/7%E7%94%9F%E6%88%90%E6%88%90%E5%8A%9F.png) -->

### ステップ6：アプリケーションの実行

**デバッグ** メニューを選択し、**デバッグの開始** または **デバッグなしで開始** を選択してアプリケーションを実行します。

### ステップ7：出力結果を確認する

出力結果はデバッグコンソールに表示されます。プログラムの設計ロジックとコードに基づいて、出力の処理方法を判断できます。

<!-- ![8](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/demo/C%26C%2B%2B/vs-c-ob-capi/8%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C.png) -->

## プロジェクトコードについて

[c-oceanbase-capi](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/demo/C%26C%2B%2B/vs-c-ob-capi/c-oceanbase-capi.zip) をクリックしてプロジェクトコードをダウンロードします。これは、`c-oceanbase-capi.zip` という名前の圧縮ファイルです。

解凍すると、`c-oceanbase-capi` という名前のフォルダが作成されます。ディレクトリ構造は以下のとおりです：

```shell
c-oceanbase-capi
├─ c-oceanbase-capi.sln
├─ c-oceanbase-capi.vcxproj
├─ c-oceanbase-capi.vcxproj.filters
├─ c-oceanbase-capi.vcxproj.user
└─ test_tbl1.cpp
```

**ファイルの説明：**

* `c-oceanbase-capi.sln`：Visual Studioのソリューションファイルです。1つまたは複数のプロジェクトを管理するために使用されます。
* `c-oceanbase-capi.vcxproj`：Visual Studioのプロジェクトファイルです。C/C++プロジェクトの構造と設定を記述するために使用されます。
* `c-oceanbase-capi.vcxproj.filters`：Visual Studioのプロジェクトフィルターファイルです。プロジェクト内のファイルのディレクトリ構造と編成方法を定義するために使用されます。
* `c-oceanbase-capi.vcxproj.user`：ユーザー固有のプロジェクト設定を格納するファイルです。
* `test_tbl1.cpp`：データテーブルの構造を定義し、データテーブル操作を実装したソースコードファイルです。

### test_tbl1.cppファイルのコード解説

`test_tbl1.cpp` ファイルは、`test_tbl1` という名前のデータテーブルを定義するために使用され、データテーブルの作成、データの挿入、クエリの操作を実装しています。

本記事の `test_tbl1.cpp` ファイルのコードには、主に以下の部分が含まれています：

1. ヘッダーファイルとライブラリファイルをインポートします。

   * ヘッダーファイル `stdio.h`、`stdlib.h`、`mysql.h` をインポートします。
   * リンカーが特定のライブラリファイル `Shlwapi.lib`、`ws2_32.lib`、`Crypt32.lib`、`Secur32.lib`、および `obclnt.lib` をリンクする必要があることを指定します。これらのライブラリファイルは、Windows APIライブラリ、WinSockライブラリ、暗号化ライブラリ、セキュリティライブラリ、およびOceanBaseデータベースクライアントライブラリです。

   **コード：**

   ```c
   #include <stdio.h>
   #include <stdlib.h>
   #include <mysql.h>
   #pragma comment(lib, "Shlwapi.lib")
   #pragma comment( lib, "ws2_32.lib" )
   #pragma comment(lib, "Crypt32.lib")
   #pragma comment(lib, "Secur32.lib")
   #pragma comment(lib, "obclnt.lib")
   ```

2. `main` 関数を定義します。

    プログラムのエントリポイントとなる関数 `main` を定義し、整数値を返します。`main` 関数内には、データベース接続とデータ操作の関連コードを記述します。

    **コード：**

    ```c
    int main() {
        // 接続インスタンスオブジェクトの作成
        // データベースへの接続
        // テーブルの作成
        // データの挿入
        // データのクエリ
        // ...
    }
    ```

3. 変数と配列を宣言します。

   * MYSQL型の `con_oboracle` という変数を宣言します。この変数を宣言することで、接続インスタンスを作成できます。
   * 長さが `1024` の `sql_str` という文字配列を宣言し、`{ 0 }` で初期化します。この配列は、SQLクエリステートメントを格納するために使用されます。

   **コード：**

   ```c
       MYSQL con_oboracle;
       char sql_str[1024] = { 0 };
   ```

4. 接続インスタンスオブジェクトを初期化します。

    接続オブジェクト `con_oboracle` を初期化し、その結果に基づいて適切な処理を行います。初期化に失敗した場合、エラーメッセージを出力して非ゼロ値を返します。初期化に成功した場合、成功メッセージを出力し、以降の処理を実行します。具体的な手順は以下のとおりです：

   1. `mysql_init()` 関数を呼び出して、接続オブジェクト `con_oboracle` を初期化します。この関数は、初期化された接続オブジェクトへのポインタを返します。初期化に失敗した場合は `NULL` を返します。`NULL` は、ヌルポインタを表すマクロです。`NULL` と `mysql_init()` の戻り値を比較して、初期化に成功したかどうかを判断します。

      1. `fprintf()` 関数は、エラーメッセージを標準エラーストリーム `stderr` に出力するために使用されます。`fprintf()` 関数の最初のパラメータは出力ストリーム、`"Error: %s\n"` はフォーマット文字列、`mysql_error(&con_oboracle)` はフォーマット文字列中の `%s` を置き換えるための実際のパラメータです。`mysql_error(&con_oboracle)` は、接続オブジェクト `con_oboracle` を取得する時のエラー情報です。

      2. 初期化に失敗した場合、`return 1` を使用して `main` 関数から非ゼロ値を返して終了します。この値はプログラムの異常終了または初期化失敗の状態を表すために使用できます。

   2. 初期化に成功した場合、成功メッセージを出力します。これにより、コンソールで接続オブジェクトの初期化に成功したかどうかを確認できます。

    **コード：**

    ```c
        if (NULL == mysql_init(&con_oboracle)) {
            fprintf(stderr, "Error: %s\n", mysql_error(&con_oboracle));
            return 1;
        }
        printf("mysql_init() success\n");
    ```

5. データベースに接続します。

    プログラムでデータベースへの接続を試み、接続結果に基づいて適切な処理を行います。接続に失敗した場合、エラーメッセージを出力して非ゼロ値を返します。接続に成功した場合、成功メッセージを出力して、以降の処理を実行します。具体的な手順は以下のとおりです：

    1. `mysql_real_connect()` 関数を呼び出してデータベースに接続します。この関数は、接続されたオブジェクトへのポインタを返します。接続に失敗した場合は `NULL` を返します。

       1. `fprintf()` 関数は、エラーメッセージを標準エラーストリーム `stderr` に出力するために使用されます。`fprintf()` 関数の最初のパラメータは出力ストリーム、`"Error: %s\n"` はフォーマット文字列、`mysql_error(&con_oboracle)` はフォーマット文字列中の `%s` を置き換えるための実際のパラメータです。`mysql_error(&con_oboracle)` は、接続オブジェクト `con_oboracle` を取得する時のエラー情報です。

       2. 接続に失敗した場合、`return 1` を使用して `main` 関数から非ゼロ値を返して終了します。この値は、プログラムの異常終了または接続失敗の状態を表すために使用できます。

    2. 接続に成功した場合、成功メッセージを出力します。これにより、コンソールでデータベースへの接続に成功したかどうかを確認できます。

    **コード：**

    ```c
        if (NULL == mysql_real_connect(&con_oboracle, "your_ip", "your_user", "your_password", "your_schema", your_port, NULL, 0)) {
            fprintf(stderr, "Error: %s\n", mysql_error(&con_oboracle));
            return 1;
        }
        printf("mysql_real_connect() success\n");
    ```

    **OceanBaseデータベースへの接続に必要なパラメータの説明：**

    * `your_ip`：OceanBaseデータベースの接続IPアドレスを提供します。ODP接続方式ではODPアドレスを使用し、直接接続方式ではOBServerノードのIPアドレスを使用します。

    * `your_user`：テナントの接続アカウント。ODP接続方式の形式：`ユーザー名@テナント名#クラスタ名` または `クラスタ名:テナント名:ユーザー名`。直接接続方式の形式：`ユーザー名@テナント名`。

    * `your_password`：アカウントのパスワード。

    * `your_schema`：アクセスするスキーマ名です。

    * `your_port`：OceanBaseデータベースの接続ポートを提供します。ODP接続方式のデフォルトポートは `2883` で、ODPデプロイ時にカスタマイズすることができます。直接接続方式のデフォルトポートは `2881` で、OceanBaseデータベースのデプロイ時にカスタマイズすることができます。

6. テーブルを作成します。

    SQLクエリステートメントを実行してテーブルを作成します。テーブルの作成に成功した場合、成功メッセージを出力します。テーブルの作成に失敗した場合、エラーメッセージを出力してプログラムを終了します。具体的な手順は以下のとおりです：

    1. `sprintf_s()` 関数を使用して、SQLクエリ文字列をフォーマットし、`sql_str` 文字配列に格納します。このSQLクエリステートメントは、`id`（主キー）、`name` および `age` という列を含む `test_tbl1` という名前のテーブルを作成するために使用されます。

    2. `mysql_query()` 関数を使用してSQLクエリステートメントを実行します。`&con_oboracle` は、データベース接続オブジェクトへのポインタで、クエリ操作の対象となる接続オブジェクトを指定するために使用されます。`sql_str` は実行するクエリステートメントです。次に、クエリの実行に成功したかどうかを確認します。クエリの実行に失敗した場合（戻り値が0でない場合）、以下のコードブロックを実行します。

       1. `fprintf()` 関数は、エラーメッセージを標準エラーストリーム `stderr` に出力するために使用されます。`fprintf()` 関数の最初のパラメータは出力ストリーム、`"Error: %s\n"` はフォーマット文字列、`mysql_error(&con_oboracle)` はフォーマット文字列中の `%s` を置き換えるための実際のパラメータです。`mysql_error(&con_oboracle)` は、接続オブジェクト `con_oboracle` を取得する時のエラー情報です。

       2. データベースとの接続を閉じ、接続オブジェクトのリソースをリリースします。

       3. テーブルの作成に失敗した場合、`return 1` を使用して `main` 関数から非ゼロ値 `1` を返して終了します。これはプログラムの異常終了の状態を表すために使用されます。

    3. テーブルの作成に成功した場合、テーブルが正常に作成されたことを表す成功メッセージを出力します。

    **コード：**

    ```c
        sprintf_s(sql_str, "CREATE TABLE test_tbl1(id NUMBER PRIMARY KEY, name VARCHAR2(50),age NUMBER NOT NULL)");
        if (mysql_query(&con_oboracle, sql_str) != 0) {
            fprintf(stderr, "Error: %s\n", mysql_error(&con_oboracle));
            mysql_close(&con_oboracle);
            return 1;
        }
        printf("Table created successfully\n");
    ```

7. データを挿入します。

    SQLクエリステートメントを実行して、テーブルにデータを挿入します。データの挿入に成功した場合、成功メッセージを出力します。データの挿入に失敗した場合、エラーメッセージを出力してプログラムを終了します。具体的な手順は以下のとおりです：

    1. `sprintf_s()` 関数を使用して、SQLクエリ文字列をフォーマットし、`sql_str` 文字配列に格納します。このSQLクエリステートメントは、`test_tbl1` テーブルに `id`、`name`、および `age` という列の値を挿入するために使用されます。

    2. `mysql_query()` 関数を使用してSQLクエリステートメントを実行します。`&con_oboracle` は、データベース接続オブジェクトへのポインタで、クエリ操作の対象となる接続オブジェクトを指定するために使用されます。`sql_str` は実行するクエリステートメントです。次に、クエリの実行に成功したかどうかを確認します。クエリの実行に失敗した場合（戻り値が0でない場合）、以下のコードブロックを実行します。

        1. `fprintf()` 関数は、エラーメッセージを標準エラーストリーム `stderr` に出力するために使用されます。`fprintf()` 関数の最初のパラメータは出力ストリーム、`"Error: %s\n"` はフォーマット文字列、`mysql_error(&con_oboracle)` はフォーマット文字列中の `%s` を置き換えるための実際のパラメータです。`mysql_error(&con_oboracle)` は、接続オブジェクト `con_oboracle` を取得する時のエラー情報です。

        2. データベースとの接続を閉じ、接続オブジェクトのリソースをリリースします。

        3. データの挿入に失敗した場合、`return 1` を使用して `main` 関数から非ゼロ値 `1` を返して終了します。これはプログラムの異常終了の状態を表すために使用されます。

    3. データの挿入に成功した場合、データが正常に挿入されたことを表す成功メッセージを出力します。

    **コード：**

    ```c
        sprintf_s(sql_str, "INSERT INTO test_tbl1 (id,name,age) VALUES  (1,'Tom', 18),(2,'Jerry', 20),(3,'Bob', 22)");
        if (mysql_query(&con_oboracle, sql_str) != 0) {
            fprintf(stderr, "Error: %s\n", mysql_error(&con_oboracle));
            mysql_close(&con_oboracle);
            return 1;
        }
        printf("Data inserted successfully\n");
    ```

8. データのクエリを実行します。

    SQLクエリを実行してテーブルからデータを取得し、取得したデータを1行ずつ出力します。データのクエリに成功した場合、成功メッセージを出力します。データのクエリに失敗した場合、エラーメッセージを出力してプログラムを終了します。具体的な手順は以下のとおりです：

    1. `sprintf_s()` 関数を使用して、SQLクエリ文字列をフォーマットし、`sql_str` 文字配列に格納します。このSQLクエリステートメントは、`test_tbl1` テーブルからすべての列のデータを取得するために使用されます。

    2. `mysql_query()` 関数を使用してSQLクエリステートメントを実行します。`&con_oboracle` は、データベース接続オブジェクトへのポインタで、クエリ操作の対象となる接続オブジェクトを指定するために使用されます。`sql_str` は実行するクエリステートメントです。次に、クエリの実行に成功したかどうかを確認します。クエリの実行に失敗した場合（戻り値が0でない場合）、以下のコードブロックを実行します。

        1. `fprintf()` 関数は、エラーメッセージを標準エラーストリーム `stderr` に出力するために使用されます。`fprintf()` 関数の最初のパラメータは出力ストリーム、`"Error: %s\n"` はフォーマット文字列、`mysql_error(&con_oboracle)` はフォーマット文字列中の `%s` を置き換えるための実際のパラメータです。`mysql_error(&con_oboracle)` は、接続オブジェクト `con_oboracle` を取得する時のエラー情報です。

        2. データベースとの接続を閉じ、接続オブジェクトのリソースをリリースします。

        3. クエリに失敗した場合、`return 1` を使用して `main` 関数から非ゼロ値 `1` を返して終了します。これはプログラムの異常終了の状態を表すために使用されます。

    3. `mysql_store_result()` 関数を使用して、クエリ結果セットを `MYSQL_RES` 構造体に格納します。`&con_oboracle` はデータベース接続オブジェクトへのポインタで、結果セットを取得する接続オブジェクトを指定するために使用されます。

    4. 結果セットが空かどうかを確認します。結果セットが空の場合、クエリ結果セットの格納に失敗したことを表します。以下のコードブロックを実行します。

        1. `fprintf()` 関数は、エラーメッセージを標準エラーストリーム `stderr` に出力するために使用されます。`fprintf()` 関数の最初のパラメータは出力ストリーム、`"Error: %s\n"` はフォーマット文字列、`mysql_error(&con_oboracle)` はフォーマット文字列中の `%s` を置き換えるための実際のパラメータです。`mysql_error(&con_oboracle)` は、接続オブジェクト `con_oboracle` を取得する時のエラー情報です。

        2. データベースとの接続を閉じ、接続オブジェクトのリソースをリリースします。

        3. クエリ結果セットの格納に失敗した場合、`return 1` を使用して `main` 関数から非ゼロ値 `1` を返して終了します。これはプログラムの異常終了の状態を表すために使用されます。

    5. データのクエリに成功した場合、データが正常に取得されたことを表す成功メッセージを出力します。

    6. `MYSQL_ROW` 型の変数 `row` を定義し、各行のデータを格納するために使用します。

    7. `mysql_fetch_row()` 関数を使用して、結果セットから行ごとにデータを検索し、各行のデータを `row` 変数に格納します。`while` ループは、結果セット内のすべての行が検索されるまで繰り返し実行されます。ループ内で、各行のデータを出力します。`row[0]`、`row[1]`、および `row[2]` は、現在の行の1番目、2番目、および3番目の列の値をそれぞれ表します。

    **コード：**

    ```c
        sprintf_s(sql_str, "SELECT * FROM test_tbl1");
        if (mysql_query(&con_oboracle, sql_str) != 0) {
            fprintf(stderr, "Error: %s\n", mysql_error(&con_oboracle));
            mysql_close(&con_oboracle);
            return 1;
        }

        MYSQL_RES* result = mysql_store_result(&con_oboracle);
        if (result == NULL) {
            fprintf(stderr, "Error: %s\n", mysql_error(&con_oboracle));
            mysql_close(&con_oboracle);
            return 1;
        }

        printf("Data retrieved successfully\n");

        MYSQL_ROW row;
        while ((row = mysql_fetch_row(result)) != NULL) {
            printf("id: %s, name: %s, age: %s\n", row[0], row[1], row[2]);
        }
    ```

9. プログラムを終了します。

    リソースをリリースし、データベースとの接続を閉じます。具体的な手順は以下のとおりです：

    1. `mysql_free_result(result)` を使用して `mysql_store_result()` 関数によって格納された結果セットリソースをリリースします。`result` はクエリ結果セットの情報とデータを格納している `MYSQL_RES` 構造体へのポインタです。

    2. `mysql_close(&con_oboracle)` を使用してデータベースとの接続を閉じ、接続オブジェクトが占有するリソースをリリースします。`&con_oboracle` は、データベース接続オブジェクトへのポインタです。`mysql_close()` 関数を呼び出すことで、データベースとの接続を閉じ、接続オブジェクトの関連リソースをリリースできます。

    3. `return 0;` を使用してプログラムの終了状態として `0` を返し、プログラムの実行が正常に終了したことを表します。

    **コード：**

    ```c
        mysql_free_result(result);

        mysql_close(&con_oboracle);
        printf("finish\n");

        return 0;
    }
    ```

### 全コード表示

:::tab
tab test_tbl1.cpp

```c
#include <stdio.h>
#include <stdlib.h>
#include <mysql.h>
#pragma comment(lib, "Shlwapi.lib")
#pragma comment( lib, "ws2_32.lib" )
#pragma comment(lib, "Crypt32.lib")
#pragma comment(lib, "Secur32.lib")
#pragma comment(lib, "obclnt.lib")

int main() {
    MYSQL con_oboracle;
    char sql_str[1024] = { 0 };

    if (NULL == mysql_init(&con_oboracle)) {
        fprintf(stderr, "Error: %s\n", mysql_error(&con_oboracle));
        return 1;
    }
    printf("mysql_init() success\n");

    if (NULL == mysql_real_connect(&con_oboracle, "your_ip", "your_user", "your_password", "your_schema", your_port, NULL, 0)) {
        fprintf(stderr, "Error: %s\n", mysql_error(&con_oboracle));
        return 1;
    }
    printf("mysql_real_connect() success\n");

    sprintf_s(sql_str, "CREATE TABLE test_tbl1(id NUMBER PRIMARY KEY, name VARCHAR2(50),age NUMBER NOT NULL)");
    if (mysql_query(&con_oboracle, sql_str) != 0) {
        fprintf(stderr, "Error: %s\n", mysql_error(&con_oboracle));
        mysql_close(&con_oboracle);
        return 1;
    }
    printf("Table created successfully\n");

    sprintf_s(sql_str, "INSERT INTO test_tbl1 (id,name,age) VALUES  (1,'Tom', 18),(2,'Jerry', 20),(3,'Bob', 22)");
    if (mysql_query(&con_oboracle, sql_str) != 0) {
        fprintf(stderr, "Error: %s\n", mysql_error(&con_oboracle));
        mysql_close(&con_oboracle);
        return 1;
    }
    printf("Data inserted successfully\n");

    sprintf_s(sql_str, "SELECT * FROM test_tbl1");
    if (mysql_query(&con_oboracle, sql_str) != 0) {
        fprintf(stderr, "Error: %s\n", mysql_error(&con_oboracle));
        mysql_close(&con_oboracle);
        return 1;
    }

    MYSQL_RES* result = mysql_store_result(&con_oboracle);
    if (result == NULL) {
        fprintf(stderr, "Error: %s\n", mysql_error(&con_oboracle));
        mysql_close(&con_oboracle);
        return 1;
    }

    printf("Data retrieved successfully\n");
    MYSQL_ROW row;
    while ((row = mysql_fetch_row(result)) != NULL) {
        printf("id: %s, name: %s, age: %s\n", row[0], row[1], row[2]);
    }

    mysql_free_result(result);

    mysql_close(&con_oboracle);
    printf("finish\n");

    return 0;
}
```

:::

## 関連ドキュメント

* OceanBaseデータベースへの接続に関する詳細については、[接続方法の概要](../../100.connect-to-oceanbase-database-of-oracle-mode/100.connection-methods-overview-of-oracle-mode.md)を参照してください。

* OceanBase Connector/Cの詳細については、[OceanBase Connector/C](https://en.oceanbase.com/docs/common-oceanbase-connector-j-en)を参照してください。
