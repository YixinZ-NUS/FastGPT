|description||
|---|---|
|keywords||
|dir-name|OceanBase Connector/ODBC|
|dir-name-en||
|tenant-type|Oracle Mode|

# OceanBase Connector/ODBC

本記事では、OceanBase Connector/ODBCとOceanBaseデータベースを使用してアプリケーションを構築し、テーブルの作成、データの挿入、データのクエリなどの基本操作を実装する方法について説明します。

<div role="videolist">
      <a role='link' href='https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/demo/C%26C%2B%2B/c-oceanbase-odbc.zip'>
          <img src='https://file.oceanbase.com/doc/img/lQLPJyFovGIOcJQWFrAqhLlgRRsPvwU-H7hJ_i0A_22_22.png'/>
          クリックしてc-oceanbase-odbcサンプルプロジェクトをダウンロード
      </a>
      <!-- <a role='video' href='https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/video-center/video/video/07%20c-oceanbase-odbc.mp4'>
          <img src='https://mdn.alipayobjects.com/huamei_22khvb/afts/img/A*DFPmToHK6hgAAAAAAAAAAAAADiGDAQ/original'/>
          OceanBase Connector/ODBCによるOceanBaseデータベースに接続するサンプルアプリケーション（Oracleモード）
      </a> -->
</div>

## 前提条件

* OceanBaseデータベースがインストール済みで、Oracleモードのユーザーテナントが作成済みであること。OceanBaseデータベースのインストールの詳細については、[デプロイの概要](../../../../400.deploy/100.deploy-overview.md)を参照してください。
* Visual Studioがインストール済みであること。
* OceanBase Connector/ODBCドライバーがインストール済みであること。

    <main id="notice" type='explain'>
        <h4>説明</h4>
        <p>OceanBase公式ダウンロードセンターの<a href="https://en.oceanbase.com/softwarecenter-cloud">OceanBase Dedicated</a>ページの<b>ドライバーとミドルウェア</b>モジュールから、OceanBase ODBCドライバープログラムのWindows版インストールパッケージをダウンロードしてください。Windows版OceanBase Connector/ODBCドライバーインストールパッケージはワンクリックデプロイ式で、デフォルトのガイド手順に従ってインストール可能です。</p>
    </main>

## 操作手順

<main id="notice" type='explain'>
  <h4>説明</h4>
  <p>本記事で示されている操作手順は、Windows環境下でVisual Studio Community 2019を使用して、このプロジェクトをコンパイルおよび実行する方法です。他のOS環境やコンパイラを使用している場合は、操作手順が若干異なる場合があります。</p>
</main>

1. `c-oceanbase-odbc` プロジェクトを開きます。
2. `c-oceanbase-odbc` プロジェクトのプロパティを設定します。
3. OceanBaseデータベースの接続情報を取得します。
4. `c-oceanbase-odbc` プロジェクト内のデータベース接続情報を修正します。
5. プロジェクトをビルドします。
6. アプリケーションを実行します。
7. 出力結果を確認します。

### ステップ１：c-oceanbase-odbcプロジェクトを開く

1. Visual Studio Community 2019を起動します。

2. 既存のプロジェクトを開きます。

   1. Visual Studio Community 2019の開始画面で、「使用を開始する」の下にある **プロジェクトまたはソリューションを開く(P)** ボタンをクリックします。または、Visual Studio Community 2019の開始画面で、「使用を開始する」の下にある **コードなしで続行(W)** ボタンをクリックするか、上部のメニューバーから **ファイル** -> **開く** -> **プロジェクト / ソリューション(P)** を選択します。

      <!-- ![1](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/demo/C%26C%2B%2B/vs-c-ob-capi/1%E6%89%93%E5%BC%80%E9%A1%B9%E7%9B%AE.png) -->

   2. **c-oceanbase-odbcプロジェクト** フォルダに移動し、プロジェクトファイル（`c-oceanbase-odbc.sln` または `c-oceanbase-odbc.vcxproj`）を選択して **開く** をクリックします。

      <!-- ![2](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/demo/C%26C%2B%2B/vs-c-ob-odbc/1%E6%89%93%E5%BC%80%E9%A1%B9%E7%9B%AE.png) -->

### ステップ2：c-oceanbase-odbcプロジェクトのプロパティを設定する

1. プロジェクトのプロパティページを開きます。

    **ソリューションエクスプローラー** で選択したプロジェクトを右クリックし、コンテキストメニューで **プロパティ** を選択するか、Visual Studioの上部メニューバーで **プロジェクト** -> **プロパティ** を選択するか、ショートカットキー <kbd>Alt</kbd> + <kbd>Enter</kbd> を使用します。

2. 構成マネージャーの設定を行います。

   1. プロパティページで、上部にある **設定(C)** ドロップダウンメニューを選択します。ドロップダウンメニューで、**Debug** を選択します。

   2. プロパティページで、上部にある **プラットフォーム(P)** のドロップダウンメニューを選択します。ドロップダウンメニューで、**x64** を選択します。

   <!-- ![3](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/demo/C%26C%2B%2B/vs-c-ob-odbc/2%E5%B1%9E%E6%80%A7_%E5%B9%B3%E5%8F%B0.png) -->

3. 文字セットの設定を行います。

    プロパティページで **詳細設定** タブを選択し、**文字セット** 項目を見つけます。ドロップダウンメニューで、**マルチバイト文字セットを使用する** を選択します。

    <!-- ![4](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/demo/C%26C%2B%2B/vs-c-ob-odbc/3%E5%B1%9E%E6%80%A7_%E5%AD%97%E7%AC%A6%E9%9B%86.png) -->

### ステップ3：OceanBaseデータベース接続情報を取得する

OceanBaseデータベースのデプロイ担当者または管理者から、該当するデータベース接続文字列を取得します。

**例：**

```shell
obclient -hxxx.xxx.xxx.xxx -P2881 -usys@oracle001 -p******
```

**パラメータの説明：**

* `-h`：OceanBaseデータベースの接続IPアドレスを提供します。ODP接続方式ではODPアドレスを使用し、直接接続方式ではOBServerノードのIPアドレスを使用します。
* `-P`：OceanBaseデータベースの接続ポートを提供します。ODP接続方式のデフォルトは `2883` で、ODPデプロイ時にカスタマイズ可能です。直接接続方式のデフォルトは `2881` で、OceanBaseデータベースのデプロイ時にカスタマイズ可能です。
* `-u`：テナントの接続アカウント。ODP接続の一般的な形式：`ユーザー名@テナント名#クラスタ名`または`クラスタ名:テナント名:ユーザー名`。直接接続方式の形式：`ユーザー名@テナント名`。
* `-p`：アカウントのパスワード。

接続文字列の詳細については、[OBClientによるOceanBaseテナントへの接続](../../100.connect-to-oceanbase-database-of-oracle-mode/200.connect-to-an-oceanbase-tenant-by-using-obclient-of-oracle-mode.md)を参照してください。

### ステップ4：c-oceanbase-odbcプロジェクトのデータベース接続情報を修正する

**ステップ3：OceanBaseデータベース接続情報を取得する** に記載されている情報に基づいて、`test_tbl1.cpp` ファイル内のデータベース接続情報を修正します。

**例：**

```c
char* mydriver = (char*)"Driver={OceanBase ODBC 2.0 Driver};Server=xxx.xxx.xxx.xxx;Port=2881;Database=sys;User=sys@oracle001;Password=******;Option=3;";
```

<!-- ![5](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/demo/C%26C%2B%2B/vs-c-ob-odbc/4%E8%BF%9E%E6%8E%A5%E4%BF%A1%E6%81%AF.png) -->

### ステップ5：プロジェクトをビルドします

**ビルド**メニューを選択し、**ソリューションのビルド** を選択します。ビルドプロセス中にコンパイラの出力とエラーや警告情報が表示されます。

<!-- ![7](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/demo/C%26C%2B%2B/vs-c-ob-capi/7%E7%94%9F%E6%88%90%E6%88%90%E5%8A%9F.png) -->

### ステップ6：アプリケーションを実行する

**デバッグ**メニューを選択し、**デバッグの開始** または **デバッグなしで開始** を選択してアプリケーションを実行します。

### ステップ7：出力結果を確認する

出力結果はデバッグコンソールに表示されます。プログラムの設計ロジックとコードに基づいて、出力の処理方法を判断できます。

<!-- ![8](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/demo/C%26C%2B%2B/vs-c-ob-odbc/5%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png) -->

## プロジェクトコードについて

[c-oceanbase-odbc](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/demo/C%26C%2B%2B/c-oceanbase-odbc.zip) をクリックして、プロジェクトコードをダウンロードします。これは、`c-oceanbase-odbc.zip` という名前の圧縮ファイルです。

解凍すると、`c-oceanbase-odbc` という名前のフォルダが作成されます。ディレクトリ構造は以下のとおりです：

```shell
c-oceanbase-odbc
├─ c-oceanbase-odbc.sln
├─ c-oceanbase-odbc.vcxproj
├─ c-oceanbase-odbc.vcxproj.filters
├─ c-oceanbase-odbc.vcxproj.user
└─ test_tbl1.cpp
```

**ファイルの説明：**

* `c-oceanbase-odbc.sln`：Visual Studioのソリューションファイルです。1つまたは複数のプロジェクトを管理するために使用されます。
* `c-oceanbase-odbc.vcxproj`：Visual Studioのプロジェクトファイルです。C/C++プロジェクトの構造と設定を記述するために使用されます。
* `c-oceanbase-odbc.vcxproj.filters`：Visual Studioのプロジェクトフィルターファイルです。プロジェクト内のファイルのディレクトリ構造と編成方法を定義するために使用されます。
* `c-oceanbase-odbc.vcxproj.user`：ユーザー固有のプロジェクト設定を格納するファイルです。
* `test_tbl1.cpp`：データテーブルの構造を定義し、データテーブル操作を実装したソースコードファイルです。

### test_tbl1.cppファイルのコード解説

`test_tbl1.cpp` ファイルは、`test_tbl1` という名前のデータテーブルを定義するために使用され、データテーブルの作成、データの挿入、クエリの操作を実装しています。

本記事の `test_tbl1.cpp` ファイルのコードには、主に以下の部分が含まれています：

1. ヘッダーファイルをインポートします。

    ヘッダーファイル `stdio.h`、`assert.h`、`windows.h`、`sql.h`、`sqlext.h` をインクルードします。

    **コード：**

    ```c
    #include <stdio.h>
    #include <assert.h>
    #include <windows.h>
    #include <sql.h>
    #include <sqlext.h>
    ```

2. `odbc_print_error` 関数を定義します。

    プログラム実行中にODBC関連のエラーが発生した場合、この関数が呼び出されてエラー情報を出力します。具体的な手順は以下のとおりです：

    1. 関数名を `odbc_print_error` として定義し、パラメータ `SQLSMALLINT HandleType` と `SQLHANDLE Handle` を指定します。これらはエラー情報に対応するハンドルのタイプとハンドルを指定するために使用されます。
    2. ODBCからエラー情報を取得するために使用する変数を定義します。これらの変数のタイプと名前は、ODBC APIで定義されたデータタイプと名前です。
    3. `SQLGetDiagRec()` を使用して、ODBCで最後に発生したエラー情報を取得します。この関数を呼び出すと、`SQLState`、`NativeError`、`SQLMessage` の各配列にエラー情報の関連内容が格納されます。
    4. `fprintf` 関数を使用して、エラー情報を標準出力ストリームに出力します。`[%s] (%d) %s\n` は出力フォーマットで、`printf` 関数に似たフォーマット文字列を使用します。`%s` は文字列タイプのデータの出力に、`%d` は整数タイプのデータの出力に使用され、`\n` は改行を表します。`SQLState`、`NativeError`、`SQLMessage` は、それぞれフォーマット文字列内の3つのパラメータに対応し、出力するエラー情報の内容を表します。

    **コード：**

    ```c
    static void odbc_print_error(SQLSMALLINT HandleType, SQLHANDLE Handle)
    {
        SQLCHAR SQLState[6];
        SQLINTEGER NativeError;
        SQLCHAR SQLMessage[SQL_MAX_MESSAGE_LENGTH] = { 0 };
        SQLSMALLINT TextLengthPtr;
        SQLGetDiagRec(HandleType, Handle, 1, SQLState, &NativeError, SQLMessage, SQL_MAX_MESSAGE_LENGTH, &TextLengthPtr);
        fprintf(stdout, "[%s] (%d) %s\n", SQLState, NativeError, SQLMessage);
    }
    ```

3. `ASSERT_CHECK` 関数を定義します。

    この関数の役割は、ODBC関数呼び出しの戻り値をチェックして処理することです。つまり、ODBC API関数の戻り値にエラーが発生していないかどうかをチェックし、エラーが発生している場合はエラー情報を出力してプログラムを終了します。具体的な手順は以下のとおりです：

    1. マクロ名を `ASSERT_CHECK` として定義し、パラメータ `SQLSMALLINT HandleType`、`SQLHANDLE Handle`、`SQLRETURN rcode` を指定します。これらはそれぞれODBCハンドルタイプ、ODBCハンドル、ODBC API関数呼び出しの戻り値です。
    2. `if` ステートメントを使用してODBC API関数の戻り値を判定します。戻り値が `SQL_SUCCESS` または `SQL_SUCCESS_WITH_INFO` と等しくない場合は、関数呼び出しでエラーが発生したことを表します。
    3. `odbc_print_error` 関数を呼び出してODBCエラー情報を出力します。
    4. `assert` 関数を呼び出して、プログラム実行中にアサーションチェックを行います。つまり、ODBC関数呼び出しでエラーが発生した場合、プログラムは中断されます。

    **コード：**

    ```c
    static void ASSERT_CHECK(SQLSMALLINT HandleType, SQLHANDLE Handle, SQLRETURN rcode)
    {
        if (rcode != SQL_SUCCESS && rcode != SQL_SUCCESS_WITH_INFO) {
            odbc_print_error(HandleType, Handle);
            assert(0);
        }
    }
    ```

4. `main` 関数を定義します。

    プログラムのエントリポイントとなる関数 `main` を定義し、整数値を返します。`main` 関数内には、データベース接続とデータ操作の関連コードを記述します。

    **コード：**

    ```c
    int main() {
        // 環境ハンドルの申請
        // ODBCバージョンの環境プロパティの設定
        // 接続ハンドルの割り当て
        // データソースへの接続
        // テーブルの作成
        // データの挿入
        // データのクエリ
        // クリーンアップ作業、具体的なリソースハンドルの解放
    }
    ```

5. 変数を定義します。

    変数 `henv` を定義します。これはODBC環境ハンドルタイプのオブジェクトで、ODBC接続とリソースの割り当てを管理するために使用されます。`OutConnStr` と `OutConnStrLen` は、接続文字列と文字列の長さを格納するために使用されます。これらのパラメータをデータベースに接続する際に `SQLDriverConnect` 関数に渡すことにより、データベースへの接続が成功した際の戻り値やその他の接続情報を取得します。

    **コード：**

    ```c
        HENV henv;
        SQLCHAR OutConnStr[255];
        SQLSMALLINT OutConnStrLen;
    ```

6. 環境ハンドルを申請します。

    `SQLAllocHandle` 関数を使用してODBC環境ハンドルを割り当てます。`ASSERT_CHECK` 関数でハンドルの割り当て結果をチェックし、割り当てが成功したことを確認します。具体的な手順は以下のとおりです：

    1. `SQLAllocHandle` 関数を実行すると、関数の実行結果を示す `SQLRETURN` タイプの値が返されます。コード内では、この戻り値は `rcode` 変数に格納されます。`SQLAllocHandle` 関数のパラメータは以下のとおりです：

       * `SQL_HANDLE_ENV`：割り当てるハンドルのタイプを指定します。ここでは `SQL_HANDLE_ENV` で、環境ハンドルを割り当てることを表します。
       * `SQL_NULL_HANDLE`：親ハンドルを指定します。ここでは `SQL_NULL_HANDLE` で、親ハンドルがないことを表します。
       * `&henv`：割り当てられたハンドルを格納する変数へのポインタです。ここでは `henv` で、環境ハンドルの変数です。

    2. `ASSERT_CHECK` 関数は、`SQLAllocHandle` 関数の戻り値 `rcode` をチェックするために使用されます。`rcode` が `SQL_SUCCESS` または `SQL_SUCCESS_WITH_INFO` でない場合、つまりハンドルの割り当てに失敗した場合、`ASSERT_CHECK` 関数は `odbc_print_error` 関数を呼び出してエラー情報を出力し、`assert` マクロを使用してプログラムの実行を終了します。

    **コード：**

    ```c
        SQLRETURN rcode = SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &henv);
        ASSERT_CHECK(SQL_HANDLE_ENV, henv, rcode);
    ```

7. ODBCバージョンの環境プロパティを設定します。

    `SQLSetEnvAttr` 関数を使用して、ODBC環境のプロパティを設定します。この関数は、環境レベルのプロパティを設定することにより、データベース接続とドライバーの動作に影響を与えることができます。`ASSERT_CHECK` 関数を使用してプロパティ設定の結果をチェックし、設定が成功したことを確認します。具体的な手順は以下のとおりです：

    1. `SQLSetEnvAttr` 関数を実行すると、関数の実行結果を示す `SQLRETURN` タイプの値が返されます。コード内では、この戻り値は `rcode` 変数に格納されます。`SQLSetEnvAttr` 関数のパラメータは以下のとおりです：

       * `henv`：ODBC環境ハンドルで、プロパティを設定する環境オブジェクトを指定します。
       * `SQL_ATTR_ODBC_VERSION`：設定する環境プロパティタイプを指定します。ここでは `SQL_ATTR_ODBC_VERSION` で、ODBCバージョンのプロパティを設定することを表します。
       * `(void*)SQL_OV_ODBC3`：プロパティ値へのポインターです。ここでは `SQL_OV_ODBC3` で、ODBCバージョンをODBC 3.xバージョンに設定することを表します。
       * `0`：プロパティ値の長さです。ここでは、プロパティ値が列挙定数であるため、長さは `0` です。

    2. `ASSERT_CHECK` 関数は、`SQLSetEnvAttr` 関数の戻り値 `rcode` をチェックするために使用されます。`rcode` が `SQL_SUCCESS` または `SQL_SUCCESS_WITH_INFO` でない場合、つまりプロパティ設定が失敗した場合、`ASSERT_CHECK` 関数は `odbc_print_error` 関数を呼び出してエラー情報を出力し、`assert` マクロを使用してプログラムの実行を終了します。

    **コード：**

    ```c
        rcode = SQLSetEnvAttr(henv, SQL_ATTR_ODBC_VERSION, (void*)SQL_OV_ODBC3, 0);
        ASSERT_CHECK(SQL_HANDLE_ENV, henv, rcode);
    ```

8. 接続ハンドルを割り当てます。

    `SQLAllocHandle` 関数を使用して、`ODBC` 接続ハンドルを割り当てます。`ASSERT_CHECK` 関数を使用してハンドルの割り当ての結果をチェックし、割り当てが成功したことを確認します。具体的な手順は以下のとおりです：

    1. `SQLAllocHandle` 関数を実行すると、関数の実行結果を示す `SQLRETURN` タイプの値が返されます。コード内では、この戻り値は `rcode` 変数に格納されます。`SQLAllocHandle` 関数のパラメータは以下のとおりです：

       * `SQL_HANDLE_DBC`：割り当てるハンドルのタイプを指定します。ここでは `SQL_HANDLE_DBC` で、接続ハンドルを割り当てることを表します。
       * `henv`：割り当て済みのODBC環境ハンドルで、親ハンドルとして接続ハンドルと関連付けられます。
       * `&hdbc`：割り当てられた接続ハンドルを格納する変数へのポインタです。

    2. `ASSERT_CHECK` 関数は、`SQLAllocHandle` 関数の戻り値 `rcode` をチェックするために使用されます。`rcode` が `SQL_SUCCESS` または `SQL_SUCCESS_WITH_INFO` でない場合、つまりハンドルの割り当てに失敗した場合、`ASSERT_CHECK` 関数は `odbc_print_error` 関数を呼び出してエラー情報を出力し、`assert` マクロを使用してプログラムの実行を終了します。

    **コード：**

    ```c
        SQLHDBC hdbc;
        rcode = SQLAllocHandle(SQL_HANDLE_DBC, henv, &hdbc);
        ASSERT_CHECK(SQL_HANDLE_DBC, hdbc, rcode);
    ```

9. データソースに接続します。

    `SQLDriverConnect` 関数を使用して、指定されたODBCデータソースに接続します。`ASSERT_CHECK` 関数を使用して接続操作の結果をチェックし、接続が成功したことを確認します。具体的な手順は以下のとおりです：

    1. 接続文字列 `mydriver` を定義します。この文字列は、データベースへの接続に必要な詳細情報を記述するために使用されます。この文字列には以下の部分が含まれます：

        * `Driver={OceanBase ODBC 2.0 Driver}`：使用するODBCドライバープログラムをOceanBase ODBC 2.0 Driverと指定します。
        * `Server=your_ip`：データベースサーバーのIPアドレスを指定します。
        * `Port=your_port`：データベースへの接続に使用するポート番号を指定します。
        * `Database=your_schema`：接続するデータベース名を指定します。
        * `User=your_use`：データベースへの接続に使用するユーザー名を指定します。
        * `Password=your_password`：データベースへの接続に使用するパスワードを指定します。
        * `Option=3`：接続オプションを指定します。値の `3` は、TCP/IP接続を使用することを表します。

    2. `SQLDriverConnect` 関数を使用して、指定されたODBCデータソースに接続します。関数を実行すると、関数の実行結果を示すSQLRETURNタイプの値が返されます。コード内では、この戻り値はrcode変数に格納されます。この関数のパラメータは以下のとおりです：

       * `hdbc`：ODBC接続ハンドルで、データソースとの接続を確立するために使用されます。
       * `NULL`：予約パラメータです。使用されません。
       * `mydriver`：ドライバープログラム名、データベースアドレス、ポート番号、データベース名、ユーザー名、パスワードなど、データベースへの接続に必要なすべての情報が含まれる接続文字列です。
       * `strlen((char*)mydriver) + 1`：接続文字列の長さです。
       * `OutConnStr`：接続文字列を格納するためのSQLCHARタイプのバッファーです。
       * `255`：バッファの長さです。
       * `&OutConnStrLen`：接続文字列の実際の長さを格納する変数へのポインタです。
       * `SQL_DRIVER_NOPROMPT`：接続時にプロンプトボックスを表示しないことを指示する接続フラグです。

    3. `ASSERT_CHECK` 関数は、`SQLDriverConnect` 関数の戻り値 `rcode` をチェックするために使用されます。`rcode` が `SQL_SUCCESS` または `SQL_SUCCESS_WITH_INFO` でない場合、つまり接続が失敗した場合、`ASSERT_CHECK` 関数は `odbc_print_error` 関数を呼び出してエラー情報を出力し、`assert` マクロを使用してプログラムの実行を終了します。

    **コード：**

    ```c
        char* mydriver = (char*)"Driver={OceanBase ODBC 2.0 Driver};Server=your_ip;Port=your_port;Database=your_schema;User=your_use;Password=your_password;Option=3;";
        rcode = SQLDriverConnect(hdbc, NULL, (SQLCHAR*)mydriver, strlen((char*)mydriver) + 1, OutConnStr, 255, &OutConnStrLen, SQL_DRIVER_NOPROMPT);
        ASSERT_CHECK(SQL_HANDLE_DBC, hdbc, rcode);
    ```

    **OceanBaseデータベースへの接続に必要なパラメータの説明：**

    * `your_ip`：OceanBaseデータベースの接続IPアドレスを提供します。ODP接続方式ではODPアドレスを使用し、直接接続方式ではOBServerノードのIPアドレスを使用します。
    * `your_port`：OceanBaseデータベースの接続ポートを提供します。ODP接続方式のデフォルトは `2883` で、ODPデプロイ時にカスタマイズ可能です。直接接続方式のデフォルトは `2881` で、OceanBaseデータベースのデプロイ時にカスタマイズ可能です。
    * `your_schema`：アクセスするスキーマ名。
    * `your_user`：テナントの接続アカウント。ODP接続方式の形式：`ユーザー名@テナント名#クラスタ名` または `クラスタ名:テナント名:ユーザー名`。直接接続方式の形式：`ユーザー名@テナント名`。
    * `your_password`：アカウントのパスワード。

10. テーブルを作成します。

    `SQLAllocHandle` 関数を使用して、ODBCステートメントハンドルを割り当てます。次に `SQLExecDirect` 関数を使用して、テーブルを作成するSQLステートメントを実行します。`ASSERT_CHECK` 関数を使用してハンドル割り当てとステートメント実行の結果をチェックし、操作が成功したことを確認します。最後に、`SQLFreeHandle` 関数を使用してステートメントハンドルを解放し、リソースを解放します。具体的な手順は以下のとおりです：

    1. ODBCステートメントハンドル `stmt` を宣言します。
    2. `SQLAllocHandle` 関数を使用して、ODBCステートメントハンドルを割り当てます。
    3. `ASSERT_CHECK` 関数を使用して、`SQLAllocHandle` 関数の戻り値 `rcode` をチェックし、ハンドルの割り当てに成功したことを確認します。

    4. `SQLExecDirect` 関数を使用してSQLステートメントを実行します。ここでは、`CREATE TABLE` ステートメントを実行して、`test_tbl1` という名前のテーブルを作成します。
    5. `ASSERT_CHECK` 関数を使用して、`SQLExecDirect` 関数の戻り値 `rcode` をチェックし、ステートメントの実行に成功したことを確認します。

    6. `SQLFreeHandle` 関数を使用して、`ODBC` ステートメントハンドルを解放します。

    **コード：**

    ```c
        SQLHSTMT stmt;
        rcode = SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &stmt);
        ASSERT_CHECK(SQL_HANDLE_STMT, stmt, rcode);

        rcode = SQLExecDirect(stmt, (SQLCHAR*)"CREATE TABLE test_tbl1(id NUMBER PRIMARY KEY, name VARCHAR2(50),age NUMBER NOT NULL)", SQL_NTS);
        ASSERT_CHECK(SQL_HANDLE_STMT, stmt, rcode);

        SQLFreeHandle(SQL_HANDLE_STMT, stmt);
    ```

11. データを挿入します。

    `SQLAllocHandle` 関数を使用して、ODBCステートメントハンドルを割り当てます。次に `SQLExecDirect` 関数を使用して、データベーステーブルにデータを挿入するSQLステートメントを実行します。`ASSERT_CHECK` 関数を使用してハンドル割り当てとステートメント実行の結果をチェックし、操作が成功したことを確認します。最後に、`SQLFreeHandle` 関数を使用してステートメントハンドルを解放し、リソースを解放します。具体的な手順は以下のとおりです：

    1. `SQLAllocHandle` 関数を使用して、ODBCステートメントハンドルを割り当てます。
    2. `ASSERT_CHECK` 関数を使用して、`SQLAllocHandle` 関数の戻り値 `rcode` をチェックし、ハンドルの割り当てに成功したことを確認します。

    3. `SQLExecDirect` 関数を使用してSQLステートメントを実行します。ここでは、`INSERT INTO` ステートメントを実行して、`test_tbl1` テーブルに3件のレコードを挿入します。
    4. `ASSERT_CHECK` 関数を使用して、`SQLExecDirect` 関数の戻り値 `rcode` をチェックし、ステートメントの実行に成功したことを確認します。

    5. `SQLFreeHandle` 関数を使用して、ODBCステートメントハンドルを解放します。

    **コード：**

    ```c
        rcode = SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &stmt);
        ASSERT_CHECK(SQL_HANDLE_STMT, stmt, rcode);

        rcode = SQLExecDirect(stmt, (SQLCHAR*)"INSERT INTO test_tbl1 (id,name,age) VALUES  (1,'Tom', 18),(2,'Jerry', 20),(3,'Bob', 22)", SQL_NTS);
        ASSERT_CHECK(SQL_HANDLE_STMT, stmt, rcode);

        SQLFreeHandle(SQL_HANDLE_STMT, stmt);
    ```

12. データのクエリを実行します。

    `SQLAllocHandle` 関数を使用して、ODBCステートメントハンドルを割り当てます。次に `SQLExecDirect` 関数を使用して、結果セットを取得するSQLステートメントを実行します。続いて、`SQLBindCol` 関数を使用して結果セットの列を変数にバインドし、`SQLFetch` 関数を使用して結果セットを行ごとに取得します。`while` ループで、`rcode` の値に基づいて結果セット内のデータを出力します。最後に、`SQLFreeHandle` 関数を使用してステートメントハンドルを解放し、リソースを解放します。具体的な手順は以下のとおりです：

    1. `SQLAllocHandle` 関数を使用して、ODBCステートメントハンドルを割り当てます。
    2. `ASSERT_CHECK` 関数を使用して、`SQLAllocHandle` 関数の戻り値 `rcode` をチェックし、ハンドルの割り当てに成功したことを確認します。
    3. `SQLExecDirect` 関数を使用してSQLステートメントを実行します。ここでは、`SELECT` ステートメントを実行して、`test_tbl1` テーブルからすべての行を取得します。
    4. `ASSERT_CHECK` 関数を使用して、`SQLExecDirect` 関数の戻り値 `rcode` をチェックし、ステートメントの実行に成功したことを確認します。

    5. `SQLLEN` タイプの変数 `res` を宣言し、バインドされた列の操作の結果を格納します。
    6. 結果セットの対応する列の値を格納するために、`SQLINTEGER` タイプの2つの変数 `id` と `age` を宣言します。
    7. 結果セットの対応する列の値を格納するために、`SQLCHAR` タイプの配列 `name` を宣言します。

    8. `SQLBindCol` 関数を使用して、結果セットの1番目の列を変数 `id` にバインドします。
    9. `SQLBindCol` 関数を使用して、結果セットの2番目の列を配列 `name` にバインドします。
    10. `SQLBindCol` 関数を使用して、結果セットの3番目の列を変数 `age` にバインドします。

    11. `SQLFetch` 関数を使用して結果セットの行を取得し、行内のデータをバインドされた変数に格納します。`while` ループは、すべての行が取得されるまで継続して実行されます。
    12. `while` ループで、`rcode` の値を判定して、対応する行のデータを出力します。`rcode` が `SQL_ERROR` の場合、エラー情報を出力します。

    13. `SQLFreeHandle` 関数を使用して、ODBCステートメントハンドルを解放します。

    **コード：**

    ```c
        rcode = SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &stmt);
        ASSERT_CHECK(SQL_HANDLE_STMT, stmt, rcode);

        rcode = SQLExecDirect(stmt, (SQLCHAR*)"SELECT * FROM test_tbl1", SQL_NTS);
        ASSERT_CHECK(SQL_HANDLE_STMT, stmt, rcode);

        SQLLEN res = SQL_NTS;
        SQLINTEGER id, age;
        SQLCHAR name[255];
        SQLBindCol(stmt, 1, SQL_C_SLONG, &id, sizeof(id), &res);
        SQLBindCol(stmt, 2, SQL_C_CHAR, name, sizeof(name), &res);
        SQLBindCol(stmt, 3, SQL_C_SLONG, &age, sizeof(age), &res);

        while ((rcode = SQLFetch(stmt)) != SQL_NO_DATA_FOUND)
        {
            if (rcode == SQL_ERROR) {
                printf("sql error!\n");
            }
            else {
                printf("id:%d, name:%s, age:%ld\n", id, name, age);
            }
        }

        SQLFreeHandle(SQL_HANDLE_STMT, stmt);
    ```

13. クリーンアップ作業を実行し、具体的なリソースハンドルを解放します。

    データベースとの接続を切断し、関連するODBCハンドルと環境ハンドルを解放して、リソースを解放します。SQLDisconnect関数とSQLFreeHandle関数を呼び出して、データベースとの接続を正しく閉じ、関連ハンドルを解放します。最後に、プログラムの実行が成功したことを示す0を返します。具体的な手順は以下のとおりです：

    1. SQLDisconnect関数を使用して、データベースとの接続を切断します。
    2. SQLFreeHandle関数を使用して、データベース接続ハンドルを解放します。
    3. SQLFreeHandle関数を使用して、ODBC環境ハンドルを解放します。

    4. プログラムの実行が成功したことを示す0を返します。

    **コード：**

    ```c
        SQLDisconnect(hdbc);
        SQLFreeHandle(SQL_HANDLE_DBC, hdbc);
        SQLFreeHandle(SQL_HANDLE_ENV, henv);

        return 0;
    ```

#### 全コード表示

:::tab
tab test_tbl1.cpp

```c
#include <stdio.h>
#include <assert.h>
#include <windows.h>
#include <sql.h>
#include <sqlext.h>

static void odbc_print_error(SQLSMALLINT HandleType, SQLHANDLE Handle)
{
    SQLCHAR SQLState[6];
    SQLINTEGER NativeError;
    SQLCHAR SQLMessage[SQL_MAX_MESSAGE_LENGTH] = { 0 };
    SQLSMALLINT TextLengthPtr;
    SQLGetDiagRec(HandleType, Handle, 1, SQLState, &NativeError, SQLMessage, SQL_MAX_MESSAGE_LENGTH, &TextLengthPtr);
    fprintf(stdout, "[%s] (%d) %s\n", SQLState, NativeError, SQLMessage);
}

static void ASSERT_CHECK(SQLSMALLINT HandleType, SQLHANDLE Handle, SQLRETURN rcode)
{
    if (rcode != SQL_SUCCESS && rcode != SQL_SUCCESS_WITH_INFO) {
        odbc_print_error(HandleType, Handle);
        assert(0);
    }
}

int main()
{
    HENV henv;
    SQLCHAR OutConnStr[255];
    SQLSMALLINT OutConnStrLen;

    SQLRETURN rcode = SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &henv);
    ASSERT_CHECK(SQL_HANDLE_ENV, henv, rcode);

    rcode = SQLSetEnvAttr(henv, SQL_ATTR_ODBC_VERSION, (void*)SQL_OV_ODBC3, 0);
    ASSERT_CHECK(SQL_HANDLE_ENV, henv, rcode);

    SQLHDBC hdbc;
    rcode = SQLAllocHandle(SQL_HANDLE_DBC, henv, &hdbc);
    ASSERT_CHECK(SQL_HANDLE_DBC, hdbc, rcode);

    char* mydriver = (char*)"Driver={OceanBase ODBC 2.0 Driver};Server=your_ip;Port=your_port;Database=your_schema;User=your_use;Password=your_password;Option=3;";
    rcode = SQLDriverConnect(hdbc, NULL, (SQLCHAR*)mydriver, strlen((char*)mydriver) + 1, OutConnStr, 255, &OutConnStrLen, SQL_DRIVER_NOPROMPT);
    ASSERT_CHECK(SQL_HANDLE_DBC, hdbc, rcode);

    SQLHSTMT stmt;
    rcode = SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &stmt);
    ASSERT_CHECK(SQL_HANDLE_STMT, stmt, rcode);

    rcode = SQLExecDirect(stmt, (SQLCHAR*)"CREATE TABLE test_tbl1(id NUMBER PRIMARY KEY, name VARCHAR2(50),age NUMBER NOT NULL)", SQL_NTS);
    ASSERT_CHECK(SQL_HANDLE_STMT, stmt, rcode);

    SQLFreeHandle(SQL_HANDLE_STMT, stmt);

    rcode = SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &stmt);
    ASSERT_CHECK(SQL_HANDLE_STMT, stmt, rcode);

    rcode = SQLExecDirect(stmt, (SQLCHAR*)"INSERT INTO test_tbl1 (id,name,age) VALUES  (1,'Tom', 18),(2,'Jerry', 20),(3,'Bob', 22)", SQL_NTS);
    ASSERT_CHECK(SQL_HANDLE_STMT, stmt, rcode);

    SQLFreeHandle(SQL_HANDLE_STMT, stmt);

    rcode = SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &stmt);
    ASSERT_CHECK(SQL_HANDLE_STMT, stmt, rcode);

    rcode = SQLExecDirect(stmt, (SQLCHAR*)"SELECT * FROM test_tbl1", SQL_NTS);
    ASSERT_CHECK(SQL_HANDLE_STMT, stmt, rcode);

    SQLLEN res = SQL_NTS;
    SQLINTEGER id, age;
    SQLCHAR name[255];
    SQLBindCol(stmt, 1, SQL_C_SLONG, &id, sizeof(id), &res);
    SQLBindCol(stmt, 2, SQL_C_CHAR, name, sizeof(name), &res);
    SQLBindCol(stmt, 3, SQL_C_SLONG, &age, sizeof(age), &res);

    while ((rcode = SQLFetch(stmt)) != SQL_NO_DATA_FOUND)
    {
        if (rcode == SQL_ERROR) {
            printf("sql error!\n");
        }
        else {
            printf("id:%d, name:%s, age:%ld\n", id, name, age);
        }
    }

    SQLFreeHandle(SQL_HANDLE_STMT, stmt);

    SQLDisconnect(hdbc);
    SQLFreeHandle(SQL_HANDLE_DBC, hdbc);
    SQLFreeHandle(SQL_HANDLE_ENV, henv);

    return 0;
}
```

:::

## 関連ドキュメント

* OceanBaseデータベースへの接続に関する詳細については、[接続方法の概要](../../100.connect-to-oceanbase-database-of-oracle-mode/100.connection-methods-overview-of-oracle-mode.md)を参照してください。

* OceanBase Connector/ODBCに関する詳細については、[OceanBase Connector/ODBC](https://en.oceanbase.com/docs/obodbc-en)を参照してください。
