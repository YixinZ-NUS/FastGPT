|description||
|---|---|
|keywords||
|dir-name|HikariCP|
|dir-name-en||
|tenant-type|Oracle Mode|

# HikariCP

本記事では、HikariCP接続プール、OceanBase Connector/J、およびOceanBaseデータベースを用いてアプリケーションを構築し、テーブル作成・データの挿入・更新・削除・クエリなどの基本的なデータベース操作を実装する方法を紹介します。

<div role="videolist">
      <a role='link' href='https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/connection-pool/hikaricp-oceanbase-client/hikaricp-oceanbase-client.zip'>
          <img src='https://file.oceanbase.com/doc/img/lQLPJyFovGIOcJQWFrAqhLlgRRsPvwU-H7hJ_i0A_22_22.png'/>
          クリックしてhikaricp-oceanbase-clientサンプルプロジェクトをダウンロード
      </a>
      <!-- <a role='video' href='https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/video-center/video/video/03%20hikaricp-%20oceanbase-client.mp4'>
          <img src='https://mdn.alipayobjects.com/huamei_22khvb/afts/img/A*DFPmToHK6hgAAAAAAAAAAAAADiGDAQ/original'/>
          HikariCP接続プールがOceanBaseデータベースに接続するサンプルプログラム(Oracle模式)
      </a> -->
</div>

## 前提条件

* OceanBaseデータベースがインストール済みで、Oracleモードのテナントが作成されていること。
* JDK 1.8とMavenがインストール済みであること。
* Eclipseがインストール済みであること。

    <main id="notice" type='explain'>
      <h4>説明</h4>
      <p>この記事でコードの実行にはEclipse IDE for Java Developers 2022-03バージョンを使用しています。ご自身の好みに合わせて、適切なツールを選択してサンプルコードを実行することも可能です。</p>
    </main>

## 操作手順

<main id="notice" type='explain'>
  <h4>説明</h4>
  <p>本記事の操作手順はWindows環境に基づいています。他のOS環境やコンパイラを使用する場合は、操作手順が若干異なる場合があります。</p>
</main>

1. `hikaricp-oceanbase-client` プロジェクトをEclipseにインポートします。
2. OceanBaseデータベースのURLを取得します。
3. `hikaricp-oceanbase-client` プロジェクトのデータベース接続情報を修正します。
4. `hikaricp-oceanbase-client` プロジェクトを実行します。

### ステップ１：hikaricp-oceanbase-client プロジェクトをEclipseにインポートする

1. Eclipseを開き、メニューバーから**File**->**Open Projects from File System**を選択します。

2. ポップアップダイアログで、**Directory**ボタンをクリックしてプロジェクトのディレクトリを選択し、**Finish**をクリックしてインポートを完了します。

    <main id="notice" type='explain'>
      <h4>説明</h4>
      <p>Eclipseを使用してMavenプロジェクトをインポートすると、プロジェクト内の<code>pom.xml</code>ファイルを自動的に検出し、その記述に基づいて必要な依存ライブラリをダウンロードしてプロジェクトに追加します。</p>
    </main>

    ![1](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/connection-pool/hikaricp-oceanbase-client/1.png)

3. プロジェクトの状況を確認します。

    ![2](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/connection-pool/hikaricp-oceanbase-client/2.png)

### ステップ2：OceanBaseデータベースのURLを取得する

1. OceanBaseデータベースのデプロイ担当者または管理者から、該当するデータベース接続文字列を取得します。

    **例：**

    ```shell
    obclient -hxxx.xxx.xxx.xxx -P2881 -utest_user001@oracel001 -p******
    ```

    接続文字列に関するその他の情報については、[OBClientを使用したOceanBaseテナントへの接続](../200.connect-to-an-oceanbase-tenant-by-using-obclient-of-oracle-mode.md)を参照してください。

2. OceanBaseデータベース接続文字列の情報に基づいて、以下のURLの対応する情報を入力します。

    ```shell
    jdbc:oceanbase://$host:$port/$schema_name?user=$user_name&password=$password
    ```

    **パラメータの説明：**

    * `$host`：OceanBaseデータベースへの接続IPアドレス。OceanBaseデータベースプロキシ(OceanBase Database Proxy、ODP)接続方式ではODPアドレスを使用し、直接接続方式ではOBServerノードのIPアドレスを使用します。
    * `$port`：OceanBaseデータベースへの接続ポート。ODP接続方式のデフォルトポートは`2883`で、ODPデプロイ時にカスタマイズ可能です。直接接続方式のデフォルトポートは`2881`で、OceanBaseデータベースのデプロイ時にカスタマイズ可能です。
    * `$schema_name`：アクセスするスキーマ名です。

        <main id="notice" type='notice'>
          <h4>注意</h4>
          <p>接続テナントのユーザーに、<code>CREATE SESSION</code> 権限と、そのSchemaの<code>CREATE TABLE</code>、<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>、および<code>SELECT</code> 権限が付与されていなければなりません。ユーザー権限に関するその他の詳細については、 <a href="https://en.oceanbase.com/docs/common-oceanbase-database-10000000001974760">Oracle モードの権限分類</a> を参照してください。</p>
        </main>

    * `$user_name`：テナントの接続アカウント。ODP接続の一般的な形式：`ユーザー名@テナント名#クラスタ名`または`クラスタ名:テナント名:ユーザー名`。直接接続方式の形式：`ユーザー名@テナント名`。
    * `$password`：アカウントのパスワード。

    OceanBase Connector/J URLパラメータに関するその他の詳細な説明については、[データベースURL](https://en.oceanbase.com/docs/common-oceanbase-connector-j-en-10000000002244946)を参照してください。

    **例：**

    ```shell
    jdbc:oceanbase://xxx.xxx.xxx.xxx:2881/test_schema001?user=test_user001@oracel001&password=******
    ```

### ステップ3：hikaricp-oceanbase-clientプロジェクトのデータベース接続情報を修正する

**ステップ2：OceanBaseデータベースのURLを取得する**で取得した情報に基づいて、`hikaricp-oceanbase-client/src/main/resources/db.properties` ファイル内のデータベース接続情報を修正します。

![3](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/connection-pool/hikaricp-oceanbase-client/3.png)

**例：**

* OBServerノードのIPアドレスは `xxx.xxx.xxx.xxx` です。
* アクセスポートは2881を使用します。
* アクセスするスキーマ名は `test_schema001` です。
* テナントの接続アカウントは `test_user001@oracle001` です。`oracle001` はOceanBaseデータベースで作成されたOracleモードのユーザーテナントで、`test_user001` はテナント `oracle001` のユーザー名です。
* パスワードは `******` です。

**コード：**

```java
...
jdbcUrl=jdbc:oceanbase://xxx.xxx.xxx.xxx:2881/test_schema001
username=test_user001@oracle001
password=******
...
```

### ステップ4：hikaricp-oceanbase-clientプロジェクトを実行する

1. プロジェクトナビゲータービューで、**src/main/java**ディレクトリを見つけて展開します。

2. **Main.java**ファイルを右クリックし、**Run As**->**Java Application**を選択します。

    ![4](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/connection-pool/hikaricp-oceanbase-client/4.png)

3. Eclipseのコンソールウィンドウで、プロジェクトのログ情報と出力結果を確認します。

    ![5](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/connection-pool/hikaricp-oceanbase-client/5.png)

4. OceanBaseクライアント（OBClient）で以下のSQLステートメントを実行して結果を確認することもできます。

    ```shell
    obclient [SYS]> SELECT * FROM test_schema001.test_hikaricp;
    ```

    **実行結果は以下のとおりです：**

    ```shell
    +------+-------------+
    | ID   | NAME        |
    +------+-------------+
    |    1 | test_update |
    +------+-------------+
    1 row in set
    ```

## プロジェクトコードについて

[hikaricp-oceanbase-client](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/connection-pool/hikaricp-oceanbase-client/hikaricp-oceanbase-client.zip) をクリックして、プロジェクトコードをダウンロードします。これは、`hikaricp-oceanbase-client.zip` という名前の圧縮ファイルです。

解凍すると、`hikaricp-oceanbase-client` という名前のフォルダが作成されます。ディレクトリ構造は以下のとおりです：

```shell
hikaricp-oceanbase-client
├── src
│   └── main
│       ├── java
│       │   └── com
│       │       └── example
│       │           └── Main.java
│       └── resources
│           └── db.properties
└── pom.xml
```

**ファイルの説明：**

* `src`：ソースコードのルートディレクトリです。
* `main`：アプリケーションの主要なロジックを含むメインコードディレクトリです。
* `java`：Javaソースコードディレクトリです。
* `com`：Javaパッケージディレクトリです。
* `example`：サンプルプロジェクトのパッケージディレクトリです。
* `Main.java`：テーブルの作成、データの挿入、削除、更新、およびクエリなどのロジック処理を含むメインクラスプログラムのサンプルファイルです。
* `resources`：設定ファイルなどを含むリソースファイルディレクトリです。
* `db.properties`：データベース接続に関するパラメータを含む接続プールの設定ファイルです。
* `pom.xml`：プロジェクトの依存関係とビルド設定を管理するために使用されるMavenプロジェクトの設定ファイルです。

### pom.xmlコードの紹介

`pom.xml` ファイルはMavenプロジェクトの設定ファイルで、プロジェクトの依存関係、プラグイン、ビルドルールなどの情報を定義しています。MavenはJavaプロジェクト管理ツールで、依存関係のダウンロード、プロジェクトのコンパイル、パッケージングなどの操作を自動化できます。

本記事の `pom.xml` ファイルのコードは、主に以下のいくつかの部分が含まれます：

1. ファイル宣言ステートメントです。

    このファイルがXMLファイルであり、使用しているXMLのバージョンが `1.0` で、文字エンコーディング方式が `UTF-8` であることを宣言しています。

    **コード：**

    ```java
    <?xml version="1.0" encoding="UTF-8"?>
    ```

2. POMのネームスペースとPOMモデルのバージョンを設定します。

    1. `xmlns` を使用して、POMのネームスペースを `http://maven.apache.org/POM/4.0.0` と指定します。
    2. `xmlns:xsi` を使用して、XMLネームスペースを `http://www.w3.org/2001/XMLSchema-instance` と指定します。
    3. `xsi:schemaLocation` を使用して、POMのネームスペースを `http://maven.apache.org/POM/4.0.0`、POMのXSDファイルの場所を `http://maven.apache.org/xsd/maven-4.0.0.xsd` と指定します。
    4. `<modelVersion>` 要素を使用して、このPOMファイルで使用されるPOMモデルバージョンを `4.0.0` と指定します。

    **コード：**

    ```java
    <project xmlns="http://maven.apache.org/POM/4.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
      <modelVersion>4.0.0</modelVersion>

     <!-- その他の設定 -->

    </project>
    ```

3. 基本情報を設定します。

    1. `<groupId>` を使用して、プロジェクトが属する組織を `com.example` と指定します。
    2. `<artifactId>` を使用して、プロジェクトの名前を `hikaricp-oceanbase-client` と指定します。
    3. `<version>` を使用して、プロジェクトのバージョン番号を `1.0-SNAPSHOT` と指定します。

    **コード：**

    ```java
        <groupId>com.example</groupId>
        <artifactId>hikaricp-oceanbase-client</artifactId>
        <version>1.0-SNAPSHOT</version>
    ```

4. プロジェクトソースファイルのプロパティを設定します。

    Mavenのコンパイラプラグインを `maven-compiler-plugin` と指定し、ソースコードとターゲットJavaバージョンをどちらも8に設定しています。これは、プロジェクトのソースコードがJava 8の機能を使用して記述されており、コンパイルされたバイトコードもJava 8ランタイム環境と互換性があることを意味します。この設定により、プロジェクトはコンパイル時および実行時にJava 8の構文と機能を正しく処理できるようになります。

    <main id="notice" type='explain'>
      <h4>説明</h4>
      <p>Java 1.8とJava 8は、同じバージョンの異なる命名ルールです。</p>
    </main>

    **コード：**

    ```java
        <build>
            <plugins>
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-compiler-plugin</artifactId>
                    <configuration>
                        <source>8</source>
                        <target>8</target>
                    </configuration>
                </plugin>
            </plugins>
        </build>
    ```

5. プロジェクトが依存するコンポーネントを設定します。

    1. `oceanbase-client` 依存ライブラリを追加し、データベースとのインタラクションを行います：

       1. `<groupId>` を使用して、依存関係が属する組織を `com.oceanbase` と指定します。
       2. `<artifactId>` を使用して、依存関係の名前を `oceanbase-client` と指定します。
       3. `<version>` を使用して、依存関係のバージョン番号を `2.4.2` と指定します。

        <main id="notice" type='explain'>
          <h4>説明</h4>
          <p>この部分のコードでは、プロジェクトが依存するコンポーネントとしてOceanBase Connector/JのバージョンV2.4.2を定義しています。他のバージョンの情報については、<a href="https://en.oceanbase.com/docs/oceanbase-connector-j-en">OceanBase JDBCドライバー</a>を参照してください</p>
        </main>

        **コード：**

        ```java
                <dependency>
                    <groupId>com.oceanbase</groupId>
                    <artifactId>oceanbase-client</artifactId>
                    <version>2.4.2</version>
                </dependency>
        ```

    2. 高パフォーマンスなJDBC接続プールを実現するために、`HikariCP` 依存ライブラリを追加します：

       1. `<groupId>` を使用して、依存関係が属する組織を `com.zaxxer` と指定します。
       2. `<artifactId>` を使用して、依存関係の名前を `HikariCP` と指定します。
       3. `<version>` を使用して、依存関係のバージョン番号を `3.3.1` と指定します。

        **コード：**

        ```java
                <dependency>
                    <groupId>com.zaxxer</groupId>
                    <artifactId>HikariCP</artifactId>
                    <version>3.3.1</version>
                </dependency>
        ```

    3. `logback-classic` 依存ライブラリを追加して、ログレコードと管理を容易に行うために使用されます：

       1. `<groupId>` を使用して、依存関係が属する組織を `ch.qos.logback` と指定します。
       2. `<artifactId>` を使用して、依存関係の名前を `logback-classic` と指定します。
       3. `<version>` を使用して、依存関係のバージョン番号を `1.2.5` と指定します。

        **コード：**

        ```java
                <dependency>
                    <groupId>ch.qos.logback</groupId>
                    <artifactId>logback-classic</artifactId>
                    <version>1.2.5</version>
                </dependency>
        ```

### db.propertiesコードの紹介

`db.properties` は本記事の例となる接続プールの設定ファイルであり、接続プールの設定プロパティが含まれています。これらのプロパティには、データベースURL、ユーザー名、パスワード、接続プールのその他のオプションが含まれます。

本記事の `db.properties` ファイルのコードは、主に以下のいくつかの部分が含まれます：

1. データベース接続パラメータを設定します。

    1. データベース接続のURLを設定します。これには、ホストIPアドレス、ポート番号、アクセスするSchemaが含まれます。
    2. データベースのユーザー名を設定します。
    3. データベースのパスワードを設定します。

    **コード：**

    ```java
    jdbcUrl=jdbc:oceanbase://$host:$port/$schema_name
    username=$user_name
    password=$password
    ```

    **パラメータの説明：**

    * `$host`：OceanBaseデータベースへの接続IPアドレス。ODP接続方式ではODPアドレスを使用し、直接接続方式ではOBServerノードのIPアドレスを使用します。
    * `$port`：OceanBaseデータベースへの接続ポート。ODP接続方式のデフォルトポートは`2883`で、ODPデプロイ時にカスタマイズ可能です。直接接続方式のデフォルトポートは`2881`で、OceanBaseデータベースのデプロイ時にカスタマイズ可能です。
    * `$schema_name`：アクセスするスキーマ名です。
    * `$user_name`：テナントの接続アカウント。ODP接続の一般的な形式：`ユーザー名@テナント名#クラスタ名`または`クラスタ名:テナント名:ユーザー名`。直接接続方式の形式：`ユーザー名@テナント名`。
    * `$password`：アカウントのパスワード。

2. 他の接続プールのパラメータを設定します。

    1. プリコンパイルされたSQLステートメントのキャッシュを有効にします。
    2. プリコンパイルされたSQLステートメントのキャッシュサイズを250に設定します。
    3. 接続の最大ライフサイクルを1800000ミリ秒（30分）に設定します。この時間を超えると接続は閉じられます。
    4. 接続のアイドルタイムアウトを600000ミリ秒（10分）に設定します。この時間を超えて接続がアイドル状態の場合、接続は閉じられます。
    5. 接続のタイムアウト時間を30000ミリ秒（30秒）に設定します。この時間内を超えても接続が確立されなかった場合、例外がスローされます。

    **コード：**

    ```java
    dataSource.cachePrepStmts=true
    dataSource.prepStmtCacheSize=250
    dataSource.maxLifetime=1800000
    dataSource.idleTimeout=600000
    dataSource.connectionTimeout=30000
    ```

<main id="notice" type='notice'>
  <h4>注意</h4>
  <p>具体的なプロパティ（パラメータ）の設定は、プロジェクトの要件とデータベースの特性によって異なります。実際の状況に応じて調整と設定を行うことを推奨します。HikariCP接続プールパラメータに関するその他の詳細情報については、<a href="https://github.com/brettwooldridge/HikariCP#essentials">Configuration</a> を参照してください。</p>
</main>

**HikariCP接続プールの一般的な基本パラメータ：**

<table>
   <tr>
       <th>分類</th>
       <th>パラメータ</th>
       <th>省略値</th>
       <th>説明</th>
   </tr>
   <tr>
       <td rowspan=4>必須パラメータ</td>
       <td>dataSourceClassName</td>
       <td>N/A</td>
       <td>JDBCドライバーが提供するDataSourceクラスの名前を指定するために使用されます。<main id="notice" type='notice'><h4>注意</h4><p><code>dataSourceClassName</code> は通常、明示的に設定する必要はありません。HikariCPは適切なドライバーを自動的に検出してロードすることができます。</p></main></td>
   </tr>
   <tr>
       <td>jdbcUrl</td>
       <td>N/A</td>
       <td>JDBC接続データベースのURLを指定するために使用されます。</td>
   </tr>
   <tr>
       <td>username</td>
       <td>N/A</td>
       <td>データベースへの接続時に使用するユーザー名の指定に使用されます。</td>
   </tr>
   <tr>
       <td>password</td>
       <td>N/A</td>
       <td>データベースに接続するために使用するパスワードを指定します。</td>
   </tr>
   <tr>
   </tr>
   <tr>
       <td rowspan=9>よく使われるオプションパラメータ</td>
       <td>autoCommit</td>
       <td>true</td>
       <td>接続プールから返される接続のデフォルトの自動コミット動作を制御するために使用されます。</td>
   </tr>
   <tr>
       <td>connectionTimeout</td>
       <td>30000</td>
       <td>クライアントが接続プールから接続を取得する際の最大待ち時間を制御するために使用されます。単位はミリ秒で、デフォルト値は30000（30秒）です。許容される最低の接続タイムアウト時間は250ミリ秒です。</td>
   </tr>
   <tr>
       <td>idleTimeout</td>
       <td>600000</td>
       <td>プール内のアイドル状態の接続の最大時間を制御するために使用されます。単位はミリ秒で、デフォルト値は600000（10分）です。この設定には、以下の制限があります：<ul><li><code>minimumIdle</code> が<code>maximumPoolSize</code> より小さい場合にのみ有効になります。</li><li>接続プール内の接続数が <code>minimumIdle</code> に達した場合、アイドル接続は回収されません。接続数が <code>minimumIdle</code> を超えた場合にのみ、接続は回収される可能性があります。</li></ul></td>
   </tr>
   <tr>
       <td>keepaliveTime</td>
       <td>0</td>
       <td>データベースまたはネットワークインフラストラクチャによって接続がタイムアウトされるのを防ぐために、接続キープアライブの頻度を制御するために使用されます。単位はミリ秒で、デフォルト値は0です。これは接続キープアライブを無効にすることを意味します。この値は <code>maxLifetime</code> プロパティの値より小さくする必要があります。</li><li></td>
   </tr>
   <tr>
       <td>maxLifetime</td>
       <td>1800000</td>
       <td>接続プール内の接続の最大ライフサイクルを制御するために使用されます。既に使用された接続は自動的に回収されることはなく、接続が閉じられた場合にのみ、接続プールから削除されます。単位はミリ秒で、デフォルト値は1800000（30分）です。<code>maxLifetime</code> を0に設定すると、接続プール内の接続は最大ライフサイクルの制限がなく、つまり接続のライフサイクルは無限であることを意味します。</td>
   </tr>
   <tr>
       <td>connectionTestQuery</td>
       <td>N/A</td>
       <td>接続プールからデータベースに送信される接続テストクエリを実行するために使用されます。これは、接続プールから接続を取得する前に実行され、データベースへの接続がまだ有効であるかどうかを確認します。</td>
   </tr>
   <tr>
       <td>minimumIdle</td>
       <td>N/A</td>
       <td>接続プール内で維持される最小アイドル接続数を制御するために使用されます。アイドル接続数がこの値を下回り、かつ接続プール内の接続総数が <code>maximumPoolSize</code> より少ない場合、HikariCPは可能な限り迅速かつ効率的に追加の接続を追加しようとします。デフォルトでは、<code>minimumIdle</code> プロパティの値は <code>maximumPoolSize</code> プロパティと同じです。</td>
   </tr>
   <tr>
       <td>maximumPoolSize</td>
       <td>10</td>
       <td>アイドル状態と使用中の接続を含む、接続プールが許可する最大サイズを制御するために使用されます。この値により、データベースバックエンドへの実際の接続の最大数が決定します。</td>
   </tr>
   <tr>
       <td>poolName</td>
       <td>N/A</td>
       <td>ユーザー定義の接続プールの名前を表すために使用されます。ログレコードおよびJMX管理コンソールでは、この名前は主に接続プールの識別と接続プールの設定に使用されます。デフォルトでは、自動的に名前がビルドされます。</td>
   </tr>
</table>

### Main.javaコードの紹介

`Main.java` ファイルは、HikariCP接続プールを使用してデータベース接続を取得し、テーブルの作成、データの挿入、削除、更新、クエリの実行、およびクエリ結果の出力など、一連のデータベース操作を実証するサンプルプログラムの一部です。

本記事の `Main.java` ファイルのコードには、主に以下のいくつの部分が含まれます：

1. 必要なクラスとパッケージをインポートします。

    1. 現在のJavaファイルのパッケージ名を `com.example` と定義します。これは、Javaクラスの整理と管理を行うために使用されます。
    2. `java.sql.Connection` クラスをインポートし、データベースへの接続を確立と管理するために使用されます。
    3. `java.sql.PreparedStatement` クラスをインポートし、プリコンパイルされたSQLステートメントを実行するために使用されます。
    4. `java.sql.ResultSet` クラスをインポートし、クエリ結果セットを処理するために使用されます。
    5. `java.sql.SQLException` クラスをインポートし、SQL例外を処理するために使用されます。
    6. HikariCPの `HikariConfig` クラスをインポートし、HikariCP接続プールを設定するために使用されます。
    7. HikariCPの `HikariDataSource` クラスをインポートし、HikariCP接続プールを作成と管理するために使用されます。

    **コード：**

    ```java
    package com.example;

    import java.sql.Connection;
    import java.sql.PreparedStatement;
    import java.sql.ResultSet;
    import java.sql.SQLException;
    import com.zaxxer.hikari.HikariConfig;
    import com.zaxxer.hikari.HikariDataSource;
    ```

2. クラス名とメソッドを定義します。

    Mainクラスを定義します。その中の `main` メソッドをプログラムのエントリポイントとします。`main` メソッド内で、`db.properties` ファイルを読み込んでHikariCP接続プールを設定し、データベース接続を取得します。その後、一連のメソッドを順番に呼び出し、テーブルの作成、データの挿入、データのクエリ、データの更新、およびデータの削除を行います。操作中に `SQLException` 例外が発生した場合、例外情報のスタックトレースが出力されます。具体的な手順は以下のとおりです：

    1. Mainという名前のpublicクラスを定義します。
    2. Mainクラスのエントリポイントメソッド `main` を定義します。
    3. HikariConfigオブジェクトを作成し、指定された `db.properties` ファイルを使用して設定します。
    4. HikariDataSourceオブジェクトを作成し、`try-with-resources` ブロック内でデータベース接続を取得します。
    5. テーブルを作成するためのメソッドを呼び出し、取得したデータベース接続オブジェクトを渡して、`test_hikaricp`テーブルを作成します。
    6. データを挿入するためのメソッドを呼び出し、取得したデータベース接続オブジェクトとデータパラメータを渡して、`(1,'A1')` と `(2,'A2')` の2行のデータを挿入します。
    7. データをクエリするためのメソッドを呼び出し、取得したデータベース接続オブジェクトを渡して、データの挿入状況を確認します。
    8. データを更新するためのメソッドを呼び出し、取得したデータベース接続オブジェクトと更新パラメータを渡して、`id` が `1` の行の `name` 列の値を `test_update` に更新します。
    9. データをクエリするためのメソッドを呼び出し、取得したデータベース接続オブジェクトを渡して、データの更新状況を確認します。
    10. データを削除するためのメソッドを呼び出し、取得したデータベース接続オブジェクトと削除パラメータを渡して、`id` が `2` の行を削除します。
    11. データをクエリするためのメソッドを呼び出し、取得したデータベース接続オブジェクトを渡して、データの削除状況を確認します
    12. `try` ブロック内で `SQLException` 例外が発生した場合、例外のスタックトレース情報を出力します。
    13. テーブルの作成、データの挿入、データのクエリ、データの更新、データの削除を行うためのメソッドを定義します。

    **コード：**

    ```java
    public class Main {
        public static void main(String[] args) {
            try {
                HikariConfig config = new HikariConfig("/db.properties");
                try (HikariDataSource dataSource = new HikariDataSource(config);
                    Connection conn = dataSource.getConnection()) {
                    createTable(conn);

                    insertData(conn, 1, "A1");
                    insertData(conn, 2, "A2");

                    selectData(conn);

                    updateData(conn, "test_update", 1);
                    selectData(conn);

                    deleteData(conn, 2);
                    selectData(conn);
                }
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

        // テーブルを作成するためのメソッドを定義する
        // データを挿入するためのメソッドを定義する
        // データをクエリするためのメソッドを定義する
        // データを更新するたのメソッドを定義する
        // データを削除するためのメソッドを定義する
    }
    ```

3. テーブルを作成するためのメソッドを定義します。

    プライベート静的メソッド `createTable` を定義し、データベースに `test_hikaricp` という名前のテーブルを作成します。このテーブルに `id` 列と `name` 列が含まれます。具体的な手順は以下のとおりです：

    1. プライベート静的メソッド `createTable` を定義します。このメソッドはConnectionオブジェクトをパラメータとして受け取り、`SQLException` 例外をスローする可能性があることを宣言します。
    2. SQLステートメント文字列を定義し、`test_hikaricp` という名前のテーブルを作成し、テーブルに `id` 列（データ型は `NUMBER`）と `name` 列（データ型は `VARCHAR2(50)`）を含めます。
    3. 接続オブジェクト `conn` を使用して、プリコンパイルされたSQLステートメントオブジェクト `pstmt` を作成し、そのオブジェクトを `try-with-resources` ブロック内で使用します。
    4. SQLステートメントを実行し、`test_hikaricp` という名前のテーブルを作成します。
    5. コンソールにメッセージを出力し、テーブルが正常に作成されたことを示します。

    **コード：**

    ```java
        private static void createTable(Connection conn) throws SQLException {
            String sql = "CREATE TABLE test_hikaricp (id NUMBER, name VARCHAR2(50))";
            try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
                pstmt.executeUpdate();
                System.out.println("Table created successfully.");
            }
        }
    ```

4. データを挿入するためのメソッドを定義します。

    プライベート静的メソッド `insertData` を定義し、データベースのテーブル `test_hikaricp` にデータを挿入するために使用されます。具体的な手順は以下のとおりです：

    1. プライベート静的メソッド `insertData` を定義します。このメソッドは、Connectionオブジェクト、整数型の `id` パラメータ、文字列タイプの `name` パラメータを受け取り、`SQLException` 例外をスローする可能性があることを宣言します。
    2. SQLステートメント文字列を定義し、`test_hikaricp` という名前のテーブルにデータを挿入するために使用されます。データに `id` と `name` 列が含まれます。
    3. 接続オブジェクト `conn` を使用して、プリコンパイルされたSQLステートメントオブジェクト `pstmt` を作成し、そのオブジェクトを `try-with-resources` ブロック内で使用します。
    4. SQLステートメントの最初のパラメータ `?` の値を `id` に設定します。
    5. SQLステートメントの2番目のパラメータ `?` の値を `name` に設定します。
    6. SQLステートメントを実行し、テーブルにデータを挿入します。
    7. コンソールにメッセージを出力し、データが正常に挿入されたことを示します。

    **コード：**

    ```java
        private static void insertData(Connection conn, int id, String name) throws SQLException {
            String sql = "INSERT INTO test_hikaricp (id, name) VALUES (?, ?)";
            try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
                pstmt.setInt(1, id);
                pstmt.setString(2, name);
                pstmt.executeUpdate();
                System.out.println("Data inserted successfully.");
            }
        }
    ```

5. データのクエリを行うためのメソッドを定義します。

    プライベート静的メソッド `selectData` を定義し、データベースからテーブル `test_hikaricp` のデータをクエリするために使用されます。具体的な手順は以下のとおりです：

    1. プライベート静的メソッド `selectData` を定義します。このメソッドはConnectionオブジェクトをパラメータとして受け取り、`SQLException` 例外をスローする可能性があることを宣言します。
    2. SQLステートメント文字列を定義し、`test_hikaricp` という名前のテーブルのすべてのデータをクエリするために使用されます。
    3. 接続オブジェクト `conn` を使用して、プリコンパイルされたSQLステートメントオブジェクト `pstmt` を作成し、そのオブジェクトを `try-with-resources` ブロック内で使用します。同時に、`executeQuery()` メソッドを呼び出してSQLクエリを実行し、クエリ結果セットのオブジェクト `rs` を返します。
    4. コンソールにメッセージを出力し、ユーザーデータが出力中であることを示します。
    5. クエリ結果セットをイテレーションし、`next()` メソッドを使用して結果セットに次の行のデータがあるかどうかを確認します。ある場合は、ループに入ります。
    6. 結果セットから `id` 列の値を取得し、変数 `id` に代入します。
    7. 結果セットから `name` 列の値を取得し、変数 `name` に代入します。
    8. コンソールに各行データの `id` と `name` の値を出力します。
    9. コンソールに空の行を出力します。

    **コード：**

    ```java
        private static void selectData(Connection conn) throws SQLException {
            String sql = "SELECT * FROM test_hikaricp";
            try (PreparedStatement pstmt = conn.prepareStatement(sql);
                ResultSet rs = pstmt.executeQuery()) {
                System.out.println("User Data:");
                while (rs.next()) {
                    int id = rs.getInt("id");
                    String name = rs.getString("name");
                    System.out.println("ID: " + id + ", Name: " + name);
                }
                System.out.println();
            }
        }
    ```

6. データを更新するためのメソッドを定義します。

    プライベート静的メソッド `updateData` を定義し、データベースのテーブル `test_hikaricp` 中のデータを更新するために使用されます。具体的な手順は以下のとおりです：

    1. プライベート静的メソッド `updateData` を定義します。このメソッドは、Connection オブジェクト、文字列タイプの `name` パラメータ、整数型の `id` パラメータを受け取り、`SQLException` 例外をスローする可能性があることを宣言します。
    2. SQLステートメント文字列を定義し、`test_hikaricp` という名前のテーブル内のデータを更新し、`name` 列の値を指定の `name` に更新するために使用されます。条件は `id` 列の値と指定の `id` が等しいことです。
    3. 接続オブジェクト `conn` を使用して、プリコンパイルされたSQLステートメントオブジェクト `pstmt` を作成し、そのオブジェクトを `try-with-resources` ブロック内で使用します。
    4. SQLステートメントの最初のパラメータ `?` の値を `name` に設定します。
    5. SQLステートメントの2番目のパラメータ `?` の値を `id` に設定します。
    6. SQLステートメントを実行して、テーブル内のデータを更新します。
    7. コンソールにメッセージを出力し、データが正常に更新されたことを示します。

    **コード：**

    ```java
        private static void updateData(Connection conn, String name, int id) throws SQLException {
            String sql = "UPDATE test_hikaricp SET name = ? WHERE id = ?";
            try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
                pstmt.setString(1, name);
                pstmt.setInt(2, id);
                pstmt.executeUpdate();
                System.out.println("Data updated successfully.");
            }
        }
    ```

7. データを削除するためのメソッドを定義します。

    プライベート静的メソッド `deleteData` を定義し、`test_hikaricp` テーブル内で条件を満たすデータをデータベースから削除するために使用されます。具体的な手順は以下のとおりです：

    1. プライベート静的メソッド `deleteData` を定義します。このメソッドはConnectionオブジェクトと整数型 `id` パラメータを受け取り、`SQLException` 例外をスローする可能性があることを宣言します。
    2. SQLステートメント文字列を定義し、`test_hikaricp` という名前のテーブルから条件 `id = ?` を満たすデータを削除するために使用されます。
    3. 接続オブジェクト `conn` を使用して、プリコンパイルされたSQLステートメントオブジェクト `pstmt` を作成し、そのオブジェクトを `try-with-resources` ブロック内で使用します。
    4. SQLステートメントの最初のパラメータ `?` の値を `id` に設定します。
    5. SQLステートメントを実行し、条件を満たすデータをテーブルから削除します。
    6. コンソールにメッセージを出力し、データが正常に削除されたことを示します。

    **コード：**

    ```java
        private static void deleteData(Connection conn, int id) throws SQLException {
            String sql = "DELETE FROM test_hikaricp WHERE id = ?";
            try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
                pstmt.setInt(1, id);
                pstmt.executeUpdate();
                System.out.println("Data deleted successfully.");
            }
        }
    ```

### 全コード表示

:::tab
tab pom.xml

```java
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.oceanbase</groupId>
    <artifactId>hikaricp-oceanbase-client</artifactId>
    <version>1.0-SNAPSHOT</version>
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <configuration>
                    <source>8</source>
                    <target>8</target>
                </configuration>
            </plugin>
        </plugins>
    </build>

    <dependencies>
        <dependency>
            <groupId>com.oceanbase</groupId>
            <artifactId>oceanbase-client</artifactId>
            <version>2.4.2</version>
        </dependency>
        <dependency>
            <groupId>com.zaxxer</groupId>
            <artifactId>HikariCP</artifactId>
            <version>3.3.1</version>
        </dependency>
        <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-classic</artifactId>
            <version>1.2.5</version>
        </dependency>
    </dependencies>
</project>
```

tab db.properties

```java
jdbcUrl=jdbc:oceanbase://$host:$port/$schema_name
username=$user_name
password=$password

dataSource.cachePrepStmts=true
dataSource.prepStmtCacheSize=250
dataSource.maxLifetime=1800000
dataSource.idleTimeout=600000
dataSource.connectionTimeout=30000
```

tab Main.java

```java
package com.example;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;

public class Main {
    public static void main(String[] args) {
        try {
            HikariConfig config = new HikariConfig("/db.properties");
            try (HikariDataSource dataSource = new HikariDataSource(config);
                 Connection conn = dataSource.getConnection()) {
                createTable(conn);

                insertData(conn, 1, "A1");
                insertData(conn, 2, "A2");

                selectData(conn);

                updateData(conn, "test_update", 1);
                selectData(conn);

                deleteData(conn, 2);
                selectData(conn);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    private static void createTable(Connection conn) throws SQLException {
        String sql = "CREATE TABLE test_hikaricp (id NUMBER, name VARCHAR2(50))";
        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.executeUpdate();
            System.out.println("Table created successfully.");
        }
    }

    private static void insertData(Connection conn, int id, String name) throws SQLException {
        String sql = "INSERT INTO test_hikaricp (id, name) VALUES (?, ?)";
        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.setInt(1, id);
            pstmt.setString(2, name);
            pstmt.executeUpdate();
            System.out.println("Data inserted successfully.");
        }
    }

    private static void selectData(Connection conn) throws SQLException {
        String sql = "SELECT * FROM test_hikaricp";
        try (PreparedStatement pstmt = conn.prepareStatement(sql);
             ResultSet rs = pstmt.executeQuery()) {
            System.out.println("User Data:");
            while (rs.next()) {
                int id = rs.getInt("id");
                String name = rs.getString("name");
                System.out.println("ID: " + id + ", Name: " + name);
            }
            System.out.println();
        }
    }

    private static void updateData(Connection conn, String name, int id) throws SQLException {
        String sql = "UPDATE test_hikaricp SET name = ? WHERE id = ?";
        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.setString(1, name);
            pstmt.setInt(2, id);
            pstmt.executeUpdate();
            System.out.println("Data updated successfully.");
        }
    }

    private static void deleteData(Connection conn, int id) throws SQLException {
        String sql = "DELETE FROM test_hikaricp WHERE id = ?";
        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.setInt(1, id);
            pstmt.executeUpdate();
            System.out.println("Data deleted successfully.");
        }
    }
}
```

:::

## 関連ドキュメント

* OceanBase Connector/Jに関するその他の詳細については、[OceanBase JDBC ドライバー](https://en.oceanbase.com/docs/oceanbase-connector-j-en)を参照してください。
* HikariCP接続プール使用に関するその他の詳細については、[HikariCP](https://github.com/brettwooldridge/HikariCP#essentials)を参照してください。
