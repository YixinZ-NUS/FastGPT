|description||
|---|---|
|keywords||
|dir-name|Proxool|
|dir-name-en||
|tenant-type|Oracle Mode|

# Proxool

本記事では、Proxool接続プール、OceanBase Connector/J、およびOceanBaseデータベースを使用してアプリケーションを構築し、テーブルの作成、挿入、削除、更新、およびクエリなどの基本的なデータベース操作を実現する方法について紹介します。

<div role="videolist">
      <a role='link' href='https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/connection-pool/proxool-oceanbase-client/proxool-oceanbase-client.zip'>
          <img src='https://file.oceanbase.com/doc/img/lQLPJyFovGIOcJQWFrAqhLlgRRsPvwU-H7hJ_i0A_22_22.png'/>
          クリックしてproxool-oceanbase-clientサンプルプロジェクトをダウンロード
      </a>
      <!-- <a role='video' href='https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/video-center/video/video/02%20proxool-oceanbase-client.mp4'>
          <img src='https://mdn.alipayobjects.com/huamei_22khvb/afts/img/A*DFPmToHK6hgAAAAAAAAAAAAADiGDAQ/original'/>
          Proxool接続プールを使用してOceanBaseデータベースに接続するサンプルプログラム（Oracleモード)
      </a> -->
</div>

## 前提条件

* OceanBaseデータベースがインストール済みで、Oracleモードのテナントが作成されていること。
* JDK 1.8とMavenがインストール済みであること。
* IntelliJ IDEAがインストール済みであること。

    <main id="notice" type='explain'>
      <h4>説明</h4>
      <p>この記事でコードを実行するために使用したツールは、IntelliJ IDEA Community Edition 2021.3.2バージョンです。ご自身の好みに合わせて、適切なツールを選択してサンプルコードを実行することも可能です。</p>
    </main>

## 操作手順

<main id="notice" type='explain'>
  <h4>説明</h4>
  <p>本記事で示されている操作手順は、Windows環境でIntelliJ IDEA Community Edition 2021.3.2を使用して、このプロジェクトをコンパイルおよび実行する手順です。他のOS環境やコンパイラを使用している場合は、操作手順が若干異なる場合があります。</p>
</main>

1. `proxool-oceanbase-client` プロジェクトをIntelliJ IDEAにインポートします。
2. OceanBaseデータベースのURLを取得します。
3. `proxool-oceanbase-client` プロジェクト内のデータベース接続情報を修正します。
4. `proxool-oceanbase-client` プロジェクトを実行します。

### ステップ１：proxool-oceanbase-clientプロジェクトをIntelliJ IDEAにインポートします。

1. IntelliJ IDEAを開きます。
2. ウェルカム画面で、**Open**オプションをクリックし、プロジェクトのディレクトリに移動します。プロジェクトのルートディレクトリを選択して、**OK**をクリックします。

    ![1](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/connection-pool/proxool-oceanbase-client/1.png)

3. IntelliJ IDEAは、プロジェクトのタイプを自動的に検出し、プロジェクトを読み込みます。

    <main id="notice" type='explain'>
      <h4>説明</h4>
      <p>IntelliJ IDEAでMavenプロジェクトをインポートすると、IntelliJ IDEAはプロジェクト内の<code>pom.xml</code>ファイルを自動的に検出し、ファイルに記述された依存関係に基づいて必要な依存ライブラリを自動的にダウンロードし、それらをプロジェクトに追加します。</p>
    </main>

    ![2](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/connection-pool/proxool-oceanbase-client/2.png)

4. （オプション）未解決の依存関係を手動でインポートします。

    `pom.xml` ファイルに対応する依存関係がすべてプロジェクトに自動的にインポートされている場合は、この手順を無視してください。

    IntelliJ IDEAの**Sync**ウィンドウのヒントから、`proxool-cglib` と `proxool` の依存関係が解決されていないことがわかります。`proxool-oceanbase-client` プロジェクトのルートディレクトリにある `lib` フォルダには、`proxool-cglib` と `proxool` の `jar` ファイルがあります。これらをプロジェクトに追加する手順は以下のとおりです：

    1. IntelliJ IDEAで、**File**->**Project Structure**をクリックして、プロジェクト構造の設定に入ります。
    2. 左側のパネルで、**Modules**を選択します。
    3. 右側のモジュールリストで、**Dependencies**タブを選択し、このページの**+**アイコンをクリックして、**JARs or directories**を選択します。
    4. ポップアップダイアログで、`jar` ファイルが保存されている `lib` ディレクトリに移動し、`jar` ファイルを選択して、**OK**をクリックします。
    5. **Dependencies**タブで、新しく追加された `jar` ファイルがリストに表示されます。
    6. **Apply**または**OK**をクリックして変更を保存します。

    ![3](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/connection-pool/proxool-oceanbase-client/3.png)

### ステップ2：OceanBaseデータベースのURLを取得する

1. OceanBaseデータベースのデプロイ担当者または管理者から、該当するデータベース接続文字列を取得します。

    **例：**

    ```shell
    obclient -hxxx.xxx.xxx.xxx -P2881 -utest_user001@oracel001 -p******
    ```

    接続文字列に関するその他の情報については、[OBClientを使用したOceanBaseテナントへの接続](../200.connect-to-an-oceanbase-tenant-by-using-obclient-of-oracle-mode.md)を参照してください。

2. OceanBaseデータベース接続文字列の情報に基づいて、以下のURLの対応する情報を入力します。

    ```shell
    jdbc:oceanbase://$host:$port/$schema_name?user=$user_name&password=$password
    ```

    **パラメータの説明：**

    * `$host`：OceanBaseデータベースへの接続IPアドレス。OceanBaseデータベースプロキシ(OceanBase Database Proxy、ODP)接続方式ではODPアドレスを使用し、直接接続方式ではOBServerノードのIPアドレスを使用します。
    * `$port`：OceanBaseデータベースへの接続ポート。ODP接続方式のデフォルトポートは`2883`で、ODPデプロイ時にカスタマイズ可能です。直接接続方式のデフォルトポートは`2881`で、OceanBaseデータベースのデプロイ時にカスタマイズ可能です。
    * `$schema_name`：アクセスするスキーマ名です。

        <main id="notice" type='notice'>
          <h4>注意</h4>
          <p>接続テナントのユーザーに、<code>CREATE SESSION</code> 権限と、そのスキーマの <code>CREATE TABLE</code>、<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>、および<code>SELECT</code> 権限が付与されていなければなりません。その他のユーザー権限の情報については、<a href="https://en.oceanbase.com/docs/common-oceanbase-database-10000000001974760">Oracleモードの権限分類</a>を参照してください。</p>
        </main>

    * `$user_name`：テナントの接続アカウント。ODP接続の一般的な形式：`ユーザー名@テナント名#クラスタ名`または`クラスタ名:テナント名:ユーザー名`。直接接続方式の形式：`ユーザー名@テナント名`。
    * `$password`：アカウントのパスワード。

    その他のOceanBase Connector/J URLパラメータの説明については、[データベースURL](https://en.oceanbase.com/docs/common-oceanbase-connector-j-en-10000000002244946)を参照してください。

    **例：**

    ```shell
    jdbc:oceanbase://xxx.xxx.xxx.xxx:2881/test_schema001?user=test_user001@oracel001&password=******
    ```

### ステップ3：proxool-oceanbase-clientプロジェクトのデータベース接続情報を修正する

**ステップ2：OceanBaseデータベースのURL**で取得した情報に基づいて、`proxool-oceanbase-client/src/main/resources/db.properties` ファイル内のデータベース接続情報を修正します。

**例：**

* OBServerノードのIPアドレスは `xxx.xxx.xxx.xxx` です。
* アクセスポートは2881を使用します。
* アクセスするスキーマ名は `test_schema001` です。
* テナントの接続アカウントは `test_user001@oracle001` です。`oracle001` はOceanBaseデータベースで作成されたOracleモードのユーザーテナントで、`test_user001` はテナント `oracle001` のユーザー名です。
* パスワードは `******` です。

**コード：**

```java
...
jdbc-1.proxool.driver-url=jdbc:oceanbase://xxx.xxx.xxx.xxx:2881/test_schema001
jdbc-1.user=test_user001@oracle001
jdbc-1.password=******
...
```

### ステップ4：proxool-oceanbase-clientプロジェクトを実行する

1. プロジェクトのナビゲーションバーで、**src/main/java/com.example**ディレクトリを見つけて展開します。
2. **Main**ファイルを右クリックし、**Run 'Main.main()'**を選択します。
3. IntelliJ IDEAは、プロジェクトを自動的にコンパイルして実行し、実行パネルに結果を出力します。

    ![4](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/connection-pool/proxool-oceanbase-client/4.png)

4. OceanBaseクライアント（OBClient）で以下のSQLステートメントを実行して結果を確認することもできます。

    ```shell
    obclient [TEST_USER001]> SELECT * FROM test_schema001.test_proxool;
    ```

    **実行結果は以下のとおりです：**

    ```shell
    +------+---------------+
    | C1   | C2            |
    +------+---------------+
    |    6 | test_update   |
    |    7 | test_insert7  |
    |    8 | test_insert8  |
    |    9 | test_insert9  |
    |   10 | test_insert10 |
    +------+---------------+
    5 rows in set
    ```

## プロジェクトコードについて

[proxool-oceanbase-client](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/connection-pool/proxool-oceanbase-client/proxool-oceanbase-client.zip) をクリックして、プロジェクトコードをダウンロードします。これは、`proxool-oceanbase-client.zip` という名前の圧縮ファイルです。

解凍すると、`proxool-oceanbase-client` という名前のフォルダが作成されます。ディレクトリ構造は以下のとおりです：

```shell
proxool-oceanbase-client
├── lib
│    ├── proxool-0.9.1.jar
│    └── proxool-cglib.jar
├── src
│   └── main
│       ├── java
│       │   └── com
│       │       └── example
│       │           └── Main.java
│       └── resources
│           └── db.properties
└── pom.xml
```

**ファイルの説明：**

* `lib`：プロジェクトに必要な依存ライブラリファイルを保存する場所です。
* `proxool-0.9.1.jar`：Proxool接続プールライブラリファイル。
* `proxool-cglib.jar`：Proxool接続プールをサポートするために使用されるCGLibライブラリファイル。
* `src`：ソースコードのルートディレクトリです。
* `main`：アプリケーションの主要なロジックを含むメインコードディレクトリです。
* `java`：Javaソースコードディレクトリです。
* `com`：Javaパッケージディレクトリです。
* `example`：サンプルプロジェクトのパッケージディレクトリです。
* `Main.java`：テーブルの作成、データの挿入、削除、更新、およびクエリなどのロジック処理を含むメインクラスプログラムのサンプルファイルです。
* `resources`：設定ファイルなどを含むリソースファイルディレクトリです。
* `db.properties`：データベース接続に関するパラメータを含む接続プールの設定ファイルです。
* `pom.xml`：プロジェクトの依存関係とビルド設定を管理するために使用されるMavenプロジェクトの設定ファイルです。

### pom.xmlコードの紹介

`pom.xml` ファイルはMavenプロジェクトの設定ファイルで、プロジェクトの依存関係、プラグイン、ビルドルールなどの情報を定義しています。MavenはJavaプロジェクト管理ツールで、依存関係のダウンロード、プロジェクトのコンパイル、パッケージングなどの操作を自動化できます。

本記事の `pom.xml` ファイルのコードは、主に以下のいくつかの部分が含まれます：

1. ファイル宣言ステートメントです。

    このファイルがXMLファイルであり、使用しているXMLのバージョンが `1.0` で、文字エンコーディング方式が `UTF-8` であることを宣言しています。

    **コード：**

    ```java
    <?xml version="1.0" encoding="UTF-8"?>
    ```

2. POMのネームスペースとPOMモデルのバージョンを設定します。

    1. `xmlns` を使用して、POMのネームスペースを `http://maven.apache.org/POM/4.0.0` と指定します。
    2. `xmlns:xsi` を使用して、XMLネームスペースを `http://www.w3.org/2001/XMLSchema-instance` と指定します。
    3. `xsi:schemaLocation` を使用して、POMのネームスペースを `http://maven.apache.org/POM/4.0.0`、POMのXSDファイルの場所を `http://maven.apache.org/xsd/maven-4.0.0.xsd` と指定します。
    4. `<modelVersion>` 要素を使用して、このPOMファイルで使用されるPOMモデルバージョンを `4.0.0` と指定します。

    **コード：**

    ```java
    <project xmlns="http://maven.apache.org/POM/4.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
      <modelVersion>4.0.0</modelVersion>

     <!-- その他の設定 -->

    </project>
    ```

3. 基本情報を設定します。

    1. `<groupId>` を使用して、プロジェクトが属する組織を `com.example` と指定します。
    2. `<artifactId>` を使用して、プロジェクトの名前を `proxool-oceanbase-client` と指定します。
    3. `<version>` を使用して、プロジェクトのバージョン番号を `1.0-SNAPSHOT` と指定します。

    **コード：**

    ```java
        <groupId>com.example</groupId>
        <artifactId>proxool-oceanbase-client</artifactId>
        <version>1.0-SNAPSHOT</version>
    ```

4. プロジェクトソースファイルのプロパティを設定します。

    Mavenのコンパイラプラグインを `maven-compiler-plugin` と指定し、ソースコードとターゲットJavaバージョンをどちらも8に設定しています。これは、プロジェクトのソースコードがJava 8の機能を使用して記述されており、コンパイルされたバイトコードもJava 8ランタイム環境と互換性があることを意味します。この設定により、プロジェクトはコンパイル時および実行時にJava 8の構文と機能を正しく処理できるようになります。

    <main id="notice" type='explain'>
      <h4>説明</h4>
      <p>Java 1.8とJava 8は、同じバージョンの異なる命名ルールです。</p>
    </main>

    **コード：**

    ```java
        <build>
            <plugins>
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-compiler-plugin</artifactId>
                    <configuration>
                        <source>8</source>
                        <target>8</target>
                    </configuration>
                </plugin>
            </plugins>
        </build>
    ```

5. プロジェクトが依存するコンポーネントを設定します。

    1. `mysql-connector-java` 依存ライブラリを追加し、データベースへの接続と操作に使用します：

       1. `<groupId>` を使用して、依存関係が属する組織を `com.oceanbase` と指定します。
       2. `<artifactId>` を使用して、依存関係の名前を `oceanbase-client` と指定します。
       3. `<version>` を使用して、依存関係のバージョン番号を `2.4.2` と指定します。

        <main id="notice" type='explain'>
          <h4>説明</h4>
          <p>この部分のコードでは、プロジェクトが依存するコンポーネントとしてOceanBase Connector/JのバージョンV2.4.2を定義しています。他のバージョンの情報については、<a href="https://en.oceanbase.com/docs/oceanbase-connector-j-en">OceanBase JDBCドライバー</a>を参照してください</p>
        </main>

        **コード：**

        ```java
                <dependency>
                    <groupId>com.oceanbase</groupId>
                    <artifactId>oceanbase-client</artifactId>
                    <version>2.4.2</version>
                </dependency>
        ```

    2. `proxool-cglib` 依存ライブラリを追加し、Proxool接続プールをサポートするために使用されるCGLibライブラリです：

       1. `<groupId>` を使用して、依存関係が属する組織を `proxool` と指定します。
       2. `<artifactId>` を使用して、依存関係の名前を `proxool-cglib` と指定します。
       3. `<version>` を使用して、依存関係のバージョン番号を `0.9.1` と指定します。

        **コード：**

        ```java
                <dependency>
                    <groupId>proxool</groupId>
                    <artifactId>proxool-cglib</artifactId>
                    <version>0.9.1</version>
                </dependency>
        ```

    3. `proxool` 依存ライブラリを追加します。これは、Proxool接続プールのコアライブラリです：

       1. `<groupId>` を使用して、依存関係が属する組織を `proxool` と指定します。
       2. `<artifactId>` を使用して、依存関係の名前を `proxool` と指定します。
       3. `<version>` を使用して、依存関係のバージョン番号を `0.9.1` と指定します。

        **コード：**

        ```java
                <dependency>
                    <groupId>proxool</groupId>
                    <artifactId>proxool</artifactId>
                    <version>0.9.1</version>
                </dependency>
        ```

    4. `ommons-logging` 依存ライブラリを追加して、アプリケーションでログレコードを行うための汎用的なログライブラリ：

       1. `<groupId>` を使用して、依存関係が属する組織を `commons-logging` と指定します。
       2. `<artifactId>` を使用して、依存関係の名前を `commons-logging` と指定します。
       3. `<version>` を使用して、依存関係のバージョン番号を `1.2` と指定します。

        **コード：**

        ```java
                <dependency>
                    <groupId>commons-logging</groupId>
                    <artifactId>commons-logging</artifactId>
                    <version>1.2</version>
                </dependency>
        ```

### db.propertiesコードの紹介

`db.properties` は本記事の例となる接続プールの設定ファイルであり、接続プールの設定プロパティが含まれています。

<main id="notice" type='explain'>
  <h4>説明</h4>
  <p> <code>.properties</code> ファイルを使用して、Proxool 接続プールを設定する際は、以下のルールに遵守する必要があります： <ol><li><code>jdbc</code> をプレフィックスとするカスタム名を使用して、各接続プールを識別します。この名前はカスタマイズ可能で、各接続プールを一意に識別するために使用されます。</li><li>Proxool接続プールに関連するプロパティは、<code>proxool.</code> をプレフィックスとするこれらのプロパティは、Proxool接続プール自体のプロパティを設定するために使用されます。</li><li><code>jdbc</code> をプレフィックスとしていないプロパティは無視され、Proxoolでは使用されません。</li><li><code>proxool.</code> をプレフィックスとしていないプロパティは、実際のデータベース接続に渡されます。つまり、これらのプロパティは実際のデータベースドライバーに引き継がれます。</li></ol> Proxool接続プール設定の詳細なメソッドについては、<a href="https://proxool.sourceforge.net/configure.html">Configuration</a>を参照してください。</p>
</main>

本記事の `db.properties` ファイルはプロパティファイルの例であり、`jdbc-1` という名前のデータソースの接続プールプロパティを設定するために使用されます。主に以下の部分が含まれます：

1. データソースのエイリアスを `TEST` に設定します。

    **コード：**

    ```java
    jdbc-1.proxool.alias=TEST
    ```

2. データベース接続パラメータを設定します。

    1. ドライバーのクラス名を設定します。ここでは、OceanBase JDBCドライバーのクラス名 `com.oceanbase.jdbc.Driver` です。
    2. データベース接続のURLを設定します。これには、ホストIPアドレス、ポート番号、アクセスするスキーマが含まれます。
    3. データベースのユーザー名を設定します。
    4. データベースのパスワードを設定します。

    **コード：**

    ```java
    jdbc-1.proxool.driver-class=com.oceanbase.jdbc.Driver
    jdbc-1.proxool.driver-url=jdbc:oceanbase://$host:$port/$schema_name
    jdbc-1.user=$user_name
    jdbc-1.password=$password
    ```

    **パラメータの説明：**

    * `$host`：OceanBaseデータベースへの接続IPアドレス。ODP接続方式ではODPアドレスを使用し、直接接続方式ではOBServerノードのIPアドレスを使用します。
    * `$port`：OceanBaseデータベースへの接続ポート。ODP接続方式のデフォルトポートは`2883`で、ODPデプロイ時にカスタマイズ可能です。直接接続方式のデフォルトポートは`2881`で、OceanBaseデータベースのデプロイ時にカスタマイズ可能です。
    * `$schema_name`：アクセスするスキーマ名です。
    * `$user_name`：テナントの接続アカウント。ODP接続の一般的な形式：`ユーザー名@テナント名#クラスタ名`または`クラスタ名:テナント名:ユーザー名`。直接接続方式の形式：`ユーザー名@テナント名`。
    * `$password`：アカウントのパスワード。

3. 他のProxool接続プールのパラメータを設定します。

    1. 接続プールの最大接続数を8に設定します。
    2. 接続プールの最小接続数を5に設定します。
    3. 接続プールで使用可能な接続数を4に設定します。
    4. 接続プールの詳細モードを有効に設定します。これにより、より多くのログ情報が表示されます。
    5. 接続プールの統計情報のレコード間隔を10秒、1分、1日に設定します。
    6. 接続プールの統計情報がレコードしたログレベルをエラーレベルに設定します。

    **コード：**

    ```java
    jdbc-1.proxool.maximum-connection-count=8
    jdbc-1.proxool.minimum-connection-count=5
    jdbc-1.proxool.prototype-count=4
    jdbc-1.proxool.verbose=true
    jdbc-1.proxool.statistics=10s,1m,1d
    jdbc-1.proxool.statistics-log-level=error
    ```

<main id="notice" type='notice'>
  <h4>注意</h4>
  <p>具体的なプロパティ（パラメータ）の設定は、プロジェクトの要件とデータベースの特性によって異なります。実際の状況に応じて調整と設定を行うことを推奨します。Proxool接続プールの詳細なパラメータについては、<a href="https://proxool.sourceforge.net/properties.html">Properties</a> を参照してください。</p>
</main>

**よく使われる構成パラメータの説明：**

|      設定    |    省略値     |      説明     |
| ------------ | ------------ | ------------ |
| alias | N/A | 接続プールのエイリアスを設定するために使用されます。1つの接続プールを識別するために使用できます。複数の接続プールが存在する場合に役立ちます。|
| driver-class | N/A | データベースドライバーのクラス名を設定するために使用されます。|
| driver-url | N/A | データベース接続URLを設定するために使用されます。これには、ホストIPアドレス、ポート番号、アクセスする必要があるスキーマ、およびオプションのデータベースドライバーのパラメータが含まれます。|
| username | N/A | データベースのユーザー名を設定するために使用されます。|
| password | N/A | データベースのパスワードを設定するために使用されます。|
| maximum-connection-count | 15 | 接続プールの最大接続数を設定するために使用されます。デフォルト値は15で、接続プールは最大15個の接続を作成できることを意味します。|
| minimum-connection-count | 5 | 接続プールの最小接続数を設定するために使用されます。デフォルト値は5で、接続プールは常に少なくとも5つの接続を保持することを意味します。|
| prototype-count | 0 | 接続プールのプロトタイプ接続数を設定するために使用されます。デフォルト値は0で、接続プールが追加の接続を自動的に作成しないことを意味します。|
| verbose | false | 接続プールの詳細出力モードを設定するために使用されます。デフォルト値は `false` で、つまり、サイレントモードです。</br> `verbose` プロパティ `true` に設定すると、接続プールはより詳細な情報を出力します。これにより、開発者がデバッグやモニタリングを行いやすくなります。これらの情報には、接続プールの状態、接続の作成とリリース、接続の利用状況などが含まれる可能性があります。</br> `verbose` モードを有効にすることで、開発者は接続プールの動作状況をより深く理解し、接続の割り当てや回収が正常に行われているかどうかを確認することができます。これは、接続リークやパフォーマンスの問題、およびチューニングのトラブルシューティングに役立ちます。</br> 本番環境では、通常、`verbose` を `true` に設定することは推奨されません。これは、大量の出力情報が生成され、システムのパフォーマンスとログファイルのサイズに影響を与える可能性があるためです。通常は `verbose` を `false`に設定し、必要な場合にのみデバッグやモニタリングを行うために、一時的に有効にすることを推奨します。|
| statistics | null | 統計情報のサンプリングの長さを設定するために使用されます、つまり、接続プールの使用状況の統計です。サンプリングの長さはカンマ（,）で区切られた時間単位として設定可能です。たとえば、`10s,15m` は10秒ごとと15分ごとにサンプリングすることを意味します。使用可能な単位は `s`（秒）、`m`（分）、`h`（時間）、および `d`（日）です。デフォルト値は `null` であり、統計情報の収集を行わないことを意味します。</br> `statistics` プロパティを設定すると、接続プールは、アクティブな接続数、アイドル接続数、接続リクエスト数など、接続プールの統計情報を定期的にサンプリングします。サンプリングの長さにより、統計情報の粒度とサンプリング頻度が決定されます。|
| statistics-log-level | null | 統計情報のログレベルを設定するために使用されます。つまり、ログ統計追跡タイプです。選択可能なログレベルは、`DEBUG`、`INFO`、`WARN`、`ERROR`、および `FATAL` です。デフォルト値は `null` であり、統計情報のログをレコードしないことを意味します。</br> `statistics-log-level` プロパティを設定すると、接続プールは生成された統計情報を指定されたログレベルでレコードします。これらの統計情報には、接続プールの状態、接続の作成とリリース、接続の使用状況などが含まれます。 |
| test-after-use | N/A | 接続がクローズされた後にテストを実行するかどうかを設定するために使用されます。このプロパティを `true` に設定し、`house-keeping-test-sql` プロパティを定義した場合、各接続はクローズ（つまり接続プールに返却される）時にテストが実行されます。接続テストに失敗すると、その接続は破棄されます。</br> 接続プール内の接続は、使用後に通常接続プールに戻され、再利用されます。`test-after-use` プロパティの役割は、接続が接続プールに戻された後に、その接続の可用性と有効性を確認するために、接続をテストすることです。接続テストでは、通常 `house-keeping-test-sql` プロパティで指定されたSQLステートメントを使用します。</br> `test-after-use` 機能を有効にすることで、接続プールは使用できない接続をタイムリーに検出し、接続プールから削除することで、アプリケーションが無効な接続を取得するのを防ぐことができます。これによりアプリケーションの安定性と信頼性を向上させることができます。</br>注意すべき点として、`test-after-use` 機能を使用するためには、事前に `house-keeping-test-sql` プロパティを設定しておく必要があります。このプロパティは、接続テストに使用するSQLステートメントを定義するために使用されます。このようにすると、接続プールは `house-keeping-test-sql` で定義されたルールに基づいて、接続をテストと判断を行うことができます。|
| house-keeping-test-sql | N/A | 接続プール内のアイドル接続をテスト用SQLステートメントの設定に使用されます。接続プールのハウスキーピングスレッドがアイドル接続を検出すると、このSQLステートメントを使用してそれらの接続をテストします。現在の日付の確認操作など、テストのSQLステートメントは非常に高速に実行されるべきです。プロパティを定義しないと、接続テストは実行されません。MySQLモードでは <code>SELECT CURRENT_DATE</code> または <code>SELECT 1</code> を使用できます。Oracleモードでは <code>SELECT sysdate FROM DUAL</code> または <code>SELECT 1 FROM DUAL</code> を使用できます。|
| trace | false | 各SQL呼び出しのログ情報をレコードするかどうかを設定するために使用されます。`true` に設定すると、各SQL呼び出しはログ（`DEBUG` レベル）にレコードされ、実行時間が表示されます。`ConnectionListener`（`ProxoolFacade` を参照）を登録することによっても、これらの情報を取得できます。デフォルト値は `false` です。</br> `trace` 機能を有効にすると、特に高同時実行処理や頻繁なSQL呼び出しの場合に、大量のログが出力される可能性があります。本番環境では、過剰なログ生成やシステムパフォーマンスに不要な影響を与えないため、慎重に使用することを推奨します。|
| maximum-connection-lifetime | 4時間 | 接続の最大ライフサイクルを設定するために使用されます。つまり、接続が破棄されるまでに存在した最長の時間（ミリ秒単位）です。デフォルト値は4時間です。 </br> 接続のライフサイクルとは、接続が作成されてから破棄されるまでの期間のことです。`maximum-connection-lifetime` プロパティを設定することで、接続が接続プール内に存在できる最長時間を制限し、接続が長時間使用されない、またはリソースリークが発生される状況を防ぐことができます。|
| maximum-active-time | 5分 | スレッドの最大アクティブ時間を設定するために使用されます。接続プールのハウスキーピングスレッドが、あるスレッドのアクティブ時間がこの設定を超えたことを検出すると、そのスレッドを終了させます。したがって、このプロパティを想定される最も遅い応答時間よりも大きい値に設定するようにしてください。デフォルト値は5分です。 </br> デーモンは接続プール内の余分な使用可能スレッド（未使用で、この時間を超過したもの）を終了させ、最終的に保持される接続の数は `minimum-connection-count` で指定された数になります。デーモンは、`house-keeping-sleep-time` パラメータで設定された時間間隔で定期的に確認します。|
| maximum-new-connections | N/A | 接続プールが毎回同時に確立した最大の新しい接続数を設定するために使用されます。このプロパティは廃止されました（Deprecated）。代わりに `simultaneous-build-throttle` プロパティの使用を推奨します。|
| simultaneous-build-throttle | 10 | 接続プールが任意の時点で同時に確立できる最大接続数を設定するために使用されます。つまり、これから確立されるが、まだ使用できない新しい接続数の上限のことです。接続の確立には複数のスレッドが使用される可能性があり（たとえば、必要に応じて接続を確立する場合など）、接続の確立を決定してから接続が利用可能になるまでに一定の時間がかかるため、同時に大量のスレッドが接続の確立を決定しないようにする方法が必要です。</br> `simultaneous-build-throttle` プロパティの役割は、接続プールが同時に新しい接続を確立する数を制限することで、接続プールの並行処理を制御することです。最大同時接続数に達すると、新しい接続をリクエストするスレッドは、利用可能な接続ができるか、指定されたタイムアウト時間を超えるまでブロックされます。</br> 適切な `simultaneous-build-throttle` プロパティを設定することで、接続プールのパラレル処理とリソース消費のバランスを取ることができます。デフォルト値は10であり、接続プールが同時に確立できる最大接続数が10であることを意味します。 |
| overload-without-refusal-lifetime | 60 | 接続プールの状態を決定するために使用されます。指定された時間しきい値（ミリ秒単位）内に接続リクエストが拒否された場合、接続プールは過負荷状態にあることを意味します。デフォルト値は60秒です。|
| test-before-use | N/A | 接続を提供する前に、各接続をテストするかどうかを設定するために使用されます。このプロパティを `true` に設定すると、アプリケーションに接続を提供する前に、各接続は、事前に定義されたテストSQL（`house-keeping-test-sql` プロパティで定義）を実行してテストされます。接続テストに失敗すると、その接続は破棄され、接続プールは別の使用可能な接続を選択します。すべての接続がテストに失敗した場合、新しい接続が作成されます。新しい接続テストが失敗した場合、`SQLException` がスローされます。</br> 注意すべき点として、MySQLデータベースには、接続パラメータに `autoReconnect=true` パラメータを追加する必要があります。そうしなければ、`test-before-use` パラメータを有効にしても再接続できません。|
| fatal-sql-exception | null | SQL例外の検出と処理を設定するために使用されます。これは、カンマ（,）で区切られたメッセージフラグメントのリストです。`SQLException` が発生した場合、そのメッセージとこれらのメッセージフラグメントが照合されます。いずれかのメッセージフラグメント（大文字と小文字を区別）が含まれている場合、致命的なSQL例外と見なされます。これにより、接続が破棄されます。どのような状況が発生しても、例外は再スローされ、ユーザーに何が起きたかを理解できるようにします。また、異なる例外がスローされるように設定することもできます（`fatal-sql-exception-wrapper-class` プロパティを参照します）。デフォルト値は `null` です。</br> 注意すべき点として、`fatal-sql-exception-wrapper-class` プロパティを設定した場合、代替の例外クラスをスローするように設定できます。これにより、SQL例外の処理方法をカスタマイズできます。|
| fatal-sql-exception-wrapper-class | null | 致命的なSQL例外の例外ラップを設定するために使用されます。`fatal-sql-exception` プロパティが設定されている場合、デフォルトの動作は、致命的な `SQLException` を引き起こす例外を破棄し、元の例外をユーザーに直接スローすることです。このプロパティを使用すると、`SQLException` を別の例外でラップできます。この例外は、`SQLException` または `RuntimeException` を継承している限り、任意のクラスを指定できます。Proxoolには、例外クラスを自分で作成したくない場合に使用できる2つのクラスを提供しています：`FatalSQLException` および `FatalRuntimeException`。これらのクラスを使用するには、必要に応じてこのプロパティを `org.logicalcobwebs.proxool.FatalSQLException` または `org.logicalcobwebs.proxool.FatalRuntimeException` に設定する必要があります。デフォルト値は `null` であり、致命的な `SQLException` をラップしないことを意味します。デフォルト値はnullです。</br> 注意すべき点として、例外ラップクラスは `SQLException` または `RuntimeException` のサブクラスである必要があります。|
| house-keeping-sleep-time | 30秒 | 接続プールのハウスキーピングスレッド（house keeping thread）のスリープ時間を設定するために使用されます。ハウスキーピングスレッドは、すべての接続の状態をチェックし、接続を破棄または作成する必要があるかどうかを判断します。デフォルト値は30秒であり、ハウスキーピングスレッドが30秒ごとにハウスキーピングタスクを実行することを意味します。|
| injectable-connection-interface | N/A | Proxoolが委任されたConnectionオブジェクトで定義されたメソッドを実行できるようにするために使用されます。|
| injectable-statement-interface | N/A | Proxoolが委任されたStatementオブジェクトで定義されたメソッドを実行できるようにするために使用されます|
| injectable-prepared-statement-interface | N/A | Proxoolが委任されたPreparedStatementオブジェクトで定義されたメソッドを実行できるようにするために使用されます。|
| injectable-callable-statement-interface | N/A | Proxoolが委任されたCallableStatementオブジェクトで定義されたメソッドを実行できるようにするために使用されます。|
| jndi-name | N/A | 接続プールがJNDI（Java Naming and Directory Interface）に登録される名前を指定するために使用されます。|

### Main.javaコードの紹介

`Main.java` ファイルは、サンプルプログラムの一部であり、Proxool接続プールを使用してデータベース接続を取得し、一連のデータベース操作を実行する方法を示しています。これには、テーブルの作成、データの挿入、データの削除、データの更新、データのクエリ、およびクエリ結果の出力が含まれます。

本記事の `Main.java` ファイルのコードには、主に以下のいくつの部分が含まれます：

1. 必要なクラスとインターフェースをインポートします。

    コードが属するパッケージを定義し、ProxoolとJDBC関連のクラスをインポートします。これらのクラスは、データベース接続プールの設定と管理の実現、およびSQLステートメントの実行に使用されます。Proxool接続プールを使用することで、データベース操作のパフォーマンスと信頼性を向上させることができます。具体的な手順は以下のとおりです：

    1. コードが属するパッケージを `com.example` と定義しており、このパッケージは現在のJavaクラスを格納するために使用されます。
    2. Proxoolの設定クラス `org.logicalcobwebs.proxool.configuration.PropertyConfigurator` をインポートします。
    3. 設定ファイルを読み取るための入力ストリームクラス `java.io.InputStream` をインポートします。
    4. JDBCのConnectionクラス `java.sql.Connection` をインポートします。
    5. JDBCのDriverManagerクラス `java.sql.DriverManager` をインポートします。
    6. JDBCのResultSetクラス `java.sql.ResultSet` をインポートします。
    7. JDBCのStatementクラス `java.sql.Statement`をインポートします。
    8. 設定ファイルをロードするためのPropertiesクラス `java.util.Properties` をインポートします。

    **コード：**

    ```java
    package com.example;

    import org.logicalcobwebs.proxool.configuration.PropertyConfigurator;
    import java.io.InputStream;
    import java.sql.Connection;
    import java.sql.DriverManager;
    import java.sql.ResultSet;
    import java.sql.Statement;
    import java.util.Properties;
    ```

2. クラス名とメソッドを定義します。

    Javaプログラムのエントリメソッドを定義し、設定ファイルを読み取ることによってデータベース接続情報を取得します。Proxoolドライバーを使用してデータベース接続を確立した後、定義済みのメソッドを順に呼び出して、DDLステートメント、DMLステートメント、およびクエリステートメントを実行します。発生する可能性のある例外情報をキャッチして出力します。このコードの目的は、データベース関連の操作を実行し、ロガーを使用してログをレコードすることです。具体的な手順は以下のとおりです：

    1. `Main` という名前のpublicクラスを定義しました。

       1. `DB_PROPERTIES_FILE` という名前のプライベート静的定数を定義しました。データベース設定（プロパティ）ファイルのパスを示します。この定数は、コード内でインポートすることでき、プロパティファイルのロードと読み込みに使用されます。
       2. プログラムの実行開始点として、public staticメソッド `main` を定義します。

           1. 例外が発生する可能性のあるコードブロックをキャッチするために使用されます。

               1. `Properties` オブジェクトを作成します。設定ファイル内のプロパティを読み取るために使用されます。
               2. Mainクラスのクラスローダーを使用して、設定ファイルの入力ストリームを取得します。
               3. ロードされた入力ストリームを使用して設定ファイルをロードし、プロパティを `Properties` オブジェクトにロードします。
               4. ロードされたプロパティを使用して接続プールを設定します。
               5. Proxoolデータベースドライバーを動的にロードします。
               6. Proxoolドライバーを使用してデータベース接続を確立します。
               7. `Statement` オブジェクトを作成します。
               8. 定義済みのメソッド `executeDDLStatements()` を呼び出して、DDLステートメントを実行します。これは、テーブルを作成する操作です。
               9. 定義済みのメソッド `executeDMLStatements()` を呼び出して、DMLステートメントを実行します。これは、データの挿入、更新、削除を行う操作です。
               10. 定義済みのメソッド `executeQueryStatements()` を呼び出し、クエリステートメントを実行して、データを取得します。

           2. 発生する可能性のある例外情報をキャッチして出力します。

    2. テーブルの作成、DMLステートメントの実行、データのクエリを行うためのメソッドを定義します。

    **コード：**

    ```java
    public class Main {
        private static final String DB_PROPERTIES_FILE = "/db.properties";

        public static void main(String[] args) {
            try {
                Properties properties = new Properties();
                InputStream is = Main.class.getResourceAsStream(DB_PROPERTIES_FILE);
                properties.load(is);
                PropertyConfigurator.configure(properties);

                Class.forName("org.logicalcobwebs.proxool.ProxoolDriver");
                try (Connection conn = DriverManager.getConnection("proxool.TEST");
                    Statement stmt = conn.createStatement()) {
                    executeDDLStatements(stmt);
                    executeDMLStatements(stmt);
                    executeQueryStatements(stmt);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        // テーブルを作成するためのメソッドを定義する
        // DMLステートメントを実行するためのメソッドを定義する
        // データをクエリするためのメソッドを定義する
    }
    ```

3. テーブルを作成するためのメソッドを定義します。

    プライベート静的メソッド `executeDDLStatements()` を定義します。このメソッドはDDL（データ定義言語）ステートメントを実行するために使用され、テーブルを作成するステートメントが含まれます。具体的な手順は以下のとおりです：

    1. プライベート静的メソッド `executeDDLStatements()` を定義します。このメソッドは `Statement` オブジェクトをパラメータとして受け取り、`Exception` 例外をスローする可能性があります。
    2. `execute()` メソッドを使用してSQLステートメントを実行し、`test_proxool` という名前のテーブルを作成します。このテーブルには、`c1` と `c2` の2つの列があり、それぞれ `NUMBER` タイプと `VARCHAR2(32)` タイプです。

    **コード：**

    ```java
        private static void executeDDLStatements(Statement stmt) throws Exception {
            stmt.execute("CREATE TABLE test_proxool (c1 NUMBER, c2 VARCHAR2(32))");
        }
    ```

4. DMLステートメントを実行するためのメソッドを定義します。

    プライベート静的メソッド `executeDMLStatements()` を定義します。このメソッドは、DML（データ操作言語）ステートメントを実行するために使用され、データの挿入、データの削除、およびデータの更新のステートメントが含まれます。具体的な手順は以下のとおりです：

    1. プライベート静的メソッド `executeDMLStatements()` を定義します。このメソッドは `Statement` オブジェクトをパラメータとして受け取ります。実行中に例外が発生した場合、メソッドは `Exception` 例外をスローします。
    2. `for` ループを使用して、1から10までイテレーションします。ループ内で、`execute()` メソッドを使用してSQL挿入ステートメントを実行し、変数 `i` と関連する文字列値を `test_proxool` テーブルに挿入します。
    3. SQL削除ステートメントを実行し、`test_proxool` テーブルから `c1` 列の値が5以下の行を削除します。
    4. SQL更新ステートメントを実行し、`test_proxool` テーブルの `c1` 列の値が6である行の `c2` 列を `test_update` に更新します。

    **コード：**

    ```java
        private static void executeDMLStatements(Statement stmt) throws Exception {
            for (int i = 1; i <= 10; i++) {
                stmt.execute("INSERT INTO test_proxool VALUES (" + i + ",'test_insert" + i + "')");
            }
            stmt.execute("DELETE FROM test_proxool WHERE c1 <= 5");
            stmt.execute("UPDATE test_proxool SET c2 = 'test_update' WHERE c1 = 6");
        }
    ```

5. データのクエリを行うためのメソッドを定義します。

    プライベート静的メソッド `executeQueryStatements()` を定義します。このメソッドは `SELECT` クエリステートメントを実行して結果を処理するために使用されます。具体的な手順は以下のとおりです：

    1. プライベート静的メソッド `executeQueryStatements()`を定義します。このメソッドは `Statement` オブジェクトをパラメータとして受け取ります。実行中に例外が発生した場合、メソッドは `Exception` 例外をスローします。
    2. `executeQuery()` メソッドを使用して `SELECT` クエリステートメントを実行し、結果を `ResultSet` オブジェクトの `rs` にストレージします。ここでは、クエリは `test_proxool` テーブルのすべてのデータを返します。`try-with-resources` ステートメントを使用することで、`ResultSet` を使用後、自動的にクローズされるようにします。
    3. `while` ループと `next()` メソッドを使用して、`ResultSet` オブジェクト `rs` 内の各行データをイテレーションします。各イテレーションにおいて、`rs.next()` メソッドはポインタを結果セットの次の行に移動します。次の行のデータが利用可能な場合、このメソッドは `true` を返し、そうでなければ `false` を返します。`while` ループ内で、`rs.next()` が `true` を返す限り、さらに多くの行データが利用可能であることを示します。ループ内のコードが実行され、現在の行のデータが処理されます。すべての行のデータ処理が終了すると、`rs.next()` は `false` を返し、ループは終了します。
    4. `getInt()` および `getString()` メソッドを使用して、現在の行の指定された列名の値を取得し、コンソールに出力します。ここでは、`c1` 列と `c2` 列の値が出力されました。`getInt()` メソッドは整数値を取得するために使用され、`getString()` メソッドは文字列値を取得するために使用されます。

    **コード：**

    ```java
        private static void executeQueryStatements(Statement stmt) throws Exception {
            try (ResultSet rs = stmt.executeQuery("SELECT * FROM test_proxool")) {
                while (rs.next()) {
                    System.out.println(rs.getInt("c1") + "   " + rs.getString("c2"));
                }
            }
        }
    ```

### 全コード表示

:::tab
tab pom.xml

```java
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.oceanbase</groupId>
    <artifactId>proxool-oceanbase-client</artifactId>
    <version>1.0-SNAPSHOT</version>
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <configuration>
                    <source>8</source>
                    <target>8</target>
                </configuration>
            </plugin>
        </plugins>
    </build>

    <dependencies>
        <dependency>
            <groupId>com.oceanbase</groupId>
            <artifactId>oceanbase-client</artifactId>
            <version>2.4.2</version>
        </dependency>
        <dependency>
            <groupId>proxool</groupId>
            <artifactId>proxool-cglib</artifactId>
            <version>0.9.1</version>
        </dependency>
        <dependency>
            <groupId>proxool</groupId>
            <artifactId>proxool</artifactId>
            <version>0.9.1</version>
        </dependency>
        <dependency>
            <groupId>commons-logging</groupId>
            <artifactId>commons-logging</artifactId>
            <version>1.2</version>
        </dependency>
    </dependencies>
</project>
```

tab db.properties

```java
#alias: the alias of the data source
jdbc-1.proxool.alias=TEST
#driver-class: driver name
jdbc-1.proxool.driver-class=com.oceanbase.jdbc.Driver
#driver-url: url connection string, username and password must be determined
jdbc-1.proxool.driver-url=jdbc:oceanbase://$host:$port/$schema_name
jdbc-1.user=$user_name
jdbc-1.password=$password
#The maximum number of database connections. The default is 15
jdbc-1.proxool.maximum-connection-count=8
#The minimum number of database connections, defaults to 5
jdbc-1.proxool.minimum-connection-count=5
#The number of available connections in the Connection pool. If the number of connections in the current Connection pool is less than this value, new connections will be established (assuming that the maximum number of available connections is not exceeded). For example, if we have three active connections and two available connections, and our prototype count is 4, the database Connection pool will try to establish another two connections. This is different from the minimum connection count Minimum connection count also counts active connections. Prototype count is the number of spare connections
jdbc-1.proxool.prototype-count=4
#verbose: detailed information settings. Parameter bool value
jdbc-1.proxool.verbose=true
#statistics: connection pool usage statistics. Parameter "10s, 1m, 1d"
jdbc-1.proxool.statistics=10s,1m,1d
#statistics-log-level:  log statistics tracking type. Parameter 'ERROR' or 'INFO'
jdbc-1.proxool.statistics-log-level=error
```

tab Main.java

```java
package com.example;

import org.logicalcobwebs.proxool.configuration.PropertyConfigurator;
import java.io.InputStream;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.util.Properties;

public class Main {
    private static final String DB_PROPERTIES_FILE = "/db.properties";

    public static void main(String[] args) {
        try {
            Properties properties = new Properties();
            InputStream is = Main.class.getResourceAsStream(DB_PROPERTIES_FILE);
            properties.load(is);
            PropertyConfigurator.configure(properties);

            Class.forName("org.logicalcobwebs.proxool.ProxoolDriver");
            try (Connection conn = DriverManager.getConnection("proxool.TEST");
                Statement stmt = conn.createStatement()) {
                executeDDLStatements(stmt);
                executeDMLStatements(stmt);
                executeQueryStatements(stmt);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static void executeDDLStatements(Statement stmt) throws Exception {
        stmt.execute("CREATE TABLE test_proxool (c1 NUMBER, c2 VARCHAR2(32))");
    }

    private static void executeDMLStatements(Statement stmt) throws Exception {
        for (int i = 1; i <= 10; i++) {
            stmt.execute("INSERT INTO test_proxool VALUES ("+ i +",'test_insert" + i + "')");
        }
        stmt.execute("DELETE FROM test_proxool WHERE c1 <= 5");
        stmt.execute("UPDATE test_proxool SET c2 = 'test_update' WHERE c1 = 6");
    }

    private static void executeQueryStatements(Statement stmt) throws Exception {
        try (ResultSet rs = stmt.executeQuery("SELECT * FROM test_proxool")) {
            while (rs.next()) {
                System.out.println(rs.getInt("c1") + "   " + rs.getString("c2"));
            }
        }
    }
}
```

:::

## 関連ドキュメント

* OceanBase Connector/Jの詳細については、[OceanBase JDBCドライバー](https://en.oceanbase.com/docs/oceanbase-connector-j-en)を参照してください。
* Proxool接続プールを使用する情報については、[Introduction for Users](https://proxool.sourceforge.net/user.html)を参照してください。
