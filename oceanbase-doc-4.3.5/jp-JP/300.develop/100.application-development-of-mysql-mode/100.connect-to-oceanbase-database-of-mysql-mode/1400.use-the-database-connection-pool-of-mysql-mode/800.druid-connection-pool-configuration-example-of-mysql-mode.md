|description||
|---|---|
|keywords||
|dir-name|Druid|
|dir-name-en||
|tenant-type|MySQL Mode|

# Druid

本記事では、Druid接続プール、MySQL Connector/J、およびOceanBaseデータベースを使用してアプリケーションを構築し、テーブルの作成、データの挿入、更新、削除、クエリ、テーブルの削除など、基本的なデータベース操作を実現する方法について説明します。

<div role="videolist">
      <a role='link' href='https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/connection-pool/druid-mysql-client/druid-mysql-client.zip'>
          <img src='https://file.oceanbase.com/doc/img/lQLPJyFovGIOcJQWFrAqhLlgRRsPvwU-H7hJ_i0A_22_22.png'/>
          druid-mysql-clientサンプルプロジェクトをダウンロード
      </a>
      <!-- <a role='video' href='https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/video-center/video/video/06%20druid-mysql-client.mp4'>
          <img src='https://mdn.alipayobjects.com/huamei_22khvb/afts/img/A*DFPmToHK6hgAAAAAAAAAAAAADiGDAQ/original'/>
          Druid 连接池连接 OceanBase 数据库示例程序（MySQL 模式）
      </a> -->
</div>

## 前提条件

* OceanBaseデータベースがインストールされており、MySQLモードのテナントが作成されていること。
* JDK 1.8とMavenがインストール済みであること。
* Eclipseがインストールされていること。

    <main id="notice" type='explain'>
    <h4>説明</h4>
    <p>この記事でコードの実行にはEclipse IDE for Java Developers 2022-03バージョンを使用しています。ご自身の好みに合わせて、適切なツールを選択してサンプルコードを実行することも可能です。</p>
    </main>

## 操作手順

<main id="notice" type='explain'>
  <h4>説明</h4>
  <p>本記事の操作手順はWindows環境に基づいています。他のOS環境やコンパイラを使用する場合は、操作手順が若干異なる場合があります。</p>
</main>

1. `druid-mysql-client`プロジェクトをEclipseにインポートします。
2. OceanBaseデータベースのURLを取得します。
3. `druid-mysql-client`プロジェクト内のデータベース接続情報を修正します。
4. `druid-mysql-client`プロジェクトを実行します。

### ステップ１：druid-mysql-clientプロジェクトをEclipseにインポートする

1. Eclipseを開き、メニューバーから**File**->**Open Projects from File System**を選択します。

2. ポップアップダイアログで、**Directory**ボタンをクリックしてプロジェクトのディレクトリを選択し、**Finish**をクリックしてインポートを完了します。

    <main id="notice" type='explain'>
      <h4>説明</h4>
      <p>Eclipseを使用してMavenプロジェクトをインポートすると、Eclipse がプロジェクト内の <code>pom.xml</code> ファイルを自動的に検出するとともに、ファイルに記述された依存関係に基づいて、必要な依存ライブラリを自動的にダウンロードし、プロジェクトに追加します。</p>
    </main>

    ![1](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/connection-pool/druid-mysql-client/1.png)

3. プロジェクトの状況を確認します。

    ![2](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/connection-pool/druid-mysql-client/2.png)

### ステップ2：OceanBaseデータベースのURLを取得する

1. OceanBaseデータベースのデプロイ担当者または管理者から、該当するデータベース接続文字列を取得します。

    **例：**

    ```shell
    obclient -hxxx.xxx.xxx.xxx -P2881 -utest_user001@mysql001 -p****** -Dtest
    ```

    接続文字列に関するその他の詳細については、[OBClientによるOceanBaseテナントへの接続](../300.connect-to-an-oceanbase-tenant-by-using-obclient-of-mysql-mode.md)を参照してください。

2. OceanBaseデータベース接続文字列の情報に基づいて、以下のURLの対応する情報を入力します。

    ```shell
    jdbc:mysql://$host:$port/$database_name?user=$user_name&password=$password&useSSL=false
    ```

    **パラメータの説明：**

    * `$host`：OceanBaseデータベースへの接続IPアドレス。OceanBaseデータベースプロキシ(OceanBase Database Proxy、ODP)接続方式ではODPアドレスを使用し、直接接続方式ではOBServerノードのIPアドレスを使用します。
    * `$port`：OceanBaseデータベースへの接続ポート。ODP接続方式のデフォルトポートは`2883`で、ODPデプロイ時にカスタマイズ可能です。直接接続方式のデフォルトポートは`2881`で、OceanBaseデータベースのデプロイ時にカスタマイズ可能です。
    * `$database_name`：アクセス対象のデータベース名。

        <main id="notice" type='notice'>
          <h4>注意</h4>
          <p>テナントに接続するユーザーは、そのデータベースに対して、<code>CREATE</code>、<code>DROP</code>、<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>、<code>SELECT</code> 権限が付与されていなければなりません。その他のユーザー権限の詳細については、<a href="https://en.oceanbase.com/docs/common-oceanbase-database-10000000001974111">MySQLモードでの権限分類</a>を参照してください。</p>
        </main>

    * `user_name`：テナントの接続アカウント。ODP接続の一般的な形式：`ユーザー名@テナント名#クラスタ名`または`クラスタ名:テナント名:ユーザー名`。直接接続方式の形式：`ユーザー名@テナント名`
    * `password`：アカウントのパスワード。

    その他のMySQL Connector/Jの接続プロパティの詳細については、[Configuration Properties](https://dev.mysql.com/doc/connector-j/en/connector-j-reference-configuration-properties.html)を参照してください。

    **例：**

    ```shell
    jdbc:mysql://xxx.xxx.xxx.xxx:2881/test?user=test_user001@mysql001&password=******&useSSL=false
    ```

### ステップ3：druid-mysql-clientプロジェクト内のデータベース接続情報を修正する

**ステップ2：OceanBaseデータベースのURLを取得する**に記載されている情報に基づいて、`druid-mysql-client/src/main/resources/db.properties`ファイル内のデータベース接続情報を修正します。

![3](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/connection-pool/druid-mysql-client/3.png)

**例：**

* OBServerノードのIPアドレスは`xxx.xxx.xxx.xxx`です。
* アクセスポートは2881を使用します。
* アクセスするデータベース名は`test`です。
* テナントの接続アカウントは`test_user001@mysql001`です。`test_user001`がユーザー名、`mysql001`がテナント名を表します。この`mysql001`は、OceanBaseデータベース上にMySQLモードで作成されたテナントです。
* パスワードは`******`です。

**コード：**

```java
...
url=jdbc:mysql://xxx.xxx.xxx.xxx:2881/test?useSSL=false
username=test_user001@mysql001
password=******
...
```

### ステップ4：druid-mysql-clientプロジェクトを実行する

1. プロジェクトナビゲータービューで、**druid-mysql-client/src/main/java**ディレクトリを見つけて展開します。

2. **Main.java**ファイルを右クリックし、**Run As**->**Java Application**を選択します。

    ![4](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/connection-pool/druid-mysql-client/4.png)

3. Eclipseのコンソールウィンドウで出力結果を確認します。

    ![5](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/connection-pool/druid-mysql-client/5.png)

## プロジェクトコードについて

[druid-mysql-client](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/connection-pool/druid-mysql-client/druid-mysql-client.zip)をクリックしてプロジェクトコードをダウンロードします。これは、`druid-mysql-client.zip`という名前の圧縮ファイルです。

解凍すると、`druid-mysql-client`という名前のフォルダが作成されます。ディレクトリ構造は以下のとおりです：

```shell
druid-mysql-client
├── src
│   └── main
│       ├── java
│       │   └── com
│       │       └── example
│       │           └── Main.java
│       └── resources
│           └── db.properties
└── pom.xml
```

**ファイルの説明：**

* `src`：ソースコードのルートディレクトリです。
* `main`：アプリケーションの主要なロジックを含むメインコードディレクトリです。
* `java`：Javaソースコードディレクトリです。
* `com`：Javaパッケージディレクトリです。
* `example`：サンプルプロジェクトのパッケージディレクトリです。
* `Main.java`：テーブルの作成、データの挿入、削除、更新、およびクエリなどのロジック処理を含むメインクラスプログラムのサンプルファイルです。
* `resources`：設定ファイルなどを含むリソースファイルディレクトリです。
* `db.properties`：接続プールの設定ファイルには、データベース接続に関するパラメータが含まれています。
* `pom.xml`：プロジェクトの依存関係とビルド設定を管理するために使用するMavenプロジェクトの設定ファイルです。

### pom.xmlコードの紹介

`pom.xml`ファイルはMavenプロジェクトの設定ファイルで、プロジェクトの依存関係、プラグイン、ビルドルールなどの情報を定義しています。MavenはJavaプロジェクト管理ツールで、依存関係のダウンロード、プロジェクトのコンパイル、パッケージングなどの操作を自動化できます。

本記事の`pom.xml`ファイルのコードは、主に以下のいくつかの部分が含まれます：

1. ファイル宣言ステートメントです。

    このファイルがXMLファイルであり、使用しているXMLのバージョンが`1.0`で、文字エンコーディング方式が`UTF-8`であることを宣言しています。

    **コード：**

    ```java
    <?xml version="1.0" encoding="UTF-8"?>
    ```

2. POMのネームスペースとPOMモデルのバージョンを設定します。

    1. `xmlns`を使用して、POMのネームスペースを`http://maven.apache.org/POM/4.0.0`と指定します。
    2. `xmlns:xsi`を使用して、XMLネームスペースを`http://www.w3.org/2001/XMLSchema-instance`と指定します。
    3. `xsi:schemaLocation`を使用して、POMのネームスペースを`http://maven.apache.org/POM/4.0.0`、POMのXSDファイルの場所を`http://maven.apache.org/xsd/maven-4.0.0.xsd`と指定します。
    4. `<modelVersion>`要素を使用して、このPOMファイルで使用されるPOMモデルバージョンを`4.0.0`と指定します。

    **コード：**

    ```java
    <project xmlns="http://maven.apache.org/POM/4.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
      <modelVersion>4.0.0</modelVersion>

     <!-- その他の設定 -->

    </project>
    ```

3. 基本情報を設定します。

    1. `<groupId>`を使用して、プロジェクトが属する組織を`com.example`と指定します。
    2. `<artifactId>`を使用して、プロジェクトの名前を`druid-mysql-client`と指定します。
    3. `<version>`を使用して、プロジェクトのバージョン番号を`1.0-SNAPSHOT`と指定します。

    **コード：**

    ```java
        <groupId>com.example</groupId>
        <artifactId>druid-mysql-client</artifactId>
        <version>1.0-SNAPSHOT</version>
    ```

4. プロジェクトソースファイルのプロパティを設定します。

    Mavenのコンパイラプラグインを`maven-compiler-plugin`と指定し、ソースコードとターゲットJavaバージョンをどちらも8に設定しています。これは、プロジェクトのソースコードがJava 8の機能を使用して記述されており、コンパイルされたバイトコードもJava 8ランタイム環境と互換性があることを意味します。この設定により、プロジェクトはコンパイル時および実行時にJava 8の構文と機能を正しく処理できるようになります。

    <main id="notice" type='explain'>
      <h4>説明</h4>
      <p>Java 1.8とJava 8は、同じバージョンの異なる命名ルールです。</p>
    </main>

    **コード：**

    ```java
        <build>
            <plugins>
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-compiler-plugin</artifactId>
                    <configuration>
                        <source>8</source>
                        <target>8</target>
                    </configuration>
                </plugin>
            </plugins>
        </build>
    ```

5. プロジェクトが依存するコンポーネントを設定します。

    1. データベースとのインタラクションを行うために、`mysql-connector-java`依存ライブラリを追加します。

       1. `<groupId>`：`mysql`
       2. `<artifactId>`：`mysql-connector-java`
       3. `<version>`：`5.1.40`

        **コード：**

        ```java
                <dependency>
                    <groupId>mysql</groupId>
                    <artifactId>mysql-connector-java</artifactId>
                    <version>5.1.40</version>
                </dependency>
        ```

    2. `druid`依存ライブラリを追加する：

       1. `<groupId>`：`com.alibaba`
       2. `<artifactId>`：`druid`
       3. `<version>`：`1.2.8`

        **コード：**

        ```java
                <dependency>
                    <groupId>com.alibaba</groupId>
                    <artifactId>druid</artifactId>
                    <version>1.2.8</version>
                </dependency>
        ```

### db.propertiesコードの紹介

`db.properties`は本記事の例となる接続プールの設定ファイルであり、接続プールの設定プロパティが含まれています。これらのプロパティには、データベースURL、ユーザー名、パスワード、接続プールのその他のオプションが含まれます。

本記事の`db.properties`ファイルのコードは、主に以下のいくつかの部分が含まれます：

1. データベース接続パラメータを設定します。

    1. データベースドライバーのクラス名を`com.mysql.jdbc.Driver`と指定します。
    2. データベース接続のURLを指定します。これにはホストIPアドレス、ポート番号、アクセスする必要があるSchemaが含まれます。
    3. データベースのユーザー名を指定します。
    4. データベースのパスワードを指定します。

    **コード：**

    ```java
    driverClassName=com.mysql.jdbc.Driver
    url=jdbc:oceanbase://$host:$port/$database_name?useSSL=false
    username=$user_name
    password=$password
    ```

    **パラメータの説明：**

    * `$host`：OceanBaseデータベースへの接続IPアドレス。ODP接続方式ではODPアドレスを使用し、直接接続方式ではOBServerノードのIPアドレスを使用します。
    * `$port`：OceanBaseデータベースへの接続ポート。ODP接続方式のデフォルトポートは`2883`で、ODPデプロイ時にカスタマイズ可能です。直接接続方式のデフォルトポートは`2881`で、OceanBaseデータベースのデプロイ時にカスタマイズ可能です。
    * `$database_name`：アクセス対象のデータベース名。
    * `$user_name`：テナントの接続アカウント。ODP接続の一般的な形式：`ユーザー名@テナント名#クラスタ名`または`クラスタ名:テナント名:ユーザー名`。直接接続方式の形式：`ユーザー名@テナント名`
    * `$password`：アカウントのパスワード。

2. 他の接続プールのパラメータを設定します。

    1. 接続を検証するためのSQLステートメント`select 1`を指定します。
    2. 接続プールの初期接続数を3に指定すると、接続プール起動時に3つの初期接続が作成されることを意味します。
    3. 接続プールの最大アクティブ接続数を30と指定します。これは、接続プール内で同時に最大30個の接続を保持できることを意味します。
    4. 廃棄された接続のログを出力するかどうかを`true`に指定すると、廃棄された接続が回収された際に、エラーログに情報が出力されることを意味します。テスト環境では`true`に設定できますが、本番環境ではパフォーマンスへの影響を避けるため`false`に設定してください。
    5. 接続プールの最小アイドル接続数を5に設定すると、接続プール内のアイドル接続数が5未満になった場合、接続プールは自動的に新しい接続を作成することを意味します。
    6. 接続取得の最大待機時間を1000ミリ秒に指定すると、接続プール内のすべての接続が使用中で、待機時間が1000ミリ秒を超える場合、接続取得操作がタイムアウト例外がスローされることを意味します。
    7. アイドル状態での最小保持時間を300000ミリ秒に指定します。これは、接続がアイドル状態になってから300000ミリ秒（5分）を経過しても使用されなかった場合に回収されることを意味します。
    8. 廃棄された接続を回収されるかどうかを`true`に指定すると、接続が`removeAbandonedTimeout`で定義された時間を超えた場合に回収されることを意味します。
    9. 廃棄された接続のタイムアウトを300秒に指定すると、300秒（5分）を経過しても使用されなかった場合に接続が回収されることを意味します。
    10. アイドル接続の回収スレッドの運用間隔を10000ミリ秒に指定すると、10000ミリ秒（10秒）ごとに、アイドル接続の回収スレッドがアイドル接続の回収操作を実行することを意味します。
    11. 接続を取得する際に接続の可用性を検証するかどうかを`false`に設定します。`false`に設定するとパフォーマンスが向上しますが、取得した接続が使用できない可能性もあります。
    12. 接続を返す際に接続の可用性を検証するかどうかを`false`に設定します。`false`に設定するとパフォーマンスが向上しますが、返された接続が使用できない可能性もあります。
    13. 接続がアイドル状態の場合に検証を行うかどうかを`true`と指定します。`true`に設定した場合、接続プールは定期的に`validationQuery`を実行し、接続の可用性を検証します。
    14. 接続の長時間キープアライブ機能の有効化を起動するかどうかを`false`と指定します。`false`に設定すると、接続の長時間キープアライブの無効化を意味します。
    15. 接続のアイドルタイムのしきい値を60000ミリ秒に指定すると、接続のアイドルタイムが設定されたしきい値60000ミリ秒（1分）を超えた場合、接続のキープアライブメカニズムによってその接続を検出し、接続の可用性を確保します。しきい値時間内に接続に対して何らかの操作が行われた場合は、接続のアイドル時間が再計算されます。

    **コード：**

    ```java
    validationQuery=select 1
    initialSize=3
    maxActive=30
    logAbandoned=true
    minIdle=5
    maxWait=1000
    minEvictableIdleTimeMillis=300000
    removeAbandoned=true
    removeAbandonedTimeout=300
    timeBetweenEvictionRunsMillis=10000
    testOnBorrow=false
    testOnReturn=false
    testWhileIdle=true
    keepAlive=false
    keepAliveBetweenTimeMillis=60000
    ```

<main id="notice" type='notice'>
  <h4>注意</h4>
  <p>具体的なプロパティ（パラメータ）の設定は、プロジェクトの要件とデータベースの特性によって異なります。実際の状況に応じて調整と設定を行うことを推奨します。</p>
</main>

**Druid接続プールでよく使われる構成パラメータ：**

| パラメータ | 説明 |
| ------ | ------ |
| url | データベースタイプ、ホスト名、ポート番号、データベースの名前などの情報を含む、データベースに接続するURLを指定します。|
| username | データベースに接続するために必要なユーザー名を指定します。|
| password | データベースに接続するために必要なパスワードを指定します。|
| driverClassName | データベースドライバーのクラス名を指定します。明示的に`driverClassName`を設定しないと、Druid接続プールは`url`に基づいてデータベースタイプ（dbType）を自動的に識別し、対応する`driverClassName`を選択します。この自動識別メカニズムにより、設定作業の負荷が軽減され、設定プロセスを簡素化できます。ただし、注意が必要な点として、`url`が正しく解析できない場合、または非標準のデータベースドライバークラスを使用する必要がある場合は、`driverClassName`パラメータを明示的に設定して、正しいドライバークラスがロードされるように確保する必要があります。|
| initialSize | 接続プールの初期化時に作成される接続数を指定します。アプリケーションが起動する際、接続プールは指定された数の接続を作成し、接続プールに格納します。|
| maxActive | 接続プール内の最大アクティブ接続数を指定します。接続プールのアクティブ接続数が最大値に達すると、その後の接続リクエストは、接続が解放されるまで待機します。|
| maxIdle | 接続プール内の最大アイドル接続数を指定します（このプロパティは既に廃止されました）。接続プールのアイドル接続数が最大値に達すると、余分な接続は閉じられます。|
| minIdle | 接続プール内の最小アイドル接続数を指定します。接続プールのアイドル接続数が最小値を下回ると、接続プールは新しい接続を作成します。|
| maxWait | 接続を取得する最大待機時間を指定します。この時間を超えると例外がスローされます。正の値に設定すると、待機するミリ秒数を表し、この時間を超過すると例外がスローされます。|
| poolPreparedStatements | `PreparedStatement`のキャッシュ（PSCache）メカニズムを有効にするかどうかを指定します。`true`に設定すると、`PreparedStatement`オブジェクトがキャッシュされてパフォーマンスが向上しますが、OBProxyのメモリが継続的に増加する可能性があることに注意してください。このようなシナリオでは、メモリリークやメモリオーバーフローを防ぐため、メモリの使用状況を適切に設定およびモニタリングする必要があります。|
| validationQuery | 接続を検証するためのSQLクエリステートメントを指定します。接続プールから接続が取得されると、このクエリステートメントが実行され、接続が有効かどうかが検証されます。|
| timeBetweenEvictionRunsMillis | 接続プールがアイドル接続を検出する間隔をミリ秒単位で指定します。接続のアイドル時間が`timeBetweenEvictionRunsMillis`の設定値を超えた場合、接続は閉じられます。|
| minEvictableIdleTimeMillis | 接続プール内の接続の最小アイドル時間をミリ秒単位で指定します。アイドル状態がこの時間を超えると回収されます。負の値に設定すると、接続は回収されないことを意味します。|
| testWhileIdle | 接続がアイドル状態のときにテストを行うかどうかを指定します。`true`に設定すると、接続がアイドル状態のときに`validationQuery`が実行され、接続が有効かどうかが検証されます。|
| testOnBorrow | 接続を取得する際に接続をテストするかどうかを指定します。`true`に設定すると、接続を取得する際に`validationQuery`を実行し、接続が有効かどうかを検証します。|
| testOnReturn | 接続を返却する際に接続をテストするかどうかを指定します。`true`に設定すると、接続を返却する際に`validationQuery`を実行して、接続が有効かどうかを検証します。|
| filters | 接続プールで事前に定義された一連のフィルターを指定します。これらのフィルターは、特定の順序で接続を事前処理および事後処理を行うことで、追加の機能を提供し、接続プールのパフォーマンスを向上させることができます。一般的なフィルターには、以下のようなものが含まれます：<ol><li>`stat`：接続プールのパフォーマンス指標の統計に使用されます。たとえば、アクティブな接続数、リクエスト数、エラー回数など。</li><li>`wall`：SQLファイアウォールに使用され、安全でないSQLステートメントをインターセプトして無効化にすることで、データベースのセキュリティを強化します。</li><li>`log4j`：接続プールのログを`log4j`に出力するために使用し、ログのレコードとデバッグを容易にします。</li><li>`slf4j`：接続プールのログを`slf4j`に出力するために使用し、ログのレコードとデバッグを容易にします。</li><li>`config`：外部設定ファイルから接続プールの設定情報をロードするために使用されます。</li><li>`encoding`：接続プールとデータベース間の文字エンコーディングを設定するために使用されます。</li></ol>これらのフィルターを`filters`プロパティに設定すると、接続プールは指定された順序でこれらのフィルターを順番に適用します。複数のフィルターの名前をカンマ（,）で区切って指定することができます。例：`filters=stat,wall,log4j`|

### Main.javaコードの紹介

`Main.java`ファイルは本記事のサンプルプログラムのメインプログラムです。このサンプルを通して、データソース、接続オブジェクト、さまざまなデータベース操作メソッドを使用してデータベースとインタラクションする方法を理解できます。

本記事の`Main.java`ファイルのコードには、主に以下のいくつの部分で構成されています：

1. 必要なクラスとインターフェースをインポートします。

    1. 現在のコードが属するパッケージ名を`com.example`と宣言します。
    2. 入出力の例外を処理するために、Javaの`IOException`クラスをインポートします。
    3. ファイルまたは他のソースから入力ストリームを取得するために、Javaの`InputStream`クラスをインポートします。
    4. データベースとの接続を表すために、Javaの`Connection`インターフェースをインポートします。
    5. データベースのクエリ結果のデータセットを表すために、Javaの`ResultSet`インターフェースをインポートします。
    6. SQL例外を処理するために、Javaの`SQLException`クラスをインポートします。
    7. SQLステートメントを実行するために、Javaの`Statement`インターフェースをインポートします。
    8. プリコンパイルされたSQLステートメントに使用するために、Javaの`PreparedStatement`インターフェースをインポートします。
    9. プロパティファイルを処理するために、Javaの`Properties`クラスをインポートします。
    10. データベース接続を管理するために、Javaの`DataSource`インターフェースをインポートします。
    11. Druidデータソースを作成するために、Alibaba Druidの接続プールの`DruidDataSourceFactory`クラスをインポートします。

    **コード：**

    ```java
    package com.example;

    import java.io.IOException;
    import java.io.InputStream;
    import java.sql.Connection;
    import java.sql.ResultSet;
    import java.sql.SQLException;
    import java.sql.Statement;
    import java.sql.PreparedStatement;
    import java.util.Properties;
    import javax.sql.DataSource;
    import com.alibaba.druid.pool.DruidDataSourceFactory;
    ```

2. `Main`クラスを作成し、`main`メソッドを定義します。

    `Main`クラスと`main`メソッドを定義し、`main`メソッドは、接続プールを使用してデータベースから一連の操作を実行する方法を示すために使用されます。具体的な手順は以下のとおりです：

    1. プログラムのエントリポイントとして、`Main`という名前のpublicクラスを定義します。クラス名はファイル名と一致させる必要があります。
    2. public staticメソッド`main`を定義して、プログラムのエントリポイントとして、コマンドラインパラメータを受け取ります。
    3. 例外処理メカニズムを使用して、発生する可能性のある例外をキャッチして処理します。
    4. `loadPropertiesFile`メソッドを呼び出し、プロパティファイルをロードして`Properties`オブジェクトを返します。
    5. `createDataSource()`メソッドを呼び出し、プロパティファイルの設定に基づいてデータソースオブジェクトを作成します。
    6. `try-with-resources`ステートメントを使用して、データベース接続を取得し、接続が使用されなくなったら自動的に接続を閉じます。

        1. `createTable()`メソッドを呼び出して、テーブルを作成します。
        2. `insertData()`メソッドを呼び出して、データを挿入します。
        3. `selectData()`メソッドを呼び出して、データをクエリします。
        4. `updateData()`メソッドを呼び出して、データを更新します。
        5. `selectData()`メソッドを再度呼び出し、更新されたデータをクエリします。
        6. `deleteData()`メソッドを呼び出して、データを削除します。
        7. `selectData()`メソッドを再度呼び出して、削除後のデータをクエリします。
        8. `dropTable()`メソッドを呼び出して、テーブルを削除します。

    **コード：**

    ```java
    public class Main {

        public static void main(String[] args) {
            try {
                Properties properties = loadPropertiesFile();
                DataSource dataSource = createDataSource(properties);
                try (Connection conn = dataSource.getConnection()) {
                    // Create table
                    createTable(conn);
                    // Insert data
                    insertData(conn);
                    // Query data
                    selectData(conn);

                    // Update data
                    updateData(conn);
                    // Query the updated data
                    selectData(conn);

                    // Delete data
                    deleteData(conn);
                    // Query the data after deletion
                    selectData(conn);

                    // Drop table
                    dropTable(conn);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        // プロパティファイルから設定情報を取得して使用するメソッドを定義する
        // データソースオブジェクトを取得するためのメソッドを定義する
        // テーブルを作成するためのメソッドを定義する
        // データを挿入するためのメソッドを定義する
        // データを更新するたのメソッドを定義する
        // データを削除するためのメソッドを定義する
        // データをクエリするためのメソッドを定義する
        // テーブルを削除するためのメソッドを定義する
    }
    ```

3. プロパティファイルから設定情報を取得して使用するメソッドを定義します。

    プライベート静的メソッド`loadPropertiesFile()`を定義し、プロパティファイルをロードして`Properties`オブジェクトを返すために使用されます。具体的な手順は以下のとおりです：

    1. プライベート静的メソッド`loadPropertiesFile()`を定義します。このメソッドは`Properties`オブジェクトを返し、`IOException`例外をスローする可能性がありことを宣言します。
    2. プロパティファイルからキーと値のペアをストレージする`Properties`オブジェクトを作成します。
    3. `try-with-resources`ステートメントを使用して、クラスローダーからプロパティファイル`db.properties`の入力ストリーム`is`を取得します。
    4. `load`メソッドを使用して、入力ストリームからプロパティを`properties`オブジェクトにロードします。
    5. ロードされた`properties`オブジェクトを返します。

    **コード：**

    ```java
        private static Properties loadPropertiesFile() throws IOException {
            Properties properties = new Properties();
            try (InputStream is = Main.class.getClassLoader().getResourceAsStream("db.properties")) {
                properties.load(is);
            }
            return properties;
        }
    ```

4. データソースオブジェクトを取得するためのメソッドを定義します。

    プライベート静的メソッド`createDataSource()`を定義して、プロパティファイル内の設定に基づき`DataSource`オブジェクトを作成し、データベースの接続を管理および取得するために使用されます。具体的な手順は以下のとおりです：

    1. プライベート静的メソッド`createDataSource()`を定義します。このメソッドは`Properties`オブジェクトをパラメータとして受け取り、`Exception`例外をスローする可能性があることを宣言します。
    2. `DruidDataSourceFactory`クラスの`createDataSource()`メソッドを呼び出し、`properties`プロパティを渡すと、`DataSource`オブジェクトが返されます。

    **コード：**

    ```java
        private static DataSource createDataSource(Properties properties) throws Exception {
            return DruidDataSourceFactory.createDataSource(properties);
        }
    ```

5. テーブルを作成するためのメソッドを定義します。

    プライベート静的メソッド`createTable()`を定義して、データベース内にデータテーブルを作成するために使用されます。具体的な手順は以下のとおりです：

    1. プライベート静的メソッド`createTable()`を定義します。このメソッドは`Connection`オブジェクトをパラメータとして受け取り、`SQLException`例外をスローする可能性があることを宣言します。
    2. `try-with-resources`ステートメントを使用して、接続オブジェクト`conn`の`createStatement()`メソッドにより、`Statement`オブジェクト`stmt`を作成します。
    3. 文字列変数`sql`を定義し、テーブルを作成するためのSQLステートメントをストレージします。
    4. `executeUpdate()`メソッドを使用してSQLステートメントを実行し、データテーブルを作成します。
    5. テーブルの作成に成功したことを示すメッセージを出力します。

    **コード：**

    ```java
        private static void createTable(Connection conn) throws SQLException {
            try (Statement stmt = conn.createStatement()) {
                String sql = "CREATE TABLE test_druid (id INT, name VARCHAR(20))";
                stmt.executeUpdate(sql);
                System.out.println("Table created successfully.");
            }
        }
    ```

6. データを挿入するためのメソッドを定義します。

    プライベート静的メソッド`insertData()`を定義し、データベースにデータを挿入するために使用されます。具体的な手順は以下のとおりです：

    1. プライベート静的メソッド`insertData()`を定義します。このメソッドは`Connection`オブジェクトをパラメータとして受け取り、`SQLException`例外をスローする可能性があることを宣言します。
    2. 文字列変数`insertDataSql`を定義して、データを挿入するためのSQLステートメントをストレージします。
    3. 整数型の変数`insertedRows`を定義し、初期値を0にし、挿入データの行数をレコードするために使用されます。
    4. `try-with-resources`ステートメントを使用して、接続オブジェクト`conn`の`prepareStatement()`メソッドとデータを挿入するためのSQLステートメントで、`PreparedStatement`オブジェクト`insertDataStmt`を作成します。
    5. `for`ループステートメントを使用して、5回イテレーションし、5件のデータを挿入します。

        1. `setInt()`メソッドを使用して、最初のパラメータの値をループ変数`i`に設定します。
        2. `setString()`メソッドを使用して、2番目のパラメータの値を文字列`test_insert`にループ変数`i`の値を加えたものとして設定します。
        3. `executeUpdate()`メソッドを使用して、データを挿入するSQLステートメントを実行し、返された操作行数を`insertedRows`変数に加算します。

    6. データの挿入に成功したことを示すメッセージと、挿入された行の総数を出力します。
    7. 挿入された行の総数を返します。

    **コード：**

    ```java
        private static int insertData(Connection conn) throws SQLException {
            String insertDataSql = "INSERT INTO test_druid (id, name) VALUES (?, ?)";
            int insertedRows = 0;
            try (PreparedStatement insertDataStmt = conn.prepareStatement(insertDataSql)) {
                for (int i = 1; i < 6; i++) {
                    insertDataStmt.setInt(1, i);
                    insertDataStmt.setString(2, "test_insert" + i);
                    insertedRows += insertDataStmt.executeUpdate();
                }
                System.out.println("Data inserted successfully. Inserted rows: " + insertedRows);
            }
            return insertedRows;
        }
    ```

7. データを更新するためのメソッドを定義します。

    プライベート静的メソッド`updateData()`を定義し、データベースのデータを更新するために使用されます。具体的な手順は以下のとおりです：

    1. プライベート静的メソッド`updateData()`を定義します。このメソッドは`Connection`オブジェクトをパラメータとして受け取り、`SQLException`例外をスローする可能性があることを宣言します。
    2. `try-with-resources`ステートメントを使用して、接続オブジェクト`conn`の`prepareStatement()`メソッドとデータ更新用のSQLステートメントで、`PreparedStatement`オブジェクト`pstmt`を作成します。
    3. `setString()`メソッドを使用して、最初のパラメータの値を文字列`test_update`に設定します。
    4. `setInt()`メソッドを使用して、2番目のパラメータの値を整数値3に設定します。
    5. `executeUpdate()`メソッドを使用して、データを更新するSQLステートメントを実行し、返された操作行数を`updatedRows`変数に代入します。
    6. データの更新に成功したことを示すメッセージと、更新された行の総数を出力します。

    **コード：**

    ```java
        private static void updateData(Connection conn) throws SQLException {
            try (PreparedStatement pstmt = conn.prepareStatement("UPDATE test_druid SET name = ? WHERE id = ?")) {
                pstmt.setString(1, "test_update");
                pstmt.setInt(2, 3);
                int updatedRows = pstmt.executeUpdate();
                System.out.println("Data updated successfully. Updated rows: " + updatedRows);
            }
        }
    ```

8. データを削除するためのメソッドを定義します。

    プライベート静的メソッド`deleteData()`を定義し、データベースのデータを削除するために使用されます。具体的な手順は以下のとおりです：

    1. プライベート静的メソッド`deleteData()`を定義します。このメソッドは`Connection`オブジェクトをパラメータとして受け取り、`SQLException`例外をスローする可能性があることを宣言します。
    2. `try-with-resources`ステートメントを使用して、接続オブジェクト`conn`の`prepareStatement()`メソッドとデータ削除用のSQLステートメントで、`PreparedStatement`オブジェクト`pstmt`を作成します。
    3. `setInt()`メソッドを使用して、最初のパラメータの値を整数値3と設定します。
    4. `executeUpdate()`メソッドを使用して、データを削除するSQLステートメントを実行し、返された操作行数を`deletedRows`変数に代入します。
    5. データの削除に成功したことを示すメッセージと、削除された行の総数を出力します。

    **コード：**

    ```java
        private static void deleteData(Connection conn) throws SQLException {
            try (PreparedStatement pstmt = conn.prepareStatement("DELETE FROM test_druid WHERE id < ?")) {
                pstmt.setInt(1, 3);
                int deletedRows = pstmt.executeUpdate();
                System.out.println("Data deleted successfully. Deleted rows: " + deletedRows);
            }
        }
    ```

9. データのクエリを行うためのメソッドを定義します。

    プライベート静的メソッド`selectData()`を定義し、データベース内のデータをクエリするために使用されます。具体的な手順は以下のとおりです：

    1. プライベート静的メソッド`selectData()`を定義します。このメソッドは`Connection`オブジェクトをパラメータとして受け取り、`SQLException`例外をスローする可能性があることを宣言します。
    2. `try-with-resources`ステートメントを使用して、接続オブジェクト`conn`の`createStatement()`メソッドにより、`Statement`オブジェクト`stmt`を作成します。
    3. 文字列変数`sql`を定義し、データをクエリするSQLステートメントをストレージします。
    4. `executeQuery()`メソッドを使用して、データをクエリするSQLステートメントを実行し、返された結果セットを`resultSet`変数に代入します。
    5. `while`ループステートメントを使用して、結果セット内の各行のデータをイテレーションします。

        1. `getInt()`メソッドを使用して、現在の行の`id`フィールドの整数値を取得し、`id`変数に代入します。
        2. `getString()`メソッドを使用して、現在の行の`name`フィールドの文字列値を取得し、`name`変数に代入します。
        3. 現在の行の`id`と`name`フィールドの値を出力します。

    **コード：**

    ```java
        private static void selectData(Connection conn) throws SQLException {
            try (Statement stmt = conn.createStatement()) {
                String sql = "SELECT * FROM test_druid";
                ResultSet resultSet = stmt.executeQuery(sql);
                while (resultSet.next()) {
                    int id = resultSet.getInt("id");
                    String name = resultSet.getString("name");
                    System.out.println("id: " + id + ", name: " + name);
                }
            }
        }
    ```

10. テーブルを削除するためのメソッドを定義します。

    プライベート静的メソッド`dropTable()`を定義し、データベース内のテーブルを削除するために使用されます。具体的な手順は以下のとおりです：

    1. プライベート静的メソッド`dropTable()`を定義します。このメソッドは`Connection`オブジェクトをパラメータとして受け取り、`SQLException`例外をスローする可能性があることを宣言します。
    2. `try-with-resources`ステートメントを使用して、接続オブジェクト`conn`の`createStatement()`メソッドにより、`Statement`オブジェクト`stmt`を作成します。
    3. 文字列変数`sql`を定義し、テーブルを削除するためのSQLステートメントをストレージします。
    4. `executeUpdate()`メソッドを使用して、テーブルを削除するためのSQLステートメントを実行します。
    5. テーブルの削除に成功したことを示すメッセージを出力します。

    **コード：**

    ```java
        private static void dropTable(Connection conn) throws SQLException {
            try (Statement stmt = conn.createStatement()) {
                String sql = "DROP TABLE test_druid";
                stmt.executeUpdate(sql);
                System.out.println("Table dropped successfully.");
            }
        }
    ```

### 全コード表示

:::tab
tab pom.xml

```java
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>druid-mysql-client</artifactId>
    <version>1.0-SNAPSHOT</version>
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <configuration>
                    <source>8</source>
                    <target>8</target>
                </configuration>
            </plugin>
        </plugins>
    </build>

    <dependencies>
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>5.1.40</version>
        </dependency>
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid</artifactId>
            <version>1.2.8</version>
        </dependency>
    </dependencies>
</project>
```

tab db.properties

```java
# Database Configuration
driverClassName=com.mysql.jdbc.Driver
url=jdbc:mysql://$host:$port/$database_name?useSSL=false
username=$user_name
password=$password

# Connection Pool Configuration
#To check whether the database link is valid, MySQL must be configured to select 1; Oracle is select 1 from dual
validationQuery=select 1
#Initial number of connections
initialSize=3
#Maximum number of activations, that is, the maximum number of Connection pool
maxActive=30
#When closing the Abandoned connection, the error log is output. When the link is recycled, the console prints information. The test environment can add true, while the online environment is false. Will affect performance.
logAbandoned=true
#Minimum number of activations during idle time
minIdle=5
#The maximum waiting time for a connection, in milliseconds
maxWait=1000
#The maximum time to start the eviction thread is the survival time of a link (previous value: 25200000, the converted result of this time is: 2520000/1000/60/60=7 hours)
minEvictableIdleTimeMillis=300000
#Whether to recycle after exceeding the time limit
removeAbandoned=true
#Exceeding the time limit (in seconds), currently 5 minutes. If any business processing time exceeds 5 minutes, it can be adjusted appropriately.
removeAbandonedTimeout=300
# Run the idle connection collector Destroy thread every 10 seconds to detect the interval time between connections, based on the judgment of testWhileIdle
timeBetweenEvictionRunsMillis=10000
#When obtaining a link, not verifying its availability can affect performance.
testOnBorrow=false
#Check whether the link is available when returning the link to the Connection pool.
testOnReturn=false
#This configuration can be set to true, without affecting performance and ensuring security. The meaning is: Detect when applying for a connection. If the idle time is greater than timeBetweenEviceRunsMillis, execute validationQuery to check if the connection is valid.
testWhileIdle=true
#Default false, if configured as true, connection detection will be performed in the DestroyConnectionThread thread (timeBetweenEvaluation once)
keepAlive=false
#If keepAlive rule takes effect and the idle time of the connection exceeds it, the connection will only be detected
keepAliveBetweenTimeMillis=60000
```

tab Main.java

```java
package com.example;

import java.io.IOException;
import java.io.InputStream;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.PreparedStatement;
import java.util.Properties;
import javax.sql.DataSource;
import com.alibaba.druid.pool.DruidDataSourceFactory;

public class Main {

    public static void main(String[] args) {
        try {
            Properties properties = loadPropertiesFile();
            DataSource dataSource = createDataSource(properties);
            try (Connection conn = dataSource.getConnection()) {
                // Create table
                createTable(conn);
                // Insert data
                insertData(conn);
                // Query data
                selectData(conn);

                // Update data
                updateData(conn);
                // Query the updated data
                selectData(conn);

                // Delete data
                deleteData(conn);
                // Query the data after deletion
                selectData(conn);

                // Drop table
                dropTable(conn);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static Properties loadPropertiesFile() throws IOException {
        Properties properties = new Properties();
        try (InputStream is = Main.class.getClassLoader().getResourceAsStream("db.properties")) {
            properties.load(is);
        }
        return properties;
    }

    private static DataSource createDataSource(Properties properties) throws Exception {
        return DruidDataSourceFactory.createDataSource(properties);
    }

    private static void createTable(Connection conn) throws SQLException {
        try (Statement stmt = conn.createStatement()) {
            String sql = "CREATE TABLE test_druid (id INT, name VARCHAR(20))";
            stmt.executeUpdate(sql);
            System.out.println("Table created successfully.");
        }
    }

    private static int insertData(Connection conn) throws SQLException {
        String insertDataSql = "INSERT INTO test_druid (id, name) VALUES (?, ?)";
        int insertedRows = 0;
        try (PreparedStatement insertDataStmt = conn.prepareStatement(insertDataSql)) {
            for (int i = 1; i < 6; i++) {
                insertDataStmt.setInt(1, i);
                insertDataStmt.setString(2, "test_insert" + i);
                insertedRows += insertDataStmt.executeUpdate();
            }
            System.out.println("Data inserted successfully. Inserted rows: " + insertedRows);
        }
        return insertedRows;
    }

    private static void updateData(Connection conn) throws SQLException {
        try (PreparedStatement pstmt = conn.prepareStatement("UPDATE test_druid SET name = ? WHERE id = ?")) {
            pstmt.setString(1, "test_update");
            pstmt.setInt(2, 3);
            int updatedRows = pstmt.executeUpdate();
            System.out.println("Data updated successfully. Updated rows: " + updatedRows);
        }
    }

    private static void deleteData(Connection conn) throws SQLException {
        try (PreparedStatement pstmt = conn.prepareStatement("DELETE FROM test_druid WHERE id < ?")) {
            pstmt.setInt(1, 3);
            int deletedRows = pstmt.executeUpdate();
            System.out.println("Data deleted successfully. Deleted rows: " + deletedRows);
        }
    }

    private static void selectData(Connection conn) throws SQLException {
        try (Statement stmt = conn.createStatement()) {
            String sql = "SELECT * FROM test_druid";
            ResultSet resultSet = stmt.executeQuery(sql);
            while (resultSet.next()) {
                int id = resultSet.getInt("id");
                String name = resultSet.getString("name");
                System.out.println("id: " + id + ", name: " + name);
            }
        }
    }

    private static void dropTable(Connection conn) throws SQLException {
        try (Statement stmt = conn.createStatement()) {
            String sql = "DROP TABLE test_druid";
            stmt.executeUpdate(sql);
            System.out.println("Table dropped successfully.");
        }
    }
}
```

:::

## 関連ドキュメント

その他のMySQL Connector/Jの詳細については、[Overview of MySQL Connector/J](https://dev.mysql.com/doc/connector-j/en/connector-j-overview.html)を参照してください。
