|description||
|---|---|
|keywords||
|dir-name|DBCP|
|dir-name-en||
|tenant-type|MySQL Mode|

# DBCP

本記事では、DBCP接続プール、MySQL Connector/J、およびOceanBaseデータベースを用いてアプリケーションを構築し、テーブル作成・データの挿入・更新・削除・クエリなどの基本的なデータベース操作を実装する方法を紹介します。

<div role="videolist">
      <a role='link' href='https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/connection-pool/dbcp-mysql-client/dbcp-mysql-client.zip'>
          <img src='https://file.oceanbase.com/doc/img/lQLPJyFovGIOcJQWFrAqhLlgRRsPvwU-H7hJ_i0A_22_22.png'/>
          dbcp-mysql-clientサンプルプロジェクトをダウンロード
      </a>
      <!-- <a role='video' href='https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/video-center/video/video/04%20dbcp-mysql-client.mp4'>
          <img src='https://mdn.alipayobjects.com/huamei_22khvb/afts/img/A*DFPmToHK6hgAAAAAAAAAAAAADiGDAQ/original'/>
          DBCP 连接池连接 OceanBase 数据库示例程序（MySQL 模式）
      </a> -->
</div>

## 前提条件

* OceanBaseデータベースがインストール済みで、MySQLモードのテナントが作成されていること。
* JDK 1.8とMavenがインストール済みであること。
* Eclipseがインストール済みであること。

    <main id="notice" type='explain'>
      <h4>説明</h4>
      <p>この記事はEclipse IDE for Java Developers 2022-03バージョンを使用してコードを実行していますが、お好みのツールを選んでサンプルコードを実行することもできます。</p>
    </main>

## 操作手順

<main id="notice" type='explain'>
  <h4>説明</h4>
  <p>本記事の操作手順はWindows環境に基づいています。他のOS環境やコンパイラを使用する場合は、操作手順が若干異なる場合があります。</p>
</main>

1. `dbcp-mysql-client`プロジェクトをEclipseにインポートします。
2. OceanBaseデータベースのURLを取得します。
3. `dbcp-mysql-client`プロジェクトのデータベース接続情報を修正します。
4. `dbcp-mysql-client`プロジェクトを実行します。

### ステップ１：dbcp-mysql-clientプロジェクトをEclipseにインポートする

1. Eclipseを開き、メニューバーから**File**->**Open Projects from File System**を選択します。

2. ポップアップダイアログで、**Directory**ボタンをクリックしてプロジェクトのディレクトリを選択し、**Finish**をクリックしてインポートを完了します。

    <main id="notice" type='explain'>
      <h4>説明</h4>
      <p>Eclipseを使用してMavenプロジェクトをインポートすると、プロジェクト内の<code>pom.xml</code>ファイルを自動的に検出し、その記述に基づいて必要な依存ライブラリをダウンロードしてプロジェクトに追加します。</p>
    </main>

    ![Import](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/connection-pool/dbcp-mysql-client/1import.png)

3. プロジェクトの状況を確認します。

    ![p1](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/connection-pool/dbcp-mysql-client/2p1.png)

### ステップ2：OceanBaseデータベースのURLを取得する

1. OceanBaseデータベースのデプロイ担当者または管理者から、該当するデータベース接続文字列を取得します。

    **例：**

    ```shell
    obclient -hxxx.xxx.xxx.xxx -P2881 -utest_user001@mysql001 -p****** -Dtest
    ```

    その他の接続文字列に関する詳細は、[OBClientによるOceanBaseテナントへの接続](../300.connect-to-an-oceanbase-tenant-by-using-obclient-of-mysql-mode.md)を参照してください。

2. OceanBaseデータベース接続文字列の情報に基づいて、以下のURLの対応する情報を入力します。

    ```shell
    jdbc:mysql://$host:$port/$database_name?user=$user_name&password=$password
    ```

    **パラメータの説明：**

    * `$host`：OceanBaseデータベースへの接続IPアドレス。OceanBaseデータベースプロキシ(OceanBase Database Proxy、ODP)接続方式ではODPアドレスを使用し、直接接続方式ではOBServerノードのIPアドレスを使用します。
    * `$port`：OceanBaseデータベースへの接続ポート。ODP接続方式のデフォルトポートは`2883`で、ODPデプロイ時にカスタマイズ可能です。直接接続方式のデフォルトポートは`2881`で、OceanBaseデータベースのデプロイ時にカスタマイズ可能です。
    * `$database_name`：アクセス対象のデータベース名。

        <main id="notice" type='notice'>
          <h4>注意</h4>
          <p>テナントに接続するユーザーは、データベースに対する<code>CREATE</code>、<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>、および<code>SELECT</code>権限が付与されていなければなりません。その他のユーザー権限の詳細については、<a href="https://en.oceanbase.com/docs/common-oceanbase-database-10000000001974758">MySQLモードの権限分類</a>を参照してください。</p>
        </main>

    * `$user_name`：テナントの接続アカウント。ODP接続方式の形式：`ユーザー名@テナント名#クラスタ名`または`クラスタ名:テナント名:ユーザー名`。直接接続方式の形式：`ユーザー名@テナント名`。
    * `$password`：アカウントのパスワード。

    その他のMySQL Connector/Jの接続プロパティの詳細については、[Configuration Properties](https://dev.mysql.com/doc/connector-j/en/connector-j-reference-configuration-properties.html)を参照してください。

    **例：**

    ```shell
    jdbc:mysql://xxx.xxx.xxx.xxx:2881/test?user=test_user001@mysql001&password=******
    ```

### ステップ3：dbcp-mysql-clientプロジェクトのデータベース接続情報を修正する

**ステップ2：OceanBaseデータベースのURLを取得する**で取得した情報に基づいて、ファイル`dbcp-mysql-client/src/main/resources/db.properties`のデータベース接続情報を修正します。

**例：**

* OBServerノードのIPアドレスは`xxx.xxx.xxx.xxx`です。
* アクセスポートは2881を使用します。
* アクセスするデータベース名は`test`です。
* テナントの接続アカウントは`test_user001@mysql001`です。`test_user001`がユーザー名、`mysql001`がテナント名を表します。この`mysql001`は、OceanBaseデータベース上にMySQLモードで作成されたテナントです。
* パスワードは`******`です。

**コード：**

```java
...
url=jdbc:mysql://xxx.xxx.xxx.xxx:2881/test
username=test_user001@mysql001
password=******
...
```

### ステップ4：dbcp-mysql-clientプロジェクトを実行する

1. プロジェクトナビゲータービューで、**src/main/java**ディレクトリを見つけて展開します。

2. **Main.java**ファイルを右クリックし、**Run As**->**Java Application**を選択します。

    ![run](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/connection-pool/dbcp-mysql-client/4run.png)

3. Eclipseのコンソールウィンドウで、プロジェクトのログ情報と出力結果を確認します。

    ![log](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/connection-pool/dbcp-mysql-client/5log.png)

4. OceanBaseクライアント(OBClient)で以下のSQLステートメントを実行して結果を確認することもできます。

    ```shell
    obclient [test]> SELECT * FROM test_tbl1;
    ```

    **実行結果は以下のとおりです：**

    ```shell
    +------+--------------+
    | id   | name         |
    +------+--------------+
    |    5 | test_update  |
    |    6 | test_insert6 |
    |    7 | test_insert7 |
    |    8 | test_insert8 |
    |    9 | test_insert9 |
    +------+--------------+
    5 rows in set
    ```

## プロジェクトコードについて

[dbcp-mysql-client](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/connection-pool/dbcp-mysql-client/dbcp-mysql-client.zip) をクリックして、プロジェクトコードをダウンロードします。これは、`dbcp-mysql-client.zip`という名前の圧縮ファイルです。

解凍すると、`dbcp-mysql-client`という名前のフォルダが作成されます。ディレクトリ構造は以下のとおりです：

```shell
dbcp-mysql-client
├── src
│   └── main
│       ├── java
│       │   └── com
│       │       └── example
│       │           └── Main.java
│       └── resources
│           └── db.properties
└── pom.xml
```

**ファイルの説明：**

* `src`：ソースコードのルートディレクトリです。
* `main`：アプリケーションの主要なロジックを含むメインコードディレクトリです。
* `java`：Javaソースコードディレクトリです。
* `com`：Javaパッケージディレクトリです。
* `example`：サンプルプロジェクトのパッケージディレクトリです。
* `Main.java`：テーブルの作成、データの挿入、削除、更新、およびクエリなどのロジック処理を含むメインクラスプログラムのサンプルファイルです。
* `resources`：設定ファイルなどを含むリソースファイルディレクトリです。
* `db.properties`：接続プールの設定ファイルには、データベース接続に関するパラメータが含まれています。
* `pom.xml`：プロジェクトの依存関係とビルド設定を管理するために使用されるMavenプロジェクトの設定ファイルです。

### pom.xmlコードの紹介

`pom.xml`ファイルはMavenプロジェクトの設定ファイルで、プロジェクトの依存関係、プラグイン、ビルドルールなどの情報を定義しています。MavenはJavaプロジェクト管理ツールで、依存関係のダウンロード、プロジェクトのコンパイル、パッケージングなどの操作を自動化できます。

本記事の`pom.xml`ファイルのコードは、主に以下のいくつかの部分が含まれます：

1. ファイル宣言ステートメントです。

    このファイルがXMLファイルであり、使用しているXMLのバージョンが`1.0`で、文字エンコーディング方式が`UTF-8`であることを宣言しています。

    **コード：**

    ```java
    <?xml version="1.0" encoding="UTF-8"?>
    ```

2. POMのネームスペースとPOMモデルのバージョンを設定します。

    1. `xmlns`を使用して、POMのネームスペースを`http://maven.apache.org/POM/4.0.0`と指定します。
    2. `xmlns:xsi`を使用して、XMLネームスペースを`http://www.w3.org/2001/XMLSchema-instance`と指定します。
    3. `xsi:schemaLocation`を使用して、POMのネームスペースを`http://maven.apache.org/POM/4.0.0`、POMのXSDファイルの場所を`http://maven.apache.org/xsd/maven-4.0.0.xsd`と指定します。
    4. `<modelVersion>`要素を使用して、このPOMファイルで使用されるPOMモデルバージョンを`4.0.0`と指定します。

    **コード：**

    ```java
    <project xmlns="http://maven.apache.org/POM/4.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
      <modelVersion>4.0.0</modelVersion>

     <!-- その他の設定 -->

    </project>
    ```

3. 基本情報を設定します。

    1. `<groupId>`で、プロジェクトが属する組織を`com.example`と指定します。
    2. `<artifactId>`で、プロジェクトの名前を`dbcp-mysql-client`と指定します。
    3. `<version>`で、プロジェクトのバージョン番号を`1.0-SNAPSHOT`と指定します。

    **コード：**

    ```java
        <groupId>com.example</groupId>
        <artifactId>dbcp-mysql-client</artifactId>
        <version>1.0-SNAPSHOT</version>
    ```

4. プロジェクトソースファイルのプロパティを設定します。

    Mavenのコンパイラプラグインを`maven-compiler-plugin`と指定し、ソースコードとターゲットJavaバージョンをどちらも8に設定しています。これは、プロジェクトのソースコードがJava 8の機能を使用して記述されており、コンパイルされたバイトコードもJava 8ランタイム環境と互換性があることを意味します。この設定により、プロジェクトはコンパイル時および実行時にJava 8の構文と機能を正しく処理できるようになります。

    <main id="notice" type='explain'>
      <h4>説明</h4>
      <p>Java 1.8とJava 8は、同じバージョンの異なる命名ルールです。</p>
    </main>

    **コード：**

    ```java
        <build>
            <plugins>
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-compiler-plugin</artifactId>
                    <configuration>
                        <source>8</source>
                        <target>8</target>
                    </configuration>
                </plugin>
            </plugins>
        </build>
    ```

5. プロジェクトが依存するコンポーネントを設定します。

    `<dependency>`タグを使い、依存関係を定義します。

    * MySQL JDBCドライバ

      1. `<groupId>`: `mysql`
      2. `<artifactId>`: `mysql-connector-java`
      3. `<version>`: `5.1.47`

    * dbcp接続プール

      1. `<groupId>`: `org.apache.commons`
      2. `<artifactId>`: `commons-dbcp2`
      3. `<version>`: `2.9.0`

    **コード：**

    ```java
        <dependencies>
            <dependency>
                <groupId>mysql</groupId>
                <artifactId>mysql-connector-java</artifactId>
                <version>5.1.47</version>
            </dependency>
            <dependency>
                <groupId>org.apache.commons</groupId>
                <artifactId>commons-dbcp2</artifactId>
                <version>2.9.0</version>
            </dependency>
        </dependencies>
    ```

### db.propertiesコードの紹介

`db.properties`は本記事の例となる接続プールの設定ファイルであり、接続プールの設定プロパティが含まれています。これらのプロパティには、ドライバーのクラス名、データベースURL、ユーザー名、パスワード、接続プールのサイズと制限、接続のタイムアウト時間、放棄された接続を処理するためのオプションが含まれます。

本記事の`db.properties`ファイルのコードは、主に以下のいくつかの部分が含まれます：

1. データベース接続パラメータを設定します。

    1. ドライバーのクラス名を設定します。ここでは、MySQL JDBCドライバーのクラス名`com.mysql.jdbc.Driver`を使用します。
    2. データベース接続のURLを設定します。これには、ホストIPアドレス、ポート番号、アクセスする必要があるデータベースなどの情報が含まれます。
    3. データベースのユーザー名を設定します。
    4. データベースのパスワードを設定します。
    5. 接続プロパティを設定します。そのうち、`useSSL=false`はSSL暗号化接続を使用しないことを示し、`characterEncoding=UTF-8`はUTF-8エンコーディングを使用してデータを送信することを示します。

    **コード：**

    ```java
    driverClassName=com.mysql.jdbc.Driver
    url=jdbc:mysql://$host:$port/$database_name
    username=$user_name
    password=$password
    connectionProperties=useSSL=false;characterEncoding=UTF-8
    ```

    **パラメータの説明：**

    * `$host`：OceanBaseデータベースへの接続IPアドレス。ODP接続方式ではODPアドレスを使用し、直接接続方式ではOBServerノードのIPアドレスを使用します。
    * `$port`：OceanBaseデータベースへの接続ポート。ODP接続方式のデフォルトポートは`2883`で、ODPデプロイ時にカスタマイズ可能です。直接接続方式のデフォルトポートは`2881`で、OceanBaseデータベースのデプロイ時にカスタマイズ可能です。
    * `$database_name`：アクセス対象のデータベース名。
    * `$user_name`：テナントの接続アカウント。ODP接続の一般的な形式：`ユーザー名@テナント名#クラスタ名`または`クラスタ名:テナント名:ユーザー名`。直接接続方式の形式：`ユーザー名@テナント名`。
    * `$password`：アカウントのパスワード。

2. その他のDBCP接続プールのパラメータを設定します。

    1. 接続プールの初期サイズを`30`に設定します。つまり、接続プールが最初に作成される接続数です。
    2. 接続プールの最大接続数を`30`に設定します。つまり、接続プール内で許容される最大接続数です。
    3. 接続プール内で保持可能なアイドル状態の最大接続数を`10`に設定します。
    4. 接続プール中でアイドル状態を保持する最小接続数を`5`に設定します。アイドル接続数がこの値を下回ると、接続プールは新しい接続を作成します。
    5. 接続プールから接続を取得する際の最大待機時間(ミリ秒単位)を`1000`に設定します。接続プール内のすべての接続が使用中で、利用可能な接続がない場合、接続取得操作は、接続が利用可能になるか、最大待機時間を超えるまで待機します。
    6. 放棄された接続を削除するまでのタイムアウト時間(秒単位)は`1`です。

        <main id="notice" type='explain'>
          <h4>説明</h4>
          <p><code>removeAbandonedTimeout</code>のデフォルト値は300秒ですが、この例ではプログラムをテストするために1秒に設定されています。アプリケーションのニーズに合わせて、この値を適切に調整することができます。</p>
        </main>

    7. プログラム内の接続が使用されなくなった後、接続プールによって回収されるかどうか：

        * メンテナンス中に放棄された接続を検出して、クリーンアップするかどうか設定します。`true`に設定します。
        * 接続プールから接続を借用する際に、放棄された接続を検出してクリーンアップするかどうかを設定します。`true`に設定します。

    **コード：**

    ```java
    initialSize=30
    maxTotal=30
    maxIdle=10
    minIdle=5
    maxWaitMillis=1000
    removeAbandonedTimeout=1

    removeAbandonedOnMaintenance=true
    removeAbandonedOnBorrow=true
    ```

<main id="notice" type='notice'>
  <h4>注意</h4>
  <p>具体的なプロパティ(パラメータ)の設定は、プロジェクトの要件とデータベースの特性によって異なります。実際の状況に応じて調整と設定を行うことを推奨します。DBCP接続プールパラメータの詳細情報については、<a href="https://commons.apache.org/proper/commons-dbcp/configuration.html">BasicDataSource Configuration Parameters</a>を参照してください。</p>
</main>

**DBCP接続プールの基本データソース構成パラメータ：**

<table>
   <tr>
       <th>分類</th>
       <th>プロパティ</th>
       <th>省略値</th>
       <th>説明</th>
   </tr>
   <tr>
       <td rowspan=5>必須パラメータ</td>
       <td>driverClass</td>
       <td>N/A</td>
       <td>データベースドライバーのクラス名を指定します。</td>
   </tr>
   <tr>
       <td>url</td>
       <td>N/A</td>
       <td>データベースに接続するときに使用するURLを指定します。</td>
   </tr>
   <tr>
       <td>username</td>
       <td>N/A</td>
       <td>データベースに接続するときに使用するユーザー名を指定します。</td>
   </tr>
   <tr>
       <td>password</td>
       <td>N/A</td>
       <td>データベースに接続するために使用するパスワードを指定します。</td>
   </tr>
   <tr>
       <td rowspan=8>推奨構成パラメータ</td>
       <td>initialSize</td>
       <td>0</td>
       <td>接続プールの初期サイズを指定します。つまり、接続プールが起動時に作成する初期接続数です。0より大きい値に設定すると、接続プールが初期化されるときに指定された数の接続が作成されます。これにより、接続を事前に作成され、クライアントが初めて接続をリクエストしたときの遅延を軽減できます。</td>
   </tr>
   <tr>
       <td>maxTotal</td>
       <td>8</td>
       <td>接続プールの最大接続数を指定します。つまり、接続プール内で存在が許容される最大接続数です。負の数値に設定すると、制限がないことを意味します。</td>
   </tr>
   <tr>
       <td>maxIdle</td>
       <td>8</td>
       <td>追加の接続を解放せずに接続プール内で保持可能なアイドル状態の最大接続数を指定します。負の数値に設定すると、制限がないことを意味します。</td>
   </tr>
   <tr>
       <td>minIdle</td>
       <td>0</td>
       <td>追加の接続を解放せずに接続プール内で保持するアイドル状態の最小接続数を指定します。負の数値に設定すると、制限がないことを意味します。</td>
   </tr>
   <tr>
       <td>maxWaitMillis</td>
       <td>indefinitely</td>
       <td>接続プールから接続を取得する際の最大待ち時間(ミリ秒単位)を指定します。-1に設定すると、無限に待機することを意味します。正の数値に設定すると、接続プール内のすべての接続が使用されている場合、接続の取得を待機している操作は指定された時間を待機し、時間を超えると例外がスローされます。</td>
   </tr>
   <tr>
       <td>validationQuery</td>
       <td>N/A</td>
       <td>接続が有効であるかどうかを検証するために使用するSQLクエリステートメントを指定します。指定されている場合、このクエリは少なくとも1行を返す <code>SQL SELECT</code> ステートメントである必要があります。指定されていない場合、接続は <code>isValid()</code> メソッドを呼び出して検証されます。</td>
   </tr>
   <tr>
       <td>testOnBorrow</td>
       <td>true</td>
       <td>接続プールからオブジェクトを借用するときに、検証を実行するかどうかを指定します。オブジェクトが検証できない場合、接続プールから削除され、別のオブジェクトの借用が試みられます。</td>
   </tr>
   <tr>
       <td>testWhileIdle</td>
       <td>false</td>
       <td>接続プールがアイドル状態のときに、検証を実行するかどうかを指定します。<code>true</code> に設定する場合、接続プールは定期的に検証クエリを実行してアイドル接続の有効性を確認します。オブジェクトが検証に失敗した場合、接続プールから削除されます。</td>
   </tr>
   <tr>
       <td rowspan=2>オプションパラメータ</td>
       <td>connectionProperties</td>
       <td>N/A</td>
       <td>キーと値のペア形式で追加の接続プロパティを指定します。これらのプロパティは、データベース接続を取得する際に、基盤となるJDBCドライバーに渡されます。文字列のフォーマットは<code>propertyName=property;</code>である必要があります。<main id="notice" type='notice'><h4>注意</h4><p><code>username</code>と<code>password</code>プロパティは明示的に渡されるため、ここで含める必要はありません。</p></main></td>
   </tr>
   <tr>
       <td><ul><li>removeAbandonedOnMaintenance</li><li>removeAbandonedOnBorrow</li></ul></td>
       <td>false</td>
       <td>これら2つのパラメータは、接続が放棄されたと見なされる場合の削除動作を制御するために使用されます。<ul><li><code>removeAbandonedOnMaintenance</code>：このパラメータを <code>true</code>に設定すると、接続プールはメンテナンスサイクル(エビクション完了時)中に、放棄された接続を削除します。ただし、このパラメータは、メンテナンスサイクルを有効にした場合(<code>timeBetweenEvictionRunsMillis</code>を正の値に設定した場合)にのみ有効になります。</li><li><code>removeAbandonedOnBorrow</code>：このパラメータを <code>true</code>に設定すると、接続プールから接続を借用するたびに、接続プールは放棄された接続が存在するかどうかをチェックし、存在する場合は削除します。さらに、削除操作は次の2つの条件を満たす必要があります：<ul><li><code>getNumActive() > getMaxTotal() - 3</code>：現在のアクティブ接続数が、最大接続数から3を引いた値より大きい。</li><li><code>getNumIdle() < 2</code>：現在のアイドル接続数が2未満です。</li></ul></li></ul>上記の2つのパラメータを <code>true</code> に設定することで、接続プールは放棄された接続を自動的に検出および削除することができます。放棄された接続とは、長期間使用されていない接続のことです。これは、アプリケーションが接続を適切に閉じなかったことを起因とする可能性があります。これらの放棄された接続を削除することで、データベースリソースを解放し、接続プールのパフォーマンスと効率を向上させることができます。</td>
   </tr>
</table>

### Main.javaコードの紹介

`Main.java`ファイルはサンプルプログラムの一部であり、DBCP接続プールを使用してデータベース接続を取得し、テーブルの作成、データの挿入、削除、更新、クエリといった一連のデータベース操作を実行し、クエリ結果を出力する方法を示します。

本記事の`Main.java`ファイルのコードには、主に以下のいくつの部分が含まれます：

1. 必要なクラスとインターフェースをインポートします。

    ファイルの読み込み、データベースの操作、データベース接続プールに関連するクラスとインターフェースを含む、必要なクラスとインターフェースをインポートします。これらのクラスとインターフェースは、以降のコードで使用されます。

    1. `com.example`という名前のパッケージを宣言します。このパッケージは現在のJavaクラスを格納するために使用されます。
    2. `java.io.FileInputStream`クラスをインポートします。これはファイルを読み込むために使用されます。
    3. `java.sql.Connection`インターフェースをインポートします。これはデータベースへの接続を意味ます。
    4. `java.sql.PreparedStatement`インターフェースをインポートします。これはプリコンパイルされたSQLステートメントを意味ます。
    5. `java.sql.ResultSet`インターフェースをインポートします。これはデータベースクエリの結果セットを意味します。
    6. `java.sql.SQLException`例外クラスをインポートします。これは、SQL操作中に発生する例外を意味します。
    7. `java.util.Properties`クラスをインポートします。これは設定ファイルをロードするために使用されます。
    8. `org.apache.commons.dbcp2.BasicDataSource`クラスをインポートします。これはデータベース接続プールを意味します。
    9. `org.apache.commons.dbcp2.BasicDataSourceFactory`クラスをインポートし、データベースの接続プールを作成するために使用されます。

    **コード：**

    ```java
    package com.example;

    import java.io.FileInputStream;
    import java.sql.Connection;
    import java.sql.PreparedStatement;
    import java.sql.ResultSet;
    import java.sql.SQLException;
    import java.util.Properties;

    import org.apache.commons.dbcp2.BasicDataSource;
    import org.apache.commons.dbcp2.BasicDataSourceFactory;
    ```

2. クラス名とメソッドを定義します。

    1. Mainクラスを作成し、プログラムのエントリポイントとして`main`メソッドを定義します。
    2. `main`メソッド内で、まず`createDataSource()`メソッドを呼び出して、接続プールオブジェクト `dataSource`を作成します。
    3. `try-with-resources`ステートメントを使用して、接続プールオブジェクトのライフサイクルの終了時にリソースが自動的に閉じます。
    4. `try`コードブロック内で、`getConnection()`メソッドを呼び出して、接続プールからデータベース接続オブジェクト`conn`を取得します。
    5. `createTable()`、`insertData()`、`deleteData()`、`updateData()`、`queryData()`の各メソッドを順に呼び出して、対応するデータベース操作を実行します。
    6. 例外が発生した場合、`catch`ブロックで例外情報を出力します。

    **コード：**

    ```java
    public class Main {

        public static void main(String[] args) {
            try (BasicDataSource dataSource = createDataSource()) {
                try (Connection conn = dataSource.getConnection()) {
                    createTable(conn);
                    insertData(conn);
                    deleteData(conn);
                    updateData(conn);
                    queryData(conn);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        // 接続プールの作成
        // テーブルを作成するためのメソッドを定義する
        // データを挿入するためのメソッドを定義する
        // データを削除するためのメソッドを定義する
        // データを更新するたのメソッドを定義する
        // データをクエリするためのメソッドを定義する
    }
    ```

3. 接続プールを作成します。

    データベース接続プールを作成するための便利なメソッドを提供し、設定ファイルからパラメータを読み取って接続プールオブジェクトを初期化します。具体的な手順は以下のとおりです：

    1. プライベート静的メソッド`createDataSource()`を定義し、`BasicDataSource`タイプを返します。このメソッドは`Exception`例外をスローする可能性があります。
    2. データベース接続の設定情報をストレージするための`Properties`オブジェクト`props`を作成します。
    3. `src/main/resources`ディレクトリにある`db.properties`ファイルを読み取るための`FileInputStream`オブジェクト`is`を作成します。
    4. `load()`メソッドを使用して、`db.properties`ファイル内のキーと値のペアを props オブジェクトにロードします。
    5. `BasicDataSourceFactory.createDataSource(props)`メソッドを呼び出し、`props`オブジェクトをパラメータとして使用して、`BasicDataSource`オブジェクトを作成して返します。

    **コード：**

    ```java
        private static BasicDataSource createDataSource() throws Exception {
            Properties props = new Properties();
            FileInputStream is = new FileInputStream("src/main/resources/db.properties");
            props.load(is);

            return BasicDataSourceFactory.createDataSource(props);
        }
    ```

4. テーブルを作成するためのメソッドを定義します。

    データベース内に指定のテーブルを作成するためのメソッドを提供します。これは接続オブジェクトをパラメータとして受け取り、プリコンパイルされた方式でテーブル作成のSQLステートメントを実行します。具体的な手順は以下のとおりです：

    1. プライベート静的メソッド`createTable()`を定義し、`Connection`オブジェクトをパラメータとして受け取ります。メソッドは`SQLException`例外をスローする可能性があります。
    2. テーブル作成用のSQLステートメントをストレージするための`createTableSql`という文字列変数を定義します。SQLステートメントでテーブル名を`test_tbl1`と指定し、2つの列を定義します。1つは`id`という名前の`INT`タイプの列、もう1つは`name`という名前の`VARCHAR(32)`タイプの列です。
    3. `conn.prepareStatement(createTableSql)`メソッドを使用して、プリコンパイルされたSQLステートメントを実行するための`PreparedStatement`オブジェクト`createTableStmt`を作成します。
    4. テーブルを作成するために、`execute()`メソッドを呼び出してSQLステートメントを実行します。

    **コード：**

    ```java
        private static void createTable(Connection conn) throws SQLException {
            String createTableSql = "CREATE TABLE test_tbl1 (id INT, name VARCHAR(32))";
            try (PreparedStatement createTableStmt = conn.prepareStatement(createTableSql)) {
                createTableStmt.execute();
            }
        }
    ```

5. データを挿入するためのメソッドを定義します。

    データベースのテーブルに指定されたデータを挿入するためのメソッドを提供します。これは接続オブジェクトをパラメータとして受け取り、プリコンパイルされた方式を使用して、データ挿入用のSQLステートメントを実行します。具体的な手順は以下のとおりです：

    1. プライベート静的メソッド`insertData()`を定義します。このメソッドは`Connection`オブジェクトをパラメータとして受け取ります。メソッドは`SQLException`例外をスローする可能性があります。
    2. 挿入データ用のSQLステートメントをストレージするための文字列変数`insertDataSql`を定義します。
    3. `conn.prepareStatement(insertDataSql)`メソッドを使用して、プリコンパイルされたSQLステートメントを実行するための`PreparedStatement`オブジェクト`insertDataStmt`を作成します。
    4. `for`ループを使用してテーブルにデータを挿入：

        1. `10`回ループして、ループごとにデータ1つを挿入します。
        2. `setInt()`メソッドを使用して、ループ変数`i`の値をSQLステートメントの最初のパラメータ値に設定します。
        3. `setString()`メソッドを使用して、文字列`test_insert + i`をSQLステートメントの2番目のパラメータ値に設定します。
        4. データベースにデータを挿入するために、`executeUpdate()`メソッドを呼び出してSQLステートメントを実行します。

    **コード：**

    ```java
        private static void insertData(Connection conn) throws SQLException {
            String insertDataSql = "INSERT INTO test_tbl1 (id, name) VALUES (?, ?)";
            try (PreparedStatement insertDataStmt = conn.prepareStatement(insertDataSql)) {
                for (int i = 0; i < 10; i++) {
                    insertDataStmt.setInt(1, i);
                    insertDataStmt.setString(2, "test_insert" + i);
                    insertDataStmt.executeUpdate();
                }
            }
        }
    ```

6. データを削除するためのメソッドを定義します。

    特定条件を満たすデータをデータベースから削除するためのメソッドを提供します。これは、接続オブジェクトをパラメータとして受け取り、プリコンパイルされた方式を使用して、データを削除するSQLステートメントを実行します。具体的な手順は以下のとおりです：

    1. プライベート静的メソッド`deleteData()`を定義して、`Connection`オブジェクトをパラメータとして受け取ります。メソッドは`SQLException`例外をスローする可能性があります。
    2. データ削除用のSQLステートメントをストレージするための文字列変数`deleteDataSql`を定義します。
    3. `conn.prepareStatement(deleteDataSql)`メソッドを使用して、プリコンパイルされたSQLステートメントを実行するための`PreparedStatement`オブジェクト`deleteDataStmt`を作成します。
    4. `setInt()`メソッドを使用して、SQLステートメントのパラメータ値として数字5を設定します。
    5. 条件を満たすデータをデータベースから削除するために、`executeUpdate()`メソッドを呼び出してSQLステートメントを実行します。

    **コード：**

    ```java
        private static void deleteData(Connection conn) throws SQLException {
            String deleteDataSql = "DELETE FROM test_tbl1 WHERE id < ?";
            try (PreparedStatement deleteDataStmt = conn.prepareStatement(deleteDataSql)) {
                deleteDataStmt.setInt(1, 5);
                deleteDataStmt.executeUpdate();
            }
        }
    ```

7. データを更新するためのメソッドを定義します。

    特定の条件を満たすデータをデータベース内で更新するためのメソッドを提供します。これは接続オブジェクトをパラメータとして受け取り、プリコンパイルされた方式でデータを更新するSQLステートメントを実行します。具体的な手順は以下のとおりです：

    1. プライベート静的メソッド`updateData()`を定義し、`Connection`オブジェクトをパラメータとして受け取ります。メソッドは`SQLException`例外をスローする可能性があります。
    2. データを更新するSQLステートメントをストレージするための文字列変数`updateDataSql`を定義します。
    3. `conn.prepareStatement(updateDataSql)`メソッドを使用して、プリコンパイルされたSQLステートメントを実行するための`PreparedStatement`オブジェクト`updateDataStmt`を作成します。
    4. `setString()`メソッドを使用して、文字列`test_update`をSQLステートメントの最初のパラメータ値に設定します。
    5. `setInt()`メソッドを使用して、SQLステートメントの2番目のパラメータ値として数値`5`を設定します。
    6. 条件を満たすデータベース内のデータを更新するために、`executeUpdate()`メソッドを呼び出してSQLステートメントを実行します。

    **コード：**

    ```java
        private static void updateData(Connection conn) throws SQLException {
            String updateDataSql = "UPDATE test_tbl1 SET name = ? WHERE id = ?";
            try (PreparedStatement updateDataStmt = conn.prepareStatement(updateDataSql)) {
                updateDataStmt.setString(1, "test_update");
                updateDataStmt.setInt(2, 5);
                updateDataStmt.executeUpdate();
            }
        }
    ```

8. データのクエリを行うためのメソッドを定義します。

    データベースからデータをクエリして処理するためのメソッドを提供します。接続オブジェクトをパラメータとして受け取り、プリコンパイルされた方式でデータをクエリするSQLステートメントを実行します。具体的な手順は以下のとおりです：

    1. プライベート静的メソッド`queryData()`を定義し、`Connection`オブジェクトをパラメータとして受け取ります。メソッドは`SQLException`例外をスローする可能性があります。
    2. データをクエリするSQLステートメントをストレージするために、文字列変数`queryDataSql`を定義します。
    3. `conn.prepareStatement(queryDataSql)`メソッドを使用して、プリコンパイルされたSQLステートメントを実行するための`PreparedStatement`オブジェクト`queryDataStmt`を作成します。
    4. `queryDataStmt.executeQuery()`メソッドを使用してSQLクエリを実行し、`ResultSet`オブジェクト`rs`を使用してクエリ結果を受け取ります。
    5. `while`ループを使用して、`rs.next()`メソッドでクエリ結果セットをイテレーション：

        1. `getInt()`メソッドを使用して、結果セットの中から`id`という名前の列の整数値を取得し、変数`id`に代入します。
        2. `getString()`メソッドを使用して、結果セットの中から`name`という名前の列の文字列値を取得し、変数`name`に代入します。
        3. クエリ結果の`id`と`name`を出力します。

    **コード：**

    ```java
        private static void queryData(Connection conn) throws SQLException {
            String queryDataSql = "SELECT * FROM test_tbl1";
            try (PreparedStatement queryDataStmt = conn.prepareStatement(queryDataSql)) {
                try (ResultSet rs = queryDataStmt.executeQuery()) {
                    while (rs.next()) {
                        int id = rs.getInt("id");
                        String name = rs.getString("name");
                        System.out.println("id: " + id + ", name: " + name);
                    }
                }
            }
        }
    ```

### 全コード表示

:::tab
tab pom.xml

```java
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>dbcp-mysql-client</artifactId>
    <version>1.0-SNAPSHOT</version>
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <configuration>
                    <source>8</source>
                    <target>8</target>
                </configuration>
            </plugin>
        </plugins>
    </build>

    <dependencies>
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>5.1.47</version>
        </dependency>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-dbcp2</artifactId>
            <version>2.9.0</version>
        </dependency>
    </dependencies>
</project>
```

tab db.properties

```java
# Database Connect Information
driverClassName=com.mysql.jdbc.Driver
url=jdbc:mysql://$host:$port/$database_name
username=$user_name
password=$password
connectionProperties=useSSL=false;characterEncoding=UTF-8

# ConnectionPool Parameters
initialSize=30
maxTotal=30
maxIdle=10
minIdle=5
maxWaitMillis=1000
removeAbandonedTimeout=1

removeAbandonedOnMaintenance=true
removeAbandonedOnBorrow=true
```

tab Main.java

```java
package com.example;

import java.io.FileInputStream;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Properties;

import org.apache.commons.dbcp2.BasicDataSource;
import org.apache.commons.dbcp2.BasicDataSourceFactory;

public class Main {

    public static void main(String[] args) {
        try (BasicDataSource dataSource = createDataSource()) {
            try (Connection conn = dataSource.getConnection()) {
                createTable(conn);
                insertData(conn);
                deleteData(conn);
                updateData(conn);
                queryData(conn);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    // Create ConnectionPool
    private static BasicDataSource createDataSource() throws Exception {
        Properties props = new Properties();
        FileInputStream is = new FileInputStream("src/main/resources/db.properties");
        props.load(is);

        return BasicDataSourceFactory.createDataSource(props);
    }

    // Create table
    private static void createTable(Connection conn) throws SQLException {
        String createTableSql = "CREATE TABLE test_tbl1 (id INT, name VARCHAR(32))";
        try (PreparedStatement createTableStmt = conn.prepareStatement(createTableSql)) {
            createTableStmt.execute();
        }
    }

    // Insert data
    private static void insertData(Connection conn) throws SQLException {
        String insertDataSql = "INSERT INTO test_tbl1 (id, name) VALUES (?, ?)";
        try (PreparedStatement insertDataStmt = conn.prepareStatement(insertDataSql)) {
            for (int i = 0; i < 10; i++) {
                insertDataStmt.setInt(1, i);
                insertDataStmt.setString(2, "test_insert" + i);
                insertDataStmt.executeUpdate();
            }
        }
    }

    // Delete data
    private static void deleteData(Connection conn) throws SQLException {
        String deleteDataSql = "DELETE FROM test_tbl1 WHERE id < ?";
        try (PreparedStatement deleteDataStmt = conn.prepareStatement(deleteDataSql)) {
            deleteDataStmt.setInt(1, 5);
            deleteDataStmt.executeUpdate();
        }
    }

    // Update data
    private static void updateData(Connection conn) throws SQLException {
        String updateDataSql = "UPDATE test_tbl1 SET name = ? WHERE id = ?";
        try (PreparedStatement updateDataStmt = conn.prepareStatement(updateDataSql)) {
            updateDataStmt.setString(1, "test_update");
            updateDataStmt.setInt(2, 5);
            updateDataStmt.executeUpdate();
        }
    }

    // Query data
    private static void queryData(Connection conn) throws SQLException {
        String queryDataSql = "SELECT * FROM test_tbl1";
        try (PreparedStatement queryDataStmt = conn.prepareStatement(queryDataSql)) {
            try (ResultSet rs = queryDataStmt.executeQuery()) {
                while (rs.next()) {
                    int id = rs.getInt("id");
                    String name = rs.getString("name");
                    System.out.println("id: " + id + ", name: " + name);
                }
            }
        }
    }
}
```

:::

## 関連ドキュメント

MySQL Connector/Jの詳細については、[Overview of MySQL Connector/J](https://dev.mysql.com/doc/connector-j/en/connector-j-overview.html)を参照してください。
