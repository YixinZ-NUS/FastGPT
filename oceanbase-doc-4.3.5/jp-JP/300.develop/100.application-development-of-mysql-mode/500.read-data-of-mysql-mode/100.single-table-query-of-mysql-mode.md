|description||
|---|---|
|keywords||
|dir-name||
|dir-name-en||
|tenant-type|MySQL Mode|

# 単一テーブルクエリ

本記事では、SQLステートメントを使用してOceanBaseデータベースで単一テーブルのクエリ操作を実行する方法について説明します。

## 前提条件

* OceanBaseデータベースのMySQLモードテナントに接続されていること。
* 既に `SELECT` 権限を保有していること。現在のユーザー権限を確認するためのその他の関連操作情報については、[ユーザー権限の確認](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001974756)を参照してください。この権限を保有していない場合は、管理者に連絡して権限の付与を依頼してください。ユーザー権限の付与に関する操作情報については、[直接権限付与](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001974754)を参照してください。

## 構文

[SELECT](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001974942) を使用してデータのクエリを実行してください。

`SELECT` ステートメントの単一テーブルクエリにおける一般的な構造は次のとおりです：

```sql
SELECT [ALL | DISTINCT | UNIQUE | SQL_CALC_FOUND_ROWS] select_list
FROM table_name
[ WHERE query_condition ]
[ GROUP BY group_by_condition ]
[ HAVING group_condition ]
[ ORDER BY column_list ][ASC | DESC]
[ LIMIT limit_clause ]

column_list：
 column_name[,column_name...]
```

**パラメータの説明：**

|             パラメータ            |                           説明                       |
|-----------------------------|-----------------------------------------------------|
| select_list                 | 対象となる列のリスト。列名、式、集約関数などを指定できます。複数の列を指定する場合は、カンマ（,）で区切ります。|
| table_name                  | データを照会する対象のテーブル名。|
| WHERE query_condition       | オプションのパラメータで、検索条件を指定するために使用します。条件に合致する行のみが返されます。|
| GROUP BY group_by_condition | オプションのパラメータで、指定された列に基づいて結果をグループ化します。集約関数と併用するのが一般的です。|
| HAVING group_condition      | オプションのパラメータで、グループ化後の結果セットをフィルタリングし、条件を満たすグループのみを返します。|
| ORDER BY column_list        | オプションのパラメータで、結果セットをソートします。1列または複数の列を指定してソートすることができます。|
| ASC | DESC                  | オプションパラメータで、ソートの順序を指定します。ASCは昇順（デフォルト）、DESCは降順を表します。|
| LIMIT limit_clause          | オプションのパラメータで、返される結果セットの行数を制限するために使用します。|
| column_list                 | 検索する列を指定するパラメータで、単一の列または複数の列をカンマ（,）で区切って指定できます。|
| column_name                 | 検索する列名。|

### SELECTキーワードの実行順序の概要

`WHERE`、`GROUP BY`、`HAVING`、`ORDER BY`、`LIMIT` といったキーワードを同時に使用する場合、その順番には明確な制限があります。キーワードの実行順序は以下のとおりです：

1. `FROM` を実行してテーブルを検索します。

2. `WHERE` を実行して制約条件を指定します。

3. `GROUP BY` を実行して取得された各レコードをグループ化（集約）します。`GROUP BY` がなければ、全体が1つのグループとして扱われます。

4. `HAVING` を実行してグループ化された結果をフィルタリングします。

5. `SELECT` を実行します。

6. `DISTINCT` を実行して重複を削除します。

7. `ORDER BY` を実行して結果を条件に基づいて昇順または降順にソートします。

8. `LIMIT` を実行して結果の件数を制限します。

<main id="notice" type='notice'>
  <h4>注意</h4>
  <p><code>WHERE</code> と <code>HAVING</code> の違いは、<code>WHERE</code> はグループ化前にデータをフィルタリングし、<code>HAVING</code> はグループ化後の結果をフィルタリングし、最終的にSQL全体のクエリ結果を返します。</p>
</main>

## テストテーブルの作成とテストデータの追加

1. テーブル `student` を作成します。

    ```sql
    CREATE TABLE student (
      id INT PRIMARY KEY AUTO_INCREMENT,
      name VARCHAR(20) NOT NULL,
      gender TINYINT NOT NULL,
      age INT NOT NULL,
      score FLOAT NOT NULL,
      enrollment_date DATE NOT NULL,
      notes VARCHAR(50)
    );
    ```

2. テーブル `student` に10件のデータを挿入します。

    ```sql
    INSERT INTO student (name, gender, age, score, enrollment_date, notes)
      VALUES ('Emma', 0, 20, 85.0, '2021-09-01',NULL),
      ('William', 1, 21, 90.5, '2021-09-02','B'),
      ('Olivia', 0, 19, 95.5, '2021-09-03','A'),
      ('James', 1, 20, 87.5, '2021-09-03',NULL),
      ('Sophia', 0, 20, 91.5, '2021-09-05','B'),
      ('Benjamin', 1, 21, 96.5, '2021-09-01','A'),
      ('Ava', 0, 22, 89.5, '2021-09-06',NULL),
      ('Michael', 1, 18, 93.5, '2021-09-08','B'),
      ('Charlotte', 1, 19, 88.0, '2021-09-06',NULL),
      ('Ethan', 1, 20, 92.0, '2021-09-01','B');
    ```

3. テーブル `fruit_order` を作成します。

    ```sql
    CREATE TABLE fruit_order(
      order_id INT PRIMARY KEY AUTO_INCREMENT COMMENT '注文 ID',
      user_id BIGINT NOT NULL COMMENT '顧客ID',
      user_name VARCHAR(16) NOT NULL DEFAULT '' COMMENT '顧客の名前',
      fruit_price DECIMAL(10,2) NOT NULL DEFAULT 0 COMMENT '注文金額',
      order_year SMALLINT NOT NULL COMMENT '注文年'
    ) COMMENT '注文書';
    ```

4. テーブル `fruit_order` に10件のデータを挿入します。

    ```sql
    INSERT INTO fruit_order(user_id, user_name,fruit_price,order_year)
      VALUES (1011,'A1',13.11,'2019'),
      (1011,'A1',22.21,'2020'),
      (1011,'A1',58.83,'2020'),
      (1022,'B2',23.34,'2019'),
      (1022,'B2',12.22,'2019'),
      (1022,'B2',14.66,'2021'),
      (1022,'B2',34.44,'2021'),
      (1033,'C3',51.55,'2020'),
      (1033,'C3',63.66,'2021'),
      (1034,'D4',53.62,'2021');
    ```

## 基本クエリ

`SELECT` を使用する場合、意味のある列エイリアスと適切な列シーケンスを使用することを推奨します。これにより、結果セットの読みやすさが向上し、クエリ結果をより適切に整理し理解することができるようになります。

### すべての列のクエリ

* `SELECT * FROM student;` ステートメントを使用することで、すべての学生情報を取得することができます。

* すべてのフィールドを手動でリストアップし、`SELECT id,name,gender,age,score,enrollment_date FROM student;` ステートメントを使用してすべての学生情報を取得することもできます。

<main id="notice" type='explain'>
  <h4>説明</h4>
  <p><code>*</code> を使用するとすべてのフィールドを簡単にリストアップすることができますが、すべてのフィールドを手動でリストアップする方がクエリのパフォーマンス、コードの読みやすさ、および保守性の点でより優れています。</p>
</main>

例1：以下のSQLステートメントを使用して、テーブル `student` のすべての列を照会します。

```sql
SELECT id, name, gender, age, score, enrollment_date, notes
FROM student;
```

または

```sql
SELECT * FROM student;
```

実行結果は次のとおりです：

```shell
+----+-----------+--------+-----+-------+-----------------+-------+
| id | name      | gender | age | score | enrollment_date | notes |
+----+-----------+--------+-----+-------+-----------------+-------+
|  1 | Emma      |      0 |  20 |    85 | 2021-09-01      | NULL  |
|  2 | William   |      1 |  21 |  90.5 | 2021-09-02      | B     |
|  3 | Olivia    |      0 |  19 |  95.5 | 2021-09-03      | A     |
|  4 | James     |      1 |  20 |  87.5 | 2021-09-03      | NULL  |
|  5 | Sophia    |      0 |  20 |  91.5 | 2021-09-05      | B     |
|  6 | Benjamin  |      1 |  21 |  96.5 | 2021-09-01      | A     |
|  7 | Ava       |      0 |  22 |  89.5 | 2021-09-06      | NULL  |
|  8 | Michael   |      1 |  18 |  93.5 | 2021-09-08      | B     |
|  9 | Charlotte |      1 |  19 |    88 | 2021-09-06      | NULL  |
| 10 | Ethan     |      1 |  20 |    92 | 2021-09-01      | B     |
+----+-----------+--------+-----+-------+-----------------+-------+
10 rows in set
```

### 指定された列のクエリ

列名に基づいてテーブル内の指定された列データを検索します。

例2：以下のSQLステートメントを使用して、テーブル `student` のすべての行のデータを照会し、各行の `id` 列と `name` 列のデータを返します。

```sql
SELECT id, name
FROM student;
```

実行結果は次のとおりです：

```shell
+----+-----------+
| id | name      |
+----+-----------+
|  1 | Emma      |
|  2 | William   |
|  3 | Olivia    |
|  4 | James     |
|  5 | Sophia    |
|  6 | Benjamin  |
|  7 | Ava       |
|  8 | Michael   |
|  9 | Charlotte |
| 10 | Ethan     |
+----+-----------+
10 rows in set
```

### 計算値を照会し、列にエイリアスを指定する

クエリで指定された列に対してデータ計算処理を実行することができます。

例3：以下のSQLステートメントを使用して、テーブル `student` から `id`、`name`、`age`、`age+5` の4つの列のデータを選択し、列 `age+5` の計算結果列に `age_plus_5` というエイリアスを指定します。

```sql
SELECT id, name, age, age+5 AS age_plus_5
FROM student;
```

実行結果は次のとおりです：

```shell
+----+-----------+-----+------------+
| id | name      | age | age_plus_5 |
+----+-----------+-----+------------+
|  1 | Emma      |  20 |         25 |
|  2 | William   |  21 |         26 |
|  3 | Olivia    |  19 |         24 |
|  4 | James     |  20 |         25 |
|  5 | Sophia    |  20 |         25 |
|  6 | Benjamin  |  21 |         26 |
|  7 | Ava       |  22 |         27 |
|  8 | Michael   |  18 |         23 |
|  9 | Charlotte |  19 |         24 |
| 10 | Ethan     |  20 |         25 |
+----+-----------+-----+------------+
10 rows in set
```

<main id="notice" type='explain'>
  <h4>説明</h4>
  <p>クエリで演算子と関数を使用して指定された列のデータ処理を実行する方法の詳細については、<b>クエリでの演算子と関数の使用</b>のセクションを参照してください。</p>
</main>

## データのフィルタリング

特定の条件を満たすデータを照会する場合、`SELECT` クエリステートメントに `WHERE` 句を追加してデータのフィルタリングを行うことができます。`WHERE` 句の後には、1つ以上の条件を含めることができ、これらの条件によってデータがフィルタリングされ、`WHERE` 条件を満たすデータのみが返されます。特定ニーズに応じて、柔軟にクエリ条件を活用することで、ターゲットデータをフィルタリングおよび検索できます。

`WHERE` 句を使用する際には、条件が正しく、適切な演算子を使用していることを確認する必要があります。

`WHERE` 句でよく使われるクエリ条件は以下のテーブルのとおりです。

|   クエリ条件タイプ   |                     述語           |
|------------|---------------------------------------------|
| 比較クエリ      | `=`，`>`，`<`，`>=`，`<=`，`!=`，`<>` |
| 論理クエリ（複数条件） | `AND`、`OR`、`NOT` |
| あいまいクエリ（文字列マッチング） | `LIKE`、`NOT LIKE`               |
| 区間クエリ（特定の範囲） | `BETWEEN AND`、`NOT BETWEEN AND` |
| 指定された集合のクエリ     | `IN`、`NOT IN`                   |
| NULL値のクエリ   | `IS NULL`、`IS NOT NULL`         |

クエリ条件で使用する演算子の詳細については、[比較演算子](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001974214)を参照してください。

### 比較条件クエリ

#### 等しい

等しい（`=`）：指定した列の値が、特定の値と等しいデータを取得します。値が文字列タイプの場合は、シングルクォートまたはダブルクォートで囲む必要があります。

例4：次のSQLステートメントを使用して、テーブル `student` 内の列 `gender` が `1` に等しいすべての行を照会し、これらの行の `id`、`name`、`gender` 列のデータを返します。

```sql
SELECT id, name, gender
FROM student
WHERE gender = 1;
```

実行結果は次のとおりです：

```shell
+----+-----------+--------+
| id | name      | gender |
+----+-----------+--------+
|  2 | William   |      1 |
|  4 | James     |      1 |
|  6 | Benjamin  |      1 |
|  8 | Michael   |      1 |
|  9 | Charlotte |      1 |
| 10 | Ethan     |      1 |
+----+-----------+--------+
6 rows in set
```

#### 等しくない

不等号には `<>` と `!=` の2種類の書き方が含まれます。

例5：次のSQLステートメントを使用して、テーブル `student` 内の列 `gender` が `1` に等しくないすべての行を照会し、これらの行の `id`、`name`、`gender` 列のデータを返します。

```sql
SELECT id, name, gender
FROM student
WHERE gender <> 1;
```

実行結果は次のとおりです：

```shell
+----+--------+--------+
| id | name   | gender |
+----+--------+--------+
|  1 | Emma   |      0 |
|  3 | Olivia |      0 |
|  5 | Sophia |      0 |
|  7 | Ava    |      0 |
+----+--------+--------+
4 rows in set
```

#### 「大なり」と「小なり」

大なり（`>`）および小なり（`<`）は、数値の大小を比較するために使用されます。文字を比較する場合、ASCIIコードに対応する値で比較し、文字の対応する位置を順番に比較します。

<main id="notice" type='explain'>
  <h4>説明</h4>
  <p>大なりイコール（\>=）および小なりイコール（\<=）も同様です。</p>
</main>

例6：次のSQLステートメントを使用して、テーブル `student` 内の列 `score` が `90` より小さいすべての行を照会し、これらの行の `id`、`name`、`score` 列のデータを返します。

```sql
SELECT id, name, score
FROM student
WHERE score < 90;
```

実行結果は次のとおりです：

```shell
+----+-----------+-------+
| id | name      | score |
+----+-----------+-------+
|  1 | Emma      |    85 |
|  4 | James     |  87.5 |
|  7 | Ava       |  89.5 |
|  9 | Charlotte |    88 |
+----+-----------+-------+
4 rows in set
```

### 論理条件クエリ

論理クエリ演算子である（`AND`）および（`OR`）は、複数の条件によるクエリをサポートします。

#### AND

`AND` キーワードは、複数の条件を組み合わせるために使用されます。すべての条件を同時に満たすデータのみが返されます。

例7：次のSQLステートメントを使用して、テーブル `student` 内の列 `gender` が `1` に等しく `score` が `90` 以下のすべての行を照会し、これらの行の `id`、`name`、`gender`、`score` 列のデータを返します。

```sql
SELECT id, name, gender, score
FROM student
WHERE gender = 1 AND score <= 90;
```

実行結果は次のとおりです：

```shell
+----+-----------+--------+-------+
| id | name      | gender | score |
+----+-----------+--------+-------+
|  4 | James     |      1 |  87.5 |
|  9 | Charlotte |      1 |    88 |
+----+-----------+--------+-------+
2 rows in set
```

#### OR

`OR` キーワードは複数の条件を連結するために使用され、いずれかの条件を満たすデータが返されます。

例8：次のSQLステートメントを使用して、テーブル `student` 内の列 `gender` が `1` に等しいか `score` が `90` より小さいすべての行を照会し、これらの行の `id`、`name`、`gender`、`score` 列のデータを返します。

```sql
SELECT id, name, gender, score
FROM student
WHERE gender = 1 OR score < 90;
```

実行結果は次のとおりです：

```shell
+----+-----------+--------+-------+
| id | name      | gender | score |
+----+-----------+--------+-------+
|  1 | Emma      |      0 |    85 |
|  2 | William   |      1 |  90.5 |
|  4 | James     |      1 |  87.5 |
|  6 | Benjamin  |      1 |  96.5 |
|  7 | Ava       |      0 |  89.5 |
|  8 | Michael   |      1 |  93.5 |
|  9 | Charlotte |      1 |    88 |
| 10 | Ethan     |      1 |    92 |
+----+-----------+--------+-------+
8 rows in set
```

### あいまいクエリ

`LIKE` 述語は、文字列のあいまいクエリに使用することができます。

構文の意味は、対応する列の値が `pattern` とマッチするデータを検索することです。`pattern` は完全な文字列にすることも、ワイルドカード `%` および `_` を含むこともできます。そのうち：

* アンダースコア（`_`）は任意の1文字にマッチします。

* パーセント記号（`%`）は、値の中の0文字以上の任意の文字列にマッチします。`%` は `NULL` とマッチしません。

<!-- <main id="notice" type='notice'>
  <h4>注意</h4>
  <p>データベースの文字セットがASCIIの場合、1つの漢字は2つの <code>_</code> を必要とします。文字セットがGBKの場合は、1つの <code>_</code> だけが必要です。</p>
</main> -->

例9：次のSQLステートメントを使用して、テーブル `student` 内の `name` に `am` が含まれるすべての行を照会し、これらの行の `id` と `name` 列のデータを返します。

```sql
SELECT id, name
FROM student
WHERE name LIKE '%am%';
```

実行結果は次のとおりです：

```shell
+----+----------+
| id | name     |
+----+----------+
|  2 | William  |
|  4 | James    |
|  6 | Benjamin |
+----+----------+
3 rows in set
```

### 区間クエリ

演算子 `BETWEEN ... AND` は、2つの値の間にあるデータを抽出します。これらの値は、数値、テキスト、または日付にすることができます。

<main id="notice" type='notice'>
  <h4>注意</h4>
  <p>区間クエリの2つの境界値の順序を入れ替えないでください。必ず「左側の値以上、かつ右側の値以下」という条件になります。</p>
</main>

例10：次のSQLステートメントを使用して、テーブル `student` 内の列 `score` が `85 ～ 90` の範囲に存在するすべての行を照会し、これらの行の `id`、`name`、`score` 列のデータを返します。

```sql
SELECT id, name, score
FROM student
WHERE score BETWEEN 85 AND 90;
```

実行結果は次のとおりです：

```shell
+----+-----------+-------+
| id | name      | score |
+----+-----------+-------+
|  1 | Emma      |    85 |
|  4 | James     |  87.5 |
|  7 | Ava       |  89.5 |
|  9 | Charlotte |    88 |
+----+-----------+-------+
4 rows in set
```

### 指定集合クエリ

`IN` 演算子を使用して `WHERE` 句で指定した複数の値は、集合と呼ばれます。`IN` は、指定された列のデータが集合内のいずれかの値と一致すれば、そのデータが返されることを意味します。`NOT IN` は、集合内のいずれの値とも一致しないデータを返すことを意味します。

  <main id="notice" type='notice'>
    <h4>注意</h4>
    <ul>
    <li><code>[NOT] IN</code> の集合内の値のタイプは、すべて一致しているか、互換性がある必要があります。</li>
    <li><code>[NOT] IN</code> 集合内の値はワイルドカードをサポートしません。</li>
    </ul>
  </main>

例11：次のSQLステートメントを使用して、テーブル `student` 内の `id` 値が集合 `(1, 3, 5, 7)` を満たすすべての行を照会し、これらの行の `id` と `name` 列のデータを返します。

```sql
SELECT id, name
FROM student
WHERE id IN (1,3,5,7);
```

実行結果は次のとおりです：

```shell
+----+--------+
| id | name   |
+----+--------+
|  1 | Emma   |
|  3 | Olivia |
|  5 | Sophia |
|  7 | Ava    |
+----+--------+
4 rows in set
```

### NULL値専用クエリ

比較演算子、`LIKE`、`BETWEEN AND`、`IN`、`NOT IN` は、`NULL` 値に対するクエリ結果が正確ではないため、`NULL` 値専用のクエリステートメント `IS NULL` および `IS NOT NULL` を使用することを推奨します。この他にも、通常の数値と `NULL` 値のどちらも判断することができるNULLセーフ演算子（`<=>`）を使用することもできます。

#### IS NULL

`IS NULL` 条件は、指定された列の値が `NULL` であるデータを照会するために使用されます。

例12：次のSQLステートメントを使用して、テーブル `student` 内の列 `notes` が NULL のすべての行を照会し、これらの行の `id`、`name`、`score`、`notes` 列のデータを返します。

```sql
SELECT id, name, score, notes
FROM student
WHERE notes IS NULL;
```

実行結果は次のとおりです：

```shell
+----+-----------+-------+-------+
| id | name      | score | notes |
+----+-----------+-------+-------+
|  1 | Emma      |    85 | NULL  |
|  4 | James     |  87.5 | NULL  |
|  7 | Ava       |  89.5 | NULL  |
|  9 | Charlotte |    88 | NULL  |
+----+-----------+-------+-------+
4 rows in set
```

#### IS NOT NULL

`IS NOT NULL` 条件は、指定された列の値が `NULL` 以外であるデータを照会するために使用されます。

例13：次のSQLステートメントを使用して、テーブル `student` 内の列 `notes` がNULLではないすべての行を照会し、これらの行の `id`、`name`、`score`、`notes` 列のデータを返します。

```sql
SELECT id, name, score, notes
FROM student
WHERE notes IS NOT NULL;
```

実行結果は次のとおりです：

```shell
+----+----------+-------+-------+
| id | name     | score | notes |
+----+----------+-------+-------+
|  2 | William  |  90.5 | B     |
|  3 | Olivia   |  95.5 | A     |
|  5 | Sophia   |  91.5 | B     |
|  6 | Benjamin |  96.5 | A     |
|  8 | Michael  |  93.5 | B     |
| 10 | Ethan    |    92 | B     |
+----+----------+-------+-------+
6 rows in set
```

## データのグループ化

SQLクエリでは、`GROUP BY` 句を使用してクエリ結果をグループ化します。`GROUP BY` は単一フィールドのグループ化と複数フィールドのグループ化をサポートします。`WHERE` 句を使用するとグループ化する前にデータをフィルタリングすることができます。`HAVING` 句を使用すると、グループ化後にデータをフィルタリングすることができます。`ORDER BY` 句を使用すると、グループ化後にデータをソートすることができます。

**データのグループ化に関する注意事項：**

* `GROUP BY` 句を使用する場合、`SELECT` ステートメント内の列は必ず `GROUP BY` 句内の列または集約関数でなければなりません。
* `HAVING` 句を使用する場合、`HAVING` 条件は元のデータをフィルタリングするのではなく、グループ化の結果をフィルタリングします。

### 単一フィールドによるグループ化クエリ

例14：テーブル `fruit_order` 内の各顧客の注文数を照会し、`user_id` と `COUNT(order_id)` を出力します。

```sql
SELECT user_id, COUNT(order_id)
FROM fruit_order
GROUP BY user_id;
```

実行結果は次のとおりです：

```shell
+---------+-----------------+
| user_id | COUNT(order_id) |
+---------+-----------------+
|    1011 |               3 |
|    1022 |               4 |
|    1033 |               2 |
|    1034 |               1 |
+---------+-----------------+
4 rows in set
```

### 複数フィールドによるグループ化クエリ

例15：テーブル `fruit_order` 内の各顧客の毎年の注文数を照会し、`user_id`、 `order_year` と `COUNT(order_id)` を出力します。

```sql
SELECT user_id, order_year, COUNT(order_id)
FROM fruit_order
GROUP BY user_id,order_year;
```

実行結果は次のとおりです：

```shell
+---------+------------+-----------------+
| user_id | order_year | COUNT(order_id) |
+---------+------------+-----------------+
|    1011 |       2019 |               1 |
|    1011 |       2020 |               2 |
|    1022 |       2019 |               2 |
|    1022 |       2021 |               2 |
|    1033 |       2020 |               1 |
|    1033 |       2021 |               1 |
|    1034 |       2021 |               1 |
+---------+------------+-----------------+
7 rows in set
```

### グループ化前のフィルタリング

例16：2020年の各顧客の注文数を照会し、`user_id` と `COUNT(order_id)` を出力します。

```sql
SELECT user_id, COUNT(order_id)
FROM fruit_order t
WHERE t.order_year = 2020
GROUP BY user_id;
```

実行結果は次のとおりです：

```shell
+---------+-----------------+
| user_id | COUNT(order_id) |
+---------+-----------------+
|    1011 |               2 |
|    1033 |               1 |
+---------+-----------------+
2 rows in set
```

### グループ化後のフィルタリング

<main id="notice" type='explain'>
  <h4>説明</h4>
  <p>クエリに <code>HAVING</code> が含まれる場合、まず先に <code>HAVING</code> 句を含まない場合のSQLクエリの結果を取得し、その結果に基づいて <code>HAVING</code> 条件を使用して条件に一致するデータを絞り込み、最後にそれらのデータを返します。このように、<code>HAVING</code> の後ろには集約関数を用いることができます。この集約関数は <code>SELECT</code> の後ろの集約関数と同じである必要はありません。 </p>
</main>

例17：2019年の注文数が1より大きい顧客を照会し、`user_id` と `COUNT(order_id)` を出力します。

```sql
SELECT user_id, COUNT(order_id)
FROM fruit_order t
WHERE t.order_year = 2019
GROUP BY user_id
HAVING COUNT(order_id) >= 2;
```

実行結果は次のとおりです：

```shell
+---------+-----------------+
| user_id | COUNT(order_id) |
+---------+-----------------+
|    1022 |               2 |
+---------+-----------------+
1 row in set
```

### グループ化後のソート

例18：各顧客の注文の最大金額を照会し、`user_id` と `MAX(fruit_price)` を金額の降順で出力します。

```sql
SELECT user_id, MAX (fruit_price)
FROM fruit_order t
GROUP BY user_id
ORDER BY MAX (fruit_price) DESC;
```

実行結果は次のとおりです：

```shell
+---------+------------------+
| user_id | MAX (fruit_price) |
+---------+------------------+
|    1033 |            63.66 |
|    1011 |            58.83 |
|    1034 |            53.62 |
|    1022 |            34.44 |
+---------+------------------+
4 rows in set
```

### 集約クエリ

集約クエリとは、データの集約操作を実行し、結果の要約を返すクエリ方式です。データセットに対して統計、カウント、合計、平均値、最大値、最小値などの集約操作を実行することができます。集約クエリは通常、`GROUP BY` 句と組み合わせて使用され、データをグループ化し、各グループに対して集約操作を実行します。`GROUP BY` 句は、指定された列に基づいてデータをグループ化し、各グループに集約関数を適用して結果セットを生成します。

グループでよく使われる集約関数は以下の表のとおりです。

| 集約関数 |      説明    |
|---------|--------------|
| MAX()   | 指定された列の最大値を照会します。|
| MIN()   | 指定された列の最小値を照会します。|
| COUNT() | クエリ結果の行数を集計します。|
| SUM()   | 指定された列の合計を返します。|
| AVG()   | 指定された列のデータの平均値を返します。|

集約関数を使用するクエリに関する詳細については、[クエリ内での集約関数の使用](300.use-operators-and-functions-in-query-of-mysql-mode/700.use-aggregate-functions-in-queries-of-mysql-mode.md)を参照してください。

## データのソート

データのソートとはクエリ結果を指定された列または式に基づいて並べ替える操作のことです。昇順（`ASC`）または降順（`DESC`）でデータを並べ替えます。SQLクエリでは、`ORDER BY` 句を使用してソートする方法を指定することができます。`ORDER BY` 句は単一フィールドのソート、複数フィールドのソート、エイリアスによるソート、関数によるソートをサポートします。複数フィールドでソートする場合はカンマ（,）で区切ります。ソートクエリの実行時に、`ASC` または `DESC` キーワードを追加しないと、デフォルトのクエリ結果は昇順でソートされます。

`ORDER BY` 句を使用して結果セットをソートする操作は、（特に大規模なデータセットの場合）リソースを大量に消費します。必要に応じて、インデックスを使用してソート操作を最適化することを推奨します。列とソートする順序を正確に指定してください。

### 単一フィールドソートクエリ

例19：テーブル `student` 内の学生情報を `score` に基づいて昇順で表示します。

```sql
SELECT id, name, score
FROM student
ORDER BY score;
```

実行結果は次のとおりです：

```shell
+----+-----------+-------+
| id | name      | score |
+----+-----------+-------+
|  1 | Emma      |    85 |
|  4 | James     |  87.5 |
|  9 | Charlotte |    88 |
|  7 | Ava       |  89.5 |
|  2 | William   |  90.5 |
|  5 | Sophia    |  91.5 |
| 10 | Ethan     |    92 |
|  8 | Michael   |  93.5 |
|  3 | Olivia    |  95.5 |
|  6 | Benjamin  |  96.5 |
+----+-----------+-------+
10 rows in set
```

例20：テーブル `student` 内の学生情報を `score` に基づいて降順で表示します。

```sql
SELECT id, name, score
FROM student
ORDER BY score DESC;
```

実行結果は次のとおりです：

```shell
+----+-----------+-------+
| id | name      | score |
+----+-----------+-------+
|  6 | Benjamin  |  96.5 |
|  3 | Olivia    |  95.5 |
|  8 | Michael   |  93.5 |
| 10 | Ethan     |    92 |
|  5 | Sophia    |  91.5 |
|  2 | William   |  90.5 |
|  7 | Ava       |  89.5 |
|  9 | Charlotte |    88 |
|  4 | James     |  87.5 |
|  1 | Emma      |    85 |
+----+-----------+-------+
10 rows in set
```

### 複数フィールドソートクエリ

例21：テーブル `student` 内の学生情報を `enrollment_date` の降順、`score` の昇順で表示します。

```sql
SELECT id, name, score, enrollment_date
FROM student
ORDER BY enrollment_date DESC,score ASC;
```

実行結果は次のとおりです：

```shell
+----+-----------+-------+-----------------+
| id | name      | score | enrollment_date |
+----+-----------+-------+-----------------+
|  8 | Michael   |  93.5 | 2021-09-08      |
|  9 | Charlotte |    88 | 2021-09-06      |
|  7 | Ava       |  89.5 | 2021-09-06      |
|  5 | Sophia    |  91.5 | 2021-09-05      |
|  4 | James     |  87.5 | 2021-09-03      |
|  3 | Olivia    |  95.5 | 2021-09-03      |
|  2 | William   |  90.5 | 2021-09-02      |
|  1 | Emma      |    85 | 2021-09-01      |
| 10 | Ethan     |    92 | 2021-09-01      |
|  6 | Benjamin  |  96.5 | 2021-09-01      |
+----+-----------+-------+-----------------+
10 rows in set
```

### ORDER BY句で関数を使用したソート

`ORDER BY` 句では、関数を使用してクエリ結果をソートすることができます。関数をソートする列または式に適用することで、より複雑なデータソートを実行することができます。

例22：テーブル `student` 内の学生情報を `DAY(enrollment_date)` の降順、`score` の昇順で表示します。

```sql
SELECT id, name, score, enrollment_date
FROM student
ORDER BY DAY (enrollment_date) DESC,score ASC;
```

実行結果は次のとおりです：

```shell
+----+-----------+-------+-----------------+
| id | name      | score | enrollment_date |
+----+-----------+-------+-----------------+
|  8 | Michael   |  93.5 | 2021-09-08      |
|  9 | Charlotte |    88 | 2021-09-06      |
|  7 | Ava       |  89.5 | 2021-09-06      |
|  5 | Sophia    |  91.5 | 2021-09-05      |
|  4 | James     |  87.5 | 2021-09-03      |
|  3 | Olivia    |  95.5 | 2021-09-03      |
|  2 | William   |  90.5 | 2021-09-02      |
|  1 | Emma      |    85 | 2021-09-01      |
| 10 | Ethan     |    92 | 2021-09-01      |
|  6 | Benjamin  |  96.5 | 2021-09-01      |
+----+-----------+-------+-----------------+
10 rows in set
```

### データフィルタリング後のソート

`WHERE` 句を使用してソート前のデータフィルタリングを実行することができます。

例23：テーブル `student` 内の学生情報を `score` が `85`より大きいという条件で照会し、`DAY(enrollment_date)` に基づいて昇順で表示します。

```sql
SELECT id, name, score, DAY (enrollment_date)
FROM student
WHERE score > 85
ORDER BY DAY (enrollment_date) ASC;
```

実行結果は次のとおりです：

```shell
+----+-----------+-------+----------------------+
| id | name      | score | DAY(enrollment_date) |
+----+-----------+-------+----------------------+
|  6 | Benjamin  |  96.5 |                    1 |
| 10 | Ethan     |    92 |                    1 |
|  2 | William   |  90.5 |                    2 |
|  3 | Olivia    |  95.5 |                    3 |
|  4 | James     |  87.5 |                    3 |
|  5 | Sophia    |  91.5 |                    5 |
|  7 | Ava       |  89.5 |                    6 |
|  9 | Charlotte |    88 |                    6 |
|  8 | Michael   |  93.5 |                    8 |
+----+-----------+-------+----------------------+
9 rows in set
```

## LIMIT句

### 結果セットの行数の制限

SQLクエリでは、`LIMIT` 句を使用して、返される結果セットの行数を制限することができます。

行数を制限する `LIMIT` 句の書式1は次のとおりです：

```sql
LIMIT [offset,] row_count
```

行数を制限する `LIMIT` 句の書式2は次のとおりです：

```sql
LIMIT row_count OFFSET offset
```

**パラメータの説明：**

* `offset`：オフセット量、すなわちスキップする行数を示します。書式1の `offset` はオプションです。デフォルトは0で、0行をスキップすることを表します。`offset` 値の範囲は[0,+∞)です。

* `row_count`：返す行数を示します。書式1では `offset` が指定されない場合、デフォルトで1行目から開始されます。`row_count` の値の範囲は[0,+∞)です。

<main id="notice" type='notice'>
  <h4>注意</h4>
  <p><code>offset</code> と <code>row_count</code> の値には次の制限があります：<ul><li>式を使用することはできません。</li><li>明示的な数字に限ります。負の数を指定することはできません</li></ul></p>
</main>

#### 最初のm行のレコードを取得する

例24：テーブル `student` の `id`、`name` 列のデータのうち、最初の5件のレコードのみを照会します。

```sql
SELECT id, name
FROM student
LIMIT 5;
```

実行結果は次のとおりです：

```shell
+----+---------+
| id | name    |
+----+---------+
|  1 | Emma    |
|  2 | William |
|  3 | Olivia  |
|  4 | James   |
|  5 | Sophia  |
+----+---------+
5 rows in set
```

#### 最大値のレコード1件のみ取得する

例25：テーブル `student` で `score` の最大値のレコード1件のみ取得する場合は、まず先に `score` で降順にソートしてから、最初の1件目のレコードを取得します。

```sql
SELECT id, name, score
FROM student
ORDER BY score DESC
LIMIT 1;
```

実行結果は次のとおりです：

```shell
+----+----------+-------+
| id | name     | score |
+----+----------+-------+
|  6 | Benjamin |  96.5 |
+----+----------+-------+
1 row in set
```

#### n行のレコードをスキップした後のm行のレコードを取得する

<main id="notice" type='explain'>
  <h4>説明</h4>
  <p>n行のレコードをスキップした後、残りのデータの行数がmより小さい場合、クエリ結果は残りのすべてのデータになります。</p>
</main>

例26：テーブル `student` 内で、`id` 列と `name` 列の5行目より後の3行のデータを取得します。

```sql
SELECT id, name
FROM student
LIMIT 3 OFFSET 5;
```

実行結果は次のとおりです：

```shell
+----+----------+
| id | name     |
+----+----------+
|  6 | Benjamin |
|  7 | Ava      |
|  8 | Michael  |
+----+----------+
3 rows in set
```

### ページネーションクエリ

SQLクエリでは、`LIMIT` 句を使用してページネーションクエリを実装することができます。

`LIMIT` 句を使用したページネーションクエリの書式は次のとおりです：

```sql
LIMIT (page_no - 1) * page_size, page_size;
```

**パラメータの説明：**

* `page_no`：ページ番号を示します。1から始まり、範囲は[1,+∞)です。

* `page_size`：1ページに表示するレコード数を表します。範囲は[1,+∞)です。例えば、page_no = 5、page_size = 10は、5ページ目の10件のデータを取得することを表します。

例27：テーブル `student` で、1ページにつき2件のデータを表示し、1ページ目、2ページ目、3ページ目のデータを順番に取得します。

1ページ目：

```sql
SELECT id, name
FROM student
ORDER BY id
LIMIT 0,2;
```

実行結果は次のとおりです：

```shell
+----+---------+
| id | name    |
+----+---------+
|  1 | Emma    |
|  2 | William |
+----+---------+
2 rows in set
```

2ページ目：

```sql
SELECT id, name
FROM student
ORDER BY id
LIMIT 2,2;
```

実行結果は次のとおりです：

```shell
+----+--------+
| id | name   |
+----+--------+
|  3 | Olivia |
|  4 | James  |
+----+--------+
2 rows in set
```

3ページ目：

```sql
SELECT id, name
FROM student
ORDER BY id
LIMIT 4,2;
```

実行結果は次のとおりです：

```shell
+----+----------+
| id | name     |
+----+----------+
|  5 | Sophia   |
|  6 | Benjamin |
+----+----------+
2 rows in set
```

## 関連ドキュメント

* `SELECT` 構文に関する詳細については、[SELECT](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001974942)を参照してください。

* クエリ条件で使用する演算子の詳細については、[比較演算子](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001974214)を参照してください。

* サブクエリに関する詳細については、[サブクエリ](200.multi-table-join-query-of-mysql-mode/500.subquery-of-mysql-mode-develop.md)を参照してください。

* クエリステートメントの最適化に関する詳細については、[クエリ・リライトの概要](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001974685)を参照してください。
