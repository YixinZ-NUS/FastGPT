| Description   |                 |
|---------------|-----------------|
| keywords      |                 |
| dir-name      |                 |
| dir-name-en   |                 |
| tenant-type   | MySQL Mode      |

# SQLを使用した高速なベクトル検索

OceanBaseはSQL言語を使用したベクトル検索をサポートしており、本記事ではそのクイックスタート方法を紹介します。

## 前提条件

* [OceanBaseクラスタをデプロイ済み](../../400.deploy/100.deploy-overview.md)であり、MySQLテナントを作成済みであること。

* OceanBaseデータベースに接続していること。詳細については、[接続方法の概要](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001971653)を参照してください。

## クイックスタート

### ベクトルインデックスのメモリの設定

OceanBaseのベクトル検索では、[ob_vector_memory_limit_percentage](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001976671)を使ってベクトルインデックスのメモリを設定できます。

* **V4.3.5 BP3以前**では、`ob_vector_memory_limit_percentage`を手動で設定してベクトル機能を有効にする必要があります。最適なクエリパフォーマンスを得るために、値は`30`に設定することをお勧めします。デフォルト値のままだと、ベクトルインデックスにメモリが割り当てられず、インデックス作成時にエラーが発生します。設定例は以下の通りです：

    ```sql
    ALTER SYSTEM SET ob_vector_memory_limit_percentage = 30;
    ```

* **V4.3.5 BP3以降**では、ベクトル検索機能がデフォルトで有効になっています。デフォルト値の`0`は適応モードを意味し、システムがテナント内のベクトルインデックスデータのメモリ使用率を自動的に調整します。手動で調整する必要はありません：
  * テナントの実際のメモリが8GB以下の場合、この値は自動的に`40`に設定されます。
  * テナントの実際のメモリが8GBを超える場合、この値は自動的に`50`に設定されます。

### ベクトル列とインデックスの作成

テーブルを作成する際に、`VECTOR(dim)` データ型を使用して、指定した列をベクトル列として定義し、その次元数を指定できます。ベクトルインデックスはベクトル列上に作成する必要があり、少なくとも `type` と `distance` の2つのパラメータを指定する必要があります。

例では、ベクトル列 `embedding` を作成し、ベクトルデータの次元を `3` に設定します。さらに、`embedding` 列にHNSWインデックスを作成し、距離アルゴリズムとしてL2を指定します。

```sql
CREATE TABLE t1(
    id INT PRIMARY KEY,
    doc VARCHAR(200),
    embedding VECTOR(3),
    VECTOR INDEX idx1(embedding) WITH (distance=L2, type=hnsw)
    );
```

データ量が多い場合は、データを全てインポートしてからベクトルインデックスを作成することを推奨します。インデックス作成の詳細については、[ベクトル検索インデックス](../200.ob-vector-index.md)を参照してください。

### ベクトルデータの書き込み

ベクトル検索のシナリオをシミュレートするためには、まずベクトルデータを作成する必要があります。各行データには、データの説明と対応するベクトルが含まれます。例では、`'リンゴ'` に対応するベクトルは `'[1.2,0.7,1.1]'`、`'ニンジン'` に対応するベクトルは `'[5.3,4.8,5.4]'` などと仮定しています。

```sql
INSERT INTO t1
  VALUES (1, 'リンゴ', '[1.2,0.7,1.1]'),
         (2, 'バナナ', '[0.6,1.2,0.8]'),
         (3, 'オレンジ','[1.1,1.1,0.9]'),
         (4, 'ニンジン', '[5.3,4.8,5.4]'),
         (5, 'ほうれん草', '[4.9,5.3,4.8]'),
         (6, 'トマト','[5.2,4.9,5.1]');
```

表示の簡略化のため、本例ではベクトルの次元を3次元とし、ベクトルは人工的に生成されたものです。実際のアプリケーションでは、埋め込みモデルを使用して実際のテキストを生成する必要があり、その次元は数百から数千に達します。

テーブル内のデータをクエリして、書き込みが成功したかどうかを確認できます。

```sql
SELECT * FROM t1;
```

期待される実行結果は次のとおりです：

```shell
+----+-----------+---------------+
| id | doc       | embedding     |
+----+-----------+---------------+
|  1 | リンゴ      | [1.2,0.7,1.1] |
|  2 | バナナ      | [0.6,1.2,0.8] |
|  3 | オレンジ      | [1.1,1.1,0.9] |
|  4 | キャロット    | [5.3,4.8,5.4] |
|  5 | ほうれん草      | [4.9,5.3,4.8] |
|  6 | トマト    | [5.2,4.9,5.1] |
+----+-----------+---------------+
6 rows in set
```

### ベクトル検索の実行

ベクトル検索を行うには、検索条件としてベクトルを提供する必要があります。例えば、`'果物'` に対応するベクトルが `[0.9, 1.0, 0.9]` だとすると、このベクトルに最も近いレコードを検索するSQLクエリは以下のようになります。

```sql
SELECT id, doc FROM t1
ORDER BY l2_distance(embedding, '[0.9, 1.0, 0.9]')
APPROXIMATE LIMIT 3;
```

期待される実行結果は次のとおりです：

```shell
+----+--------+
| id | doc    |
+----+--------+
|  3 | オレンジ  |
|  2 | バナナ   |
|  1 | アップル   |
+----+--------+
3 rows in set
```

## 関連ドキュメント

* ベクトルデータの詳細については、[ベクトルデータ](../700.ob-vector-search-reference/100.ob-vector-data-type.md)を参照してください。

* テーブル作成後のベクトルインデックスの作成、削除方法については、[ベクトルインデックス](../200.ob-vector-index.md)を参照してください。