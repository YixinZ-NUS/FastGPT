| Description   |                 |
|---------------|-----------------|
| keywords      |                 |
| dir-name      |                 |
| dir-name-en   |                 |
| tenant-type   | MySQL Mode      |

# pyobvector Python SDKインターフェースの説明

pyobvectorはOceanBaseベクトルストレージ機能のpython SDKであり、2つの使用モードを提供します。

* pymilvus互換モード：MilvusLikeClientオブジェクトを使用してデータベースを操作し、軽量なMilvusClientと互換性のある一般的なインターフェースを提供します。

* SQLAlchemy拡張モード：ObVecClientオブジェクトを使用してデータベースを操作し、リレーショナルデータベース用のpython SDK拡張機能を提供します。

本記事では、2つのモードにおける使用インターフェースと例をそれぞれ紹介します。

## MilvusLikeClient

### コンストラクター

```python

def __init__(
    self,
    uri: str = "127.0.0.1:2881",
    user: str = "root@test",
    password: str = "",
    db_name: str = "test",
    **kwargs,
)
```

### collection関連インターフェース

| API | パラメータ記述 | 例 |
|------|------|------|
| `def create_schema(self, **kwargs) -> CollectionSchema:` | <ul>CollectionSchemaオブジェクトを作成します<li>パラメータなしで、空のモード定義を初期化できます。</li><li>選択可能なパラメータについては以下のとおりです：</li><ul><li>fields：FieldSchemaのリスト(詳細は以下のadd_schemaインターフェースを参照してください)</li><li>partitions：パーティションルール(詳細についてはObPartitionを使用したパーティションルールの定義に関する章を参照してください)</li><li>description：Milvusと互換性がありますが、OceanBaseでは現時点で実用的な役割はありません</li></ul> |  |
| <pre><code>def create_collection(<br/>self,<br/>collection_name: str,<br/>dimension: Optional[int] = None,<br/>primary_field_name: str = "id",<br/>id_type: Union[DataType, str] = DataType.INT64,<br/>vector_field_name: str = "vector",<br/>metric_type: str = "l2",<br/>auto_id: bool = False,<br/>timeout: Optional[float] = None,<br/>schema: Optional[CollectionSchema] = None,  # Used for custom setup<br/>index_params: Optional[IndexParams] = None,  # Used for custom setup<br/>max_length: int = 16384,<br/>**kwargs,<br/>)</code></pre> | テーブルを作成します：<ul><li>collection_name : テーブル名</li><li>dimension : ベクトルデータの次元</li><li>primary_field_name: プライマリフィールド名</li><li>id_type: プライマリフィールドデータ型(VARCHARとINT型のみがサポートされています)</li><li>vector_field_name : ベクトルフィールド名</li><li>metric_type: OceanBaseではまだ使用されていませんが、インターフェースの互換性は維持されています(主テーブルの定義においてベクトル距離関数を指定する必要がないため)</li><li>auto_id：プライマリフィールドが自動インクリメントされるかどうか</li><li>timeout : OceanBaseではまだ使用されていませんが、インターフェースの互換性は維持されています</li><li>schema : カスタム集合アーキテクチャの場合、`schema` がNoneでない場合、上記のdimensionからmetric_typeまでのパラメータは無視されます</li><li>index_params: カスタムベクトルインデックスパラメータ</li><li>max_length: プライマリフィールドデータ型がVARCHARで、かつ `schema` がNoneでない場合の最大varcharの長さは `max_length`となります</li></ul> | <pre><code>client.create_collection(<br/>collection_name=test_collection_name,<br/>schema=schema,<br/>index_params=idx_params,<br/>)</code></pre> |
| <pre><code>def get_collection_stats(<br/>self, collection_name: str, timeout: Optional[float] = None # pylint: disable=unused-argument<br/>) -> Dict:</code></pre> | テーブルのレコードの数を取得します<ul><li>collection_name：テーブル名</li><li>timeout : OceanBaseではまだ使用されていませんが、インターフェースの互換性は維持されています</li></ul> |  |
| <pre><code>def has_collection(self, collection_name: str, timeout: Optional[float] = None) -> bool</code></pre> | テーブルが存在しているかどうかを判断します<ul><li>collection_name：テーブル名</li><li>timeout : OceanBaseではまだ使用されていませんが、インターフェースの互換性は維持されています</li></ul> |  |
| <pre><code>def drop_collection(self, collection_name: str) -> None</code></pre> | リネームテーブル<ul><li>old_name：元のテーブル名</li><li>new_name：新しいテーブル名</li></ul> |  |
| <pre><code>def load_table(self, collection_name: str,)</code></pre> | テーブルのメタデータをSQLAlchemyメタデータキャッシュに読み込みます<ul><li>collection_name：テーブル名</li></ul> |  |

### CollectionSchema & FieldSchema

MilvusLikeClientは、CollectionSchemaを使用してテーブルのモード定義を記述します。1つのCollectionSchemaは複数のFieldSchemaを含み、FieldSchemaは1つのテーブルの列モードを記述します。

#### MilvusLikeClientのcreate_schemaを使用してCollectionSchemaを作成します

```python
def __init__(
    self,
    fields: Optional[List[FieldSchema]] = None,
    partitions: Optional[ObPartition] = None,
    description: str = "",  # ignored in oceanbase
    **kwargs,
)
```

パラメータの説明は以下のとおりです：

* fields：FieldSchemaのオプションのセット。

* partitions：パーティションルール(詳細についてはObPartitionを使用したパーティションルールの定義に関する章を参照してください)。

* description：Milvusと互換性がありますが、OceanBaseでは現時点で実用的な役割はありません。

#### FieldSchemaを作成してCollectionSchemaに登録する

```python
def add_field(self, field_name: str, datatype: DataType, **kwargs)
```

* field_name：列名。

* datatype：列データ型。サポートされているデータ型の詳細については、 [互換性に関する説明](../800.ob-vector-sdk-refer.md)を参照してください。

* kwargs：その他のパラメータは列属性の設定に使用されます。例は以下のとおりです：

    ```python
    def __init__(
    self,
    name: str,
    dtype: DataType,
    description: str = "",
    is_primary: bool = False,
    auto_id: bool = False,
    nullable: bool = False,
    **kwargs,
    )
    ```

    パラメータの説明は以下のとおりです：

    * is_primary：主キーであるかどうか。

    * auto_id：自動インクリメント列かどうか。

    * nullable：空を許可するかどうか。

#### 使用例

```python
schema = self.client.create_schema()
schema.add_field(field_name="id", datatype=DataType.INT64, is_primary=True)
schema.add_field(field_name="title", datatype=DataType.VARCHAR, max_length=512)
schema.add_field(
    field_name="title_vector", datatype=DataType.FLOAT_VECTOR, dim=768
)
schema.add_field(field_name="link", datatype=DataType.VARCHAR, max_length=512)
schema.add_field(field_name="reading_time", datatype=DataType.INT64)
schema.add_field(
    field_name="publication", datatype=DataType.VARCHAR, max_length=512
)
schema.add_field(field_name="claps", datatype=DataType.INT64)
schema.add_field(field_name="responses", datatype=DataType.INT64)

self.client.create_collection(
    collection_name="medium_articles_2020", schema=schema
)
```

### インデックス関連

| API | パラメータ記述 | 例または備考 |
|-----|-----|-----|
| <pre><code>def create_index(<br/>self,<br/>collection_name: str,<br/>index_params: IndexParams,<br/>timeout: Optional[float] = None,<br/>**kwargs,<br/>)</code></pre> | 作成済みのIndexParamsに基づいてベクトルインデックステーブルを作成する(このインターフェースのIndexParamsに関する使用の詳細については、prepare_index_paramsとadd_indexインターフェースを参照してください)<ul><li>collection_name：テーブル名</li><li>index_params：インデックスパラメータ</li><li>timeout：OceanBaseではまだ使用されていませんが、インターフェースの互換性は維持されています</li><li>kwargs：その他のパラメータについては、現在のところ使用されていませんが、互換性は維持されています</li></ul> |  |
| <pre><code>def drop_index(<br/>self,<br/>collection_name: str,<br/>index_name: str,<br/>timeout: Optional[float] = None,<br/>**kwargs,<br/>)</code></pre> | インデックステーブル削除<ul><li>collection_name：テーブル名</li><li>index_name：インデックス名</li></ul> |  |
| <pre><code>def refresh_index(<br/>self,<br/>collection_name: str,<br/>index_name: str,<br/>trigger_threshold: int = 10000,<br/>)</code></pre> | 読み取りの性能を向上させるためにベクトルインデックステーブルをリフレッシュします。これは増分データの移行とみなすことができます<ul><li>collection_name：テーブル名</li><li>index_name：インデックス名</li><li>trigger_threshold：リフレッシュ動作のトリガー閾値。インデックステーブルのデータ量がこの閾値を超えると、リフレッシュが行なわれます</li></ul> | OceanBaseで追加されたインターフェース<br/>Milvusとの互換性はありません |
| <pre><code>def rebuild_index(<br/>self,<br/>collection_name: str,<br/>index_name: str,<br/>trigger_threshold: float = 0.2,<br/>)</code></pre> | 読み取りの性能を向上させるためにベクトルインデックステーブルを再構築します。これは増分データをベースラインインデックスデータにマージすることとみなすことができます<ul><li>collection_name：テーブル名</li><li>index_name：インデックス名</li><li>trigger_threshold：再構築動作のトリガー閾値。値の範囲は0から1で、増分データがフルデータに占める割合がこの閾値に達すると再構築がトリガーされます</li></ul> | OceanBaseに追加されたインターフェース<br/>Milvusとの互換性はありません |
| <pre><code>def search(<br/>self,<br/>collection_name: str,<br/>data: list,<br/>anns_field: str,<br/>with_dist: bool = False,<br/>filter=None,limit: int = 10,output_fields: Optional[List[str]] = None,<br/>search_params: Optional[dict] = None,<br/>timeout: Optional[float] = None,<br/>partition_names: Optional[List[str]] = None,<br/>**kwargs,<br/>) -> List[dict]</code></pre> | ベクトル近似近傍検索を実行します<ul><li>collection_name：テーブル名</li><li>data：検索が必要なベクトルデータ</li><li>anns_field: 検索が必要なベクトル列名</li><li>with_dist: ベクトル距離の結果を返すかどうか</li><li>filter : フィルタ条件付きベクトル近似近傍検索を使用します</li><li>limit：top K</li><li>output_fields: 出力列(または投影列) </li><li>search_params : 値が `l2` / `neg_ip` の `metric_type` のみをサポートします（例：search_params = {"metric_type": "neg_ip"} ）</li><li>timeout : OceanBaseでは使用されていません。互換性のためのみです</li><li>partition_names : クエリを特定のパーティションに制限します</li></ul><ul>戻り値：<br/>レコードのリストで、各レコードは辞典です<br/> column_nameから列値へのマッピングを表しています。</ul> | <pre><code>res = self.client.search(<br/>collection_name=test_collection_name,<br/>data=[0, 0, 1],<br/>anns_field="embedding",<br/>limit=5,<br/>output_fields=["id"],<br/>search_params={"metric_type": "neg_ip"}<br/>)<br/>self.assertEqual(<br/> set([r['id'] for r in res]), set([12, 111, 11, 112, 10])) |
| <pre><code>def query(<br/>self,<br/>collection_name: str,<br/>flter=None,<br/>output_fields: Optional[List[str]] = None,<br/>timeout: Optional[float] = None,<br/>partition_names: Optional[List[str]] = None,<br/>**kwargs,<br/>) -> List[dict]</code></pre> | 指定されたフィルタ条件を使用してデータレコードを読み取ります<ul><li>collection_name：テーブル名</li><li>flter : フィルタ条件付きのベクトル近似近傍検索を使用します</li><li>output_fields: 出力列(または投影列) </li><li>timeout : OceanBaseでは使用されていません。互換性のためのみです</li><li>partition_names : クエリを特定のパーティションに制限します</li></ul><ul>戻り値：<br/>レコードのリストで、各レコードは辞典です<br/> column_nameから列値へのマッピングを表しています。</ul> | <pre><code>table = self.client.load_table(collection_name=test_collection_name)<br/>where_clause = [table.c["id"] < 100]<br/>res = self.client.query(<br/>  collection_name=test_collection_name,<br/>  output_fields=["id"],<br/>  flter=where_clause,<br/>) |
| <pre><code>def get(<br/>self,<br/>collection_name: str,<br/>ids: Union[list, str, int],<br/>output_fields: Optional[List[str]] = None,<br/>timeout: Optional[float] = None,<br/>partition_names: Optional[List[str]] = None,<br/>**kwargs,<br/>) -> List[dict]</code></pre> | 指定された主キー `ids` のレコードを取得します：<ul><li>collection_name：テーブル名</li><li>ids：特定のidまたはidリスト。注意：MilvusLikeClient getインターフェースのidsパラメータは、ObVecClientのgetと異なります。詳細については、<a href="#DML%20操作">ObVecClient get</a> を参照してください</li><li>output_fields: 出力列(または投影列) </li><li>timeout : OceanBaseでは使用されていません。互換性のためのみです</li><li>partition_names : クエリを特定のパーティションに制限します</li></ul>戻り値：<br/>レコードのリストで、各レコードは辞典です<br/> column_nameから列値へのマッピングを表しています。 | <pre><code>res = self.client.get(<br/>  collection_name=test_collection_name,<br/>  output_fields=["id", "meta"],<br/>  ids=[80, 12, 112],<br/>) |
| <pre><code>def delete(<br/>self,<br/>collection_name: str,<br/>ids: Optional[Union[list, str, int]] = None,<br/>timeout: Optional[float] = None, # pylint: disable=unused-argument<br/>flter=None,<br/>partition_name: Optional[str] = "",<br/>**kwargs, # pylint: disable=unused-argument<br/>)</code></pre> | 集合内のデータを削除します<ul><li>collection_name：テーブル名</li><li>ids：特定のidまたはidリスト</li><li>timeout : OceanBaseでは使用されていません。互換性のためのみです</li><li>flter : フィルタ条件付きのベクトル近似近傍検索を使用します</li><li>partition_name : 削除操作を特定のパーティションに制限します</li></ul> | <pre><code>self.client.delete(<br/>    collection_name=test_collection_name, ids=[12, 112], partition_name="p0"<br/>)</code></pre> |
| <pre><code>def insert(<br/>  self, <br/>  collection_name: str, <br/>  data: Union[Dict, List[Dict]], <br/>  timeout: Optional[float] = None, <br/>  partition_name: Optional[str] = ""<br/>)</code></pre> | テーブルにデータを挿入します<ul><li>collection_name：テーブル名</li><li>data：Key-Value形式で記述された挿入するデータ</li><li>timeout : OceanBaseでは使用されていません。互換性のためのみです</li><li>partition_name : 挿入操作を特定のパーティションに制限します</li></ul> | <pre><code>data = [<br/>    {"id": 12, "embedding": [1, 2, 3], "meta": {"doc": "oceanbase document 1"}},<br/>    {<br/>        "id": 90,<br/>        "embedding": [0.13, 0.123, 1.213],<br/>        "meta": {"doc": "oceanbase document 1"},<br/>    },<br/>    {"id": 112, "embedding": [1, 2, 3], "meta": None},<br/>    {"id": 190, "embedding": [0.13, 0.123, 1.213], "meta": None},<br/>]<br/>self.client.insert(collection_name=test_collection_name, data=data)</code></pre> |
| <pre><code>def upsert(<br/>self,<br/>collection_name: str,<br/>data: Union[Dict, List[Dict]],<br/>timeout: Optional[float] = None, # pylint: disable=unused-argument<br/>partition_name: Optional[str] = "",<br/>) -> List[Union[str, int]]</code></pre> | テーブルのデータを更新します。主キーが重複した場合、それを交換します<ul><li>collection_name：テーブル名</li><li>data：更新挿入するデータの形式は、insertインターフェースと一致しています</li><li>timeout : OceanBaseでは使用されていません。互換性のためのみです</li><li>partition_name : 挿入操作を特定のパーティションに制限します</li></ul> | <pre><code>data = [<br/>    {"id": 112, "embedding": [1, 2, 3], "meta": {'doc':'hhh1'}},<br/>    {"id": 190, "embedding": [0.13, 0.123, 1.213], "meta": {'doc':'hhh2'}},<br/>]<br/>self.client.upsert(collection_name=test_collection_name, data=data)</code></pre> |
| <pre><code>def perform_raw_text_sql(self, text_sql: str):<br/>    return super().perform_raw_text_sql(text_sql)</code></pre> | SQLステートメントを直接実行します<ul><li>text_sql: 実行するSQL</li></ul>戻り値：<br/>SQLAlchemyが提供する結果セットのイテレータを返します |  |

## ObVecClient

### コンストラクター

```python
def __init__(
    self,
    uri: str = "127.0.0.1:2881",
    user: str = "root@test",
    password: str = "",
    db_name: str = "test",
    **kwargs,
)
```

### テーブルモード関連操作

| API | パラメータ記述 | 例または備考 |
|-----|-----|-----|
| <pre><code>def check_table_exists(self, table_name: str)</code></pre> | 検査テーブルが存在しているかどうか<ul><li>table_name：テーブル名</li></ul> |  |
| <pre><code>def create_table(<br/>self,<br/>table_name: str,<br/>columns: List[Column],<br/>indexes: Optional[List[Index]] = None,<br/>partitions: Optional[ObPartition] = None,<br/>)</code></pre> | テーブル作成<ul><li>table_name：テーブル名</li><li>columns：SQLAlchemyで定義されたテーブルの列モード</li><li>indexes：SQLAlchemyで定義された一連のインデックステーブルモード</li><li>partitions：オプションのパーティションルール(詳細については、ObPartitionを使用したパーティションルールの定義に関する章を参照してください)</li></ul> |  |
| <pre><code>@classmethod<br/>def prepare_index_params(cls)</code></pre> | IndexParams対象を作成してベクトルインデックステーブルのモード定義を記録します<pre><code>class IndexParams:<br/>    """Vector index parameters for MilvusLikeClient"<br/>    def __init__(self):<br/>        self._indexes = {}</code></pre>IndexParamsの定義は非常にシンプルで、内部には辞書タイプのメンバのみを持ち、<br/>(列名、インデックス名)のtupleからIndexParam構造へのマッピングを保持します<br/>IndexParamタイプの構造関数は：<pre><code>def __init__(<br/>    self,<br/>    index_name: str,<br/>    field_name: str,<br/>    index_type: Union[VecIndexType, str],<br/>    **kwargs<br/>)</code></pre><ul><li>index_name：ベクトルインデックステーブル名</li><li>field_name：ベクトル列名</li><li>index_type：ベクトルインデックスアルゴリズムタイプの列挙型で、現在はHNSWのみをサポートしています</li></ul> `prepare_index_params` を通じてIndexParamsを取得した後、`add_index` インターフェースを通じてIndexParamを登録できます：<pre><code>def add_index(<br/>    self,<br/>    field_name: str,<br/>    index_type: VecIndexType,<br/>    index_name: str,<br/>    **kwargs<br/>)</code></pre>パラメータの意味はIndexParamの構造関数と同じです | ベクトルインデックスを作成する使用例を示しています：<pre><code>idx_params = self.client.prepare_index_params()<br/>idx_params.add_index(<br/>    field_name="title_vector",<br/>    index_type="HNSW",<br/>    index_name="vidx_title_vector",<br/>    metric_type="L2",<br/>    params={"M": 16, "efConstruction": 256},<br/>)<br/>self.client.create_collection(<br/>    collection_name=test_collection_name,<br/>    schema=schema,<br/>   <br/>index_params=idx_params,<br/>)</code></pre>注意が必要なのは `prepare_index_params` 関数はMilvusLikeClientで使用し、ObVecClientでは使用しないことが推奨されます。ObVecClientモードでは `create_index` インターフェースを使用してベクトルインデックステーブルを定義しなければなりません。(詳細については、create_indexインターフェースを参照してください) |
| <pre><code>def create_table_with_index_params(<br/>self,<br/>table_name: str,<br/>columns: List[Column],<br/>indexes: Optional[List[Index]] = None,<br/>vidxs: Optional[IndexParams] = None,<br/>partitions: Optional[ObPartition] = None,<br/>) | オプションのindex_paramsを使用して、テーブルを作成すると同時にベクトルインデックスを作成します<ul><li>table_name：テーブル名</li><li>columns：SQLAlchemyで定義されたテーブルの列モード</li><li>indexes：SQLAlchemyで定義されたインデックステーブルの列モード</li><li>vidxs：IndexParamsで指定されたベクトルインデックステーブルモード</li><li>partitions：オプションのパーティションルール(詳細については、ObPartitionを使用したパーティションルールの定義に関する章を参照してください)</li></ul> | MilvusLikeClientでの使用が推奨されます。ObVecClientでの使用は推奨されません |
| <pre><code>def create_index(<br/>self,<br/>table_name: str,<br/>is_vec_index: bool,<br/>index_name: str,<br/>column_names: List[str],<br/>vidx_params: Optional[str] = None,<br/>**kw,<br/>)</code></pre> | 通常インデックスとベクトルインデックスの2つのモードの作成をサポートします<ul><li>table_name：テーブル名</li><li>is_vec_index：インデックスまたはベクトルインデックスです</li><li>index_name：インデックス名</li><li>column_names：どの列にインデックスを作成するか</li><li>vidx_params：ベクトルインデックスのパラメータ。例：`“distance=l2, type=hnsw, lib=vsag”`</li></ul>現在、OceanBaseは `type=hnsw` および `lib=vsag` のみをサポートしています。これらの2つの設定は保持してください。distanceは `l2` または `inner_product` に設定できます | <pre><code>self.client.create_index(<br/>    test_collection_name,<br/>    is_vec_index=True,<br/>    index_name="vidx",<br/>    column_names=["embedding"],<br/>    vidx_params="distance=l2, type=hnsw, lib=vsag",<br/>) |
| <pre><code>def create_vidx_with_vec_index_param(<br/>self,<br/>table_name: str,<br/>vidx_param: IndexParam,<br/>)</code></pre> | ベクトルインデックスパラメータを使用してベクトルインデックスを作成します<ul><li>table_name：テーブル名</li><li>vidx_param：IndexParam構造のベクトルインデックスパラメータ</li></ul> |  |
| <pre><code>def drop_table_if_exist(self, table_name: str)</code></pre> | テーブルを削除します<ul><li>table_name：テーブル名</li></ul> |  |
| <pre><code>def drop_index(self, table_name: str, index_name: str)</code></pre> | インデックスを削除します<ul><li>table_name：テーブル名</li><li>index_name：インデックス名</li></ul> |  |
| <pre><code>def refresh_index(<br/>self,<br/>table_name: str,<br/>index_name: str,<br/>trigger_threshold: int = 10000,<br/>)</code></pre> | 読み取りの性能を向上させるためにベクトルインデックステーブルをリフレッシュします。これは増分データの移行とみなすことができます<ul><li>table_name：テーブル名</li><li>index_name：インデックス名</li><li>trigger_threshold：リフレッシュ動作のトリガー閾値。インデックステーブルのデータ量がこの閾値を超えると、リフレッシュが行なわれます</li></ul> |  |
| <pre><code>def rebuild_index(<br/>self,<br/>table_name: str,<br/>index_name: str,<br/>trigger_threshold: float = 0.2,<br/>)</code></pre> | 読み取りの性能を向上させるためにベクトルインデックステーブルを再構築します。これは増分データをベースラインインデックスデータにマージすることとみなすことができます<ul><li>table_name：テーブル名</li><li>index_name：インデックス名</li><li>trigger_threshold：再構築動作のトリガー閾値。値の範囲は0から1で、増分データがフルデータに占める割合がこの閾値に達すると再構築がトリガーされます</li></ul> |  |

### DML操作

| API | パラメータ記述 | 例または備考 |
|-----|-----|-----|
| <pre><code>def insert(<br/>self,<br/>table_name: str,<br/>data: Union[Dict, List[Dict]],<br/>partition_name: Optional[str] = "",<br/>)</code></pre> | テーブルにデータを入力します<ul><li>table_name：テーブル名</li><li>data：Key-Value形式で記述された挿入するデータ</li><li>partition_name：挿入操作を特定のパーティションに制限します</li></ul> | <pre><code>vector_value1 = [0.748479, 0.276979, 0.555195]<br/>vector_value2 = [0, 0, 0]<br/>data1 = [{"id": i, "embedding": vector_value1} for i in range(10)]<br/>data1.extend([{"id": i, "embedding": vector_value2} for i in range(10, 13)])<br/>data1.extend([{"id": i, "embedding": vector_value2} for i in range(111, 113)])<br/>self.client.insert(test_collection_name, data=data1)</code></pre> |
| <pre><code>def upsert(<br/>self,<br/>table_name: str,<br/>data: Union[Dict, List[Dict]],<br/>partition_name: Optional[str] = "",<br/>)</code></pre> | テーブルのデータを更新します。主キーが重複した場合、それを交換します。<ul><li>table_name：テーブル名</li><li>data：更新挿入するデータ。key-value形式</li><li>partition_name：更新挿入を特定のパーティションに制限します</li></ul> |  |
| <pre><code>def update(<br/>self,<br/>table_name: str,<br/>values_clause,<br/>where_clause=None,<br/>partition_name: Optional[str] = "",<br/>)</code></pre> | テーブルのデータを更新します。主キーが重複した場合、それを交換します。<ul><li>table_name：テーブル名</li><li>values_clause：更新列の値</li><li>where_clause：更新条件</li><li>partition_name：更新操作を特定のパーティションに制限します</li></ul> | <pre><code>data = [<br/>    {"id": 112, "embedding": [1, 2, 3], "meta": {'doc':'hhh1'}},<br/>    {"id": 190, "embedding": [0.13, 0.123, 1.213], "meta": {'doc':'hhh2'}},<br/>]<br/>client.insert(collection_name=test_collection_name, data=data)<br/>client.update(<br/>    table_name=test_collection_name,<br/>    values_clause=[{'meta':{'doc':'HHH'}}],<br/>    where_clause=[text("id=112")]<br/>) |
| <pre><code>def delete(<br/>self,<br/>table_name: str,<br/>ids: Optional[Union[list, str, int]] = None,<br/>where_clause=None,<br/>partition_name: Optional[str] = "",<br/>)</code></pre> | テーブルのデータを削除します<ul><li>table_name：テーブル名</li><li>ids：特定のidまたはidリスト</li><li>where_clause：削除条件</li><li>partition_name：削除操作を特定のパーティションに制限します</li></ul> | <pre><code>self.client.delete(test_collection_name, ids=["bcd", "def"])</code></pre> |
| <pre><code>def get(<br/>self,<br/>table_name: str,<br/>ids: Optional[Union[list, str, int]],<br/>where_clause = None,<br/>output_column_name: Optional[List[str]] = None,<br/>partition_names: Optional[List[str]] = None,<br/>)</code></pre> | 指定した主キー `ids` のレコードを取得します：<ul><li>table_name：テーブル名</li><li>ids：特定のidまたはidリスト。オプションのパラメータで、指定されていない場合は `ids=None` を入力できます。ObVecClient getインターフェースのidsパラメータはMilvusLikeClientのgetとは異なります。詳細については、<a href="#インデックス関連">MilvusLikeClient get</a>を参照してください</li><li>where_clause：取得条件</li><li>output_column_name：出力列または投影列の名前のセット</li><li>partition_names：取得操作を特定のパーティションに制限します</li></ul>戻り値：<br/>MilvusLikeClientとは異なり、ObVecClientの戻り値はtuple listです。各tupleは1行のレコードを表します | <pre><code>res = self.client.get(<br/>    test_collection_name,<br/>    ids=["abc", "bcd", "cde", "def"],<br/>    where_clause=[text("meta->'$.page' > 1")],<br/>    output_column_name=['id']<br/>) |
| <pre><code>def set_ob_hnsw_ef_search(self, ob_hnsw_ef_search: int)</code></pre> | HNSWインデックスのefSearchパラメータを設定します。sessionレベル変数設定では、ef_searchが大きくなればリコール率も高くなるが、クエリの性能は若干下がります。<ul><li>ob_hnsw_ef_search：HNSWインデックスのefSearchパラメータ</li></ul> |  |
| <pre><code>def get_ob_hnsw_ef_search(self) -> int</code></pre> | HNSWインデックスのefSearchパラメータを取得します |  |
| <pre><code>def ann_search(<br/>self,<br/>table_name: str,<br/>vec_data: list,<br/>vec_column_name: str,<br/>distance_func,<br/>with_dist: bool = False,<br/>topk: int = 10,<br/>output_column_names: Optional[List[str]] = None,<br/>extra_output_cols: Optional[List] = None,<br/>where_clause=None,<br/>partition_names: Optional[List[str]] = None,<br/>**kwargs,<br/>)</code></pre> | ベクトル近似近傍検索を実行します<ul><li>table_name：テーブル名</li><li>vec_data：検索が必要なベクトルデータ</li><li>vec_column_name：検索が必要なベクトル列名</li><li>distance_func：距離関数。SQLAlchemy funcの拡張を提供し、`func.l2_distance`/`func.cosine_distance`/`func.inner_product`/`func.negative_inner_product` のオプションがあります。それぞれ、l2距離関数、cosine距離関数、内積距離関数、内積距離関数のマイナス値を表します</li><li>with_dist：ベクトル距離付きの結果を返すかどうか</li><li>topk：直近のどれくらいのベクトルを取得するか</li><li>output_column_names：出力列または投影列の名前のセット</li><li>extra_output_cols：追加の出力列。より複雑な出力式を提供できます</li><li>where_clause：フィルタ条件</li><li>partition_names：クエリを特定のパーティションに制限します</li></ul>戻り値：<br/>MilvusLikeClientとは異なり、ObVecClientの戻り値はtuple listです。各tupleは1行のレコードを表します | <pre><code>res = self.client.ann_search(<br/>    test_collection_name,<br/>    vec_data=[0, 0, 0],<br/>    vec_column_name="embedding",<br/>    distance_func=func.l2_distance,<br/>    with_dist=True,<br/>    topk=5,<br/>    output_column_names=["id"],<br/>) |
| <pre><code>def precise_search(<br/>self,<br/>table_name: str,<br/>vec_data: list,<br/>vec_column_name: str,<br/>distance_func,<br/>topk: int = 10,<br/>output_column_names: Optional[List[str]] = None,<br/>where_clause=None,<br/>**kwargs,<br/>) | 正確近傍検索アルゴリズムを実行します<ul><li>table_name：テーブル名</li><li>vec_data：クエリのベクトル</li><li>vec_column_name：ベクトル列名</li><li>distance_func：ベクトル距離関数。SQLAlchemy funcの拡張を提供し、func.l2_distance/func.cosine_distance/func.inner_product/func.negative_inner_productのオプションがあります。それぞれl2距離関数、cosine距離関数、内積距離関数、内積距離関数のマイナスの値を表します</li><li>topk：直近のどれくらいのベクトルを取得するか</li><li>output_column_names：出力列または投影列の名前のセット</li><li>where_clause：フィルタ条件</li></ul>戻り値：<br/>MilvusLikeClientとは異なり、ObVecClientの戻り値はtuple listです。各tupleは1行のレコードを表します |  |
| <pre><code>def perform_raw_text_sql(self, text_sql: str)</code></pre> | SQLステートメントを直接実行します<ul><li>text_sql: 実行するSQL</li></ul>戻り値：<br/>SQLAlchemyが提供する結果セットのイテレータを返します |  |

## ObPartitionを使用したパーティションルールの定義

pyobvectorは、range/range columns、list/list columns、hash、keyおよびサブパーティションをサポートするために以下のタイプを提供します：

* ObRangePartition：rangeパーティション。構築する際に `is_range_columns = True` を設定してrange columnsパーティションを作成します。

* ObListPartition：listパーティション。構築する際に `is_list_columns = True` を設定してlist columnsパーティションを作成します。

* ObHashPartition：hashパーティション。

* ObKeyPartition：keyパーティション。

* ObSubRangePartition：rangeサブパーティション。構築する際に `is_range_columns = True` を設定してrange columnsサブパーティションを作成します。

* ObSubListPartition：listサブパーティション。構築する際に `is_list_columns = True` を設定してlist columnsサブパーティションを作成します。

* ObSubHashPartition：hashサブパーティション。

* ObSubKeyPartition：keyサブパーティション。

### rangeパーティションの例

```python
range_part = ObRangePartition(
    False,
    range_part_infos=[
        RangeListPartInfo("p0", 100),
        RangeListPartInfo("p1", "maxvalue"),
    ],
    range_expr="id",
)
```

### listパーティションの例

```python
list_part = ObListPartition(
    False,
    list_part_infos=[
        RangeListPartInfo("p0", [1, 2, 3]),
        RangeListPartInfo("p1", [5, 6]),
        RangeListPartInfo("p2", "DEFAULT"),
    ],
    list_expr="col1",
)
```

### hashパーティションの例

```python
hash_part = ObHashPartition("col1", part_count=60)
```

### マルチレベルパーティションの例

```python
# rangeパーティション
range_columns_part = ObRangePartition(
    True,
    range_part_infos=[
        RangeListPartInfo("p0", 100),
        RangeListPartInfo("p1", 200),
        RangeListPartInfo("p2", 300),
    ],
    col_name_list=["col1"],
)
# rangeサブパーティション
range_sub_part = ObSubRangePartition(
    False,
    range_part_infos=[
        RangeListPartInfo("mp0", 1000),
        RangeListPartInfo("mp1", 2000),
        RangeListPartInfo("mp2", 3000),
    ],
    range_expr="col3",
)
range_columns_part.add_subpartition(range_sub_part)
```

## 純粋なSQLAlchemy APIモード

OceanBaseデータベースのベクトル検索機能で純粋なSQLAlchemy APIを使用したい場合には、以下の2つの方法を通じて同期データベースエンジンを取得できます：

* 方法1：ObVecClientを使用してデータベースエンジンの作成を補助する

```python
from pyobvector import ObVecClient

client = ObVecClient(uri="127.0.0.1:2881", user="test@test")
engine = client.engine
# 次に、SQLAlchemyを通常通り使用してsessionを作成し、SQLAlchemyのAPIを使用します
```

* 方法2：ObVecClientの `create_engine` インターフェースを使用してデータベースエンジンを作成する

```python
import pyobvector
from sqlalchemy.dialects import registry
from sqlalchemy import create_engine

uri: str = "127.0.0.1:2881"
user: str = "root@test"
password: str = ""
db_name: str = "test"
registry.register("mysql.oceanbase", "pyobvector.schema.dialect", "OceanBaseDialect")
connection_str = (
    # mysql+aoceanbaseは、mysql標準を選択し、OceanBaseデータベースの同期ドライバーを使用することを意味します
    f"mysql+oceanbase://{user}:{password}@{uri}/{db_name}?charset=utf8mb4"
)
engine = create_engine(connection_str, **kwargs)
# 次に、SQLAlchemyを通常通り使用してsessionを作成し、SQLAlchemyのAPIを使用します
```

SQLAlchemyの非同期インターフェースを使用したい場合は、OceanBaseデータベースの非同期ドライバーを使用できます。

```python
import pyobvector
from sqlalchemy.dialects import registry
from sqlalchemy.ext.asyncio import create_async_engine

uri: str = "127.0.0.1:2881"
user: str = "root@test"
password: str = ""
db_name: str = "test"
registry.register("mysql.aoceanbase", "pyobvector", "AsyncOceanBaseDialect")
connection_str = (
    # mysql+aoceanbaseは、mysql標準を選択し、OceanBaseデータベースの非同期ドライバーを使用することを意味します
    f"mysql+aoceanbase://{user}:{password}@{uri}/{db_name}?charset=utf8mb4"
)
engine = create_async_engine(connection_str)
# 次に、SQLAlchemyを通常通り使用してsessionを作成し、SQLAlchemyのAPIを使用します
```

## さらなる例

[pyobvectorコードリポジトリ](https://github.com/oceanbase/pyobvector)にアクセスして、より多くの例を取得します。
