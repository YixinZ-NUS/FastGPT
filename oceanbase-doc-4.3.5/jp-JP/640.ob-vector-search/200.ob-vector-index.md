| Description   |                 |
|---------------|-----------------|
| keywords      |                 |
| dir-name      |                 |
| dir-name-en   |                 |
| tenant-type   | MySQL Mode      |

# ベクトルインデックスの作成

本記事は、OceanBaseにおけるベクトルインデックスの作成、検索、メンテナンス、削除について紹介します。

<main id="notice" type='notice'>
  <h4>注意</h4>
  <p><li>IVF/IVF_PQ/IVF_SQインデックスは、V4.3.5 BP1バージョンからサポートされます。</li><li><p>HNSW_BQインデックスは、V4.3.5 BP2からサポートされます。</li></p>
</main>

## インデックスのタイプ

OceanBaseがサポートするベクトルインデックスのタイプと、その詳細な説明は以下の通りです。

| インデックスタイプ | 説明 | 適用シナリオ |
|-----------|------|----------|
| HNSW      | インデックス列の最大次元は4096です。HNSWインデックスはメモリインデックスであり、メモリに完全にロードする必要があります。DMLとリアルタイム検索をサポートします。 |  |
| HNSW_SQ   | HNSWインデックスとほぼ同等の構築速度、検索性能、リコール率を提供しますが、総メモリ使用量は元の1/2～1/3に削減されます。 | パフォーマンスとリコール率に高い要求があるシナリオに適しています。 |
| HNSW_BQ   | HNSW_BQインデックスは、HNSWインデックスよりリコール率がわずかに低いものの、メモリ使用量を大幅に削減します。BQ量子化圧縮アルゴリズム（Rabitq）は、ベクトルを元のサイズの32分の1に圧縮できます。ベクトルの次元数が高くなるほど、HNSW_BQインデックスのメモリ最適化効果はより顕著になります。 |  |
| IVF| データベースのテーブルに基づいて実装されるIVFインデックスで、常駐メモリを占有しません。 | パフォーマンス要件は高くないものの、データ量が膨大で、コストを重視するシーンに適しています。 |
| IVF_PQ| データベースのテーブルに基づいて実装されるIVF_PQインデックスで、常駐メモリを占有しません。IVFをベースにPQ（積量子化）技術を応用しており、インデックスのリコール率はIVFインデックスよりわずかに低いものの、パフォーマンスは上回ります。また、PQ量子化圧縮アルゴリズムは、一般的なシーンにおいてベクトルを元のサイズの1/16～1/32に圧縮できます。 | パフォーマンス要件は高くないものの、データ量が膨大で、コストを重視するシーンに適しています。 |

その他：

* 密ベクトルインデックスは、L2(ユークリッド距離)、内積（IP）、コサイン距離を距離計算アルゴリズムとしてサポートします。
* ベクトルインデックス検索では、一部の距離関数の呼び出しがサポートされています。詳細は[SQL関数の利用](250.ob-vector-function.md)を参照してください。
* フィルタリング条件付きのベクトル検索をサポートしています。フィルタリング条件には、スカラー型の条件や、ST_Intersectsなどの空間関係を指定できます。現時点では、プリフィルタとして複数値インデックス、全文検索インデックス、グローバルインデックスはサポートされていません。
* 同一テーブル上に、ベクトルインデックスと全文検索インデックスの作成をサポートしています。
* ベクトルインデックスのオフラインDDLへの対応状況については、[オフラインDDL](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001974221)を参照してください。
* ベクトルインデックス検索は、V4.3.5 BP4バージョンから「弱い整合性読み取り（Weak Read）」をサポートしました。これにより、必ずしもリージョンをまたいでプライマリデータベースにアクセスする必要がなく、ローカルデータセンター内のレプリカデータを読み取ることが可能になりました。

制限について：

* V4.3.5 BP3では、カラムストアベクトルインデックスの作成はサポートされていません。

## ベクトルインデックスのメモリの設定

OceanBaseのベクトル検索では、[ob_vector_memory_limit_percentage](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001976671)設定を使ってベクトルインデックスのメモリを設定できます。

* **V4.3.5 BP3以前**では、`ob_vector_memory_limit_percentage`を手動で設定してベクトル機能を有効にする必要があります。最適な検索性能を得るために、値は `30`に設定することをお勧めします。デフォルト値のままだと、ベクトルインデックスにメモリが割り当てられず、インデックス作成時にエラーが発生します。設定例は以下の通りです：
    ```sql
    ALTER SYSTEM SET ob_vector_memory_limit_percentage = 30;
    ```

* **V4.3.5 BP3以降**では、ベクトル検索機能がデフォルトで有効になっています。デフォルト値の`0`は適応モードを意味し、システムがテナント内のベクトルインデックスデータのメモリ使用率を自動的に調整します。手動で調整する必要はありません：
  * テナントの実際のメモリが8GB以下の場合、この値は自動的に`40`に設定されます。
  * テナントの実際のメモリが8GBを超える場合、この値は自動的に`50`に設定されます。

## インデックスのメモリ使用量の見積もりと実際の使用状況の確認

`DBMS_VECTOR`システムパッケージを利用して、インデックスメモリの見積もりが可能です。

* テーブル作成前には、[INDEX_VECTOR_MEMORY_ADVISOR](https://en.oceanbase.com/docs/common-oceanbase-database-10000000002754002)プロシージャを使用してインデックスのメモリ使用量を見積もります。
* テーブル作成済みでデータが挿入されている場合は、[INDEX_VECTOR_MEMORY_ESTIMATE](https://en.oceanbase.com/docs/common-oceanbase-database-10000000002754001)プロシージャでインデックスのメモリ使用量を分析します。

インデックスのメモリ使用量の見積もりでは、2つの情報が返されます。1つはベクトルインデックスの作成に必要となる最小メモリ構成で、もう1つはHNSW_SQおよびIVFインデックスが作成された後の実際のメモリ使用量です。

また、`load_vector_index_on_follower`構成パラメータを使用して、`follower`ロールが自動的にメモリベクトルインデックスをロードするかどうかを制御できます。構文と例については、`load_vector_index_on_follower`のページを参照してください。弱い整合性読み取りが不要な場合は、この構成パラメータをオフにすることで、ベクトルインデックスが占有するメモリを削減できます。

実際のメモリ使用状況の詳細は、ビュー`GV$OB_VECTOR_MEMORY`または`V$OB_VECTOR_MEMORY`から取得できます。

## 作成構文と説明

OceanBaseのベクトルインデックスは、**テーブル作成時に同時に作成する**方法と、テーブル作成後に**別途追加する**方法の2種類をサポートしています。作成時には、以下の点にご注意ください：

* ベクトルインデックスを作成すには、`VECTOR` キーワードが必要となります。
* 後から作成されるインデックスのパラメータと説明は、テーブル作成時にインデックスを作成する場合と同様です。
* データ量が大きい場合は、データの書き込みを完了してからインデックスを作成することを推奨します。これにより、最適なクエリのパフォーマンスが得られます。
* HNSW_SQ/IVF/IVF_SQ/IVF_PQインデックスは、データの書き込み後に作成し、大量の増分データの書き込み後にインデックスを再作成することを推奨します。各インデックスの作成の詳細については、以下の具体的な例を参照してください。

:::tab
tab HNSW/HNSW_SQ/HNSW_BQ

テーブル作成時のインデックス作成構文：

```sql
CREATE TABLE table_name (
    column_name1 data_type1,
    column_name2 data_type2,
    ...,
    VECTOR INDEX index_name (column_name) WITH (param1=value1, param2=value2, ...)
);
```

インデックスの後付け構文：

```sql
-- 後からインデックスを追加する場合、並列度を設定することでインデックス構築のパフォーマンスを向上させることができます。並列度の最大設定値はCPUコア数*2を超えません。
CREATE [/*+ paralell $value*/] VECTOR INDEX index_name ON table_name(column_name) WITH (param1=value1, param2=value2, ...);
```

`param`パラメータの説明：

| パラメータ | デフォルト値 | 値の範囲 | 必須かどうか | 説明 | 備考 |
|------|--------|----------|----------|------|------|
| distance | | l2/inner_product/cosine | はい | ベクトル距離アルゴリズムのタイプを指定します。 | l2はユークリッド距離、inner_productは内積距離、cosineはコサイン距離を表します。 |
| type | | 現在、 `hnsw`/`hnsw_sq`/`hnsw_bq`をサポートしています。 | はい | インデックスタイプを指定します。 | |
| lib | vsag | vsag | いいえ | ベクトルインデックスライブラリのタイプを指定します。 | 現在、VSAGベクトルライブラリのみをサポートしています。 |
| m | 16 | [5,128] | いいえ | 各ノードの最大近傍数。 | 値が大きいほど、インデックスの構築は遅くなりますが、検索性能は向上します。 |
| ef_construction | 200 | [5,1000] | いいえ | インデックス構築時の候補セットのサイズ。 | 値が大きいほど、インデックスの構築は遅くなりますが、インデックスの品質は向上します。`ef_construction`は`m`より大きい必要があります。|
| ef_search | 64 | [1,1000] | いいえ | 検索時の候補セットのサイズ。 | 値が大きいほど、検索は遅くなりますが、リコール率は高くなります。 |
| extra_info_max_size | 0 | [0,16384] | いいえ | 各主キー情報の最大サイズ（単位：バイト）を設定します。テーブルの主キーをインデックスに格納することで、検索速度を向上させます。 | <code>0</code>：主キー情報を格納しません。<br/><code>1</code>：サイズ制限を無視して主キー情報を強制的に格納します。この場合、テーブルの主キータイプ（詳細は後述）はサポートされているタイプである必要があります。<br/><code>1</code> より大きい場合：主キー情報の最大サイズ（単位：バイト）を設定します。この場合、以下の条件を満たす必要があります：<ul><li>主キー情報のサイズ（計算方法は後述）は、設定されたサイズ制限より小さい必要があります。</li><li>テーブルの主キータイプはサポートされているタイプである必要があります。</li></ul> |
| refine_k | 4.0 | [1.0,1000.0] | いいえ | <main id="notice" type='notice'><h4>注意</h4><p>このパラメータはV4.3.5 BP3バージョンからサポートされており、HNSW_BQインデックスの作成時にのみ指定できます。</p></main>このパラメータは浮動小数点数型で、量子化ベクトルインデックスのリランキングの比率を調整するために使用されます。 | このパラメータはインデックス作成時に設定することも、検索時に指定することもできます：<ul><li>検索時に設定されていない場合は、インデックス作成時の値が使用されます；</li><li>検索時に設定されている場合は、検索時に設定された値が使用されます。</li></ul> |
| refine_type | sq8 <main id="notice" type='notice'><h4>注意</h4><p>クラスタが旧バージョンからV4.3.5 BP3バージョンにアップグレードされた場合、このパラメータのデフォルト値はfp32になります。</p></main> | sq8/fp32 | いいえ | <main id="notice" type='notice'><h4>注意</h4><p>このパラメータはV4.3.5 BP3バージョンからサポートされており、HNSW_BQインデックスの作成時にのみ指定できます。</p></main>量子化ベクトルインデックスの構築精度を設定するために使用されます。 | この値は、インデックス構築時のメモリ消費と構築時間を削減することで効率を向上させますが、リコール率に影響を与える可能性があります。 |
| bq_bits_query | 32 | 0/4/32 | いいえ | <main id="notice" type='notice'><h4>注意</h4><p>このパラメータはV4.3.5 BP3バージョンからサポートされており、HNSW_BQインデックスの作成時にのみ指定できます。</p></main>量子化ベクトルインデックスの検索精度を設定するために使用されます。単位はビットです。 | この値は、インデックス構築時のメモリ消費と構築時間を削減することで効率を向上させますが、リコール率に影響を与える可能性があります。 |
| bq_use_fht | true <main id="notice" type='notice'><h4>注意</h4><p>クラスタが旧バージョンからV4.3.5 BP3バージョンにアップグレードされた場合、このパラメータのデフォルト値はfalseになります。</p></main> | true/false | いいえ | <main id="notice" type='notice'><h4>注意</h4><p>このパラメータはV4.3.5 BP3バージョンからサポートされており、HNSW_BQインデックスの作成時にのみ指定できます。</p></main>検索にFHTを使用するかどうかを設定します。FHT(高速アダマール変換)は、ベクトル内積計算を高速化するためのアルゴリズムです。 | |

`extra_info_max_size`でサポートされている主キーの型は以下の通りです：

* [数値型](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001975803)：整数型、浮動小数点数型、Bit_value型をサポートします。
* [日付時刻型](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001975805)
* [文字列型](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001975810)：VARCHAR型をサポートします。

主キー情報のサイズの計算方法：

```sql
SET @table_name = 'test'; -- 照会したいtable_nameに置き換えてください

SELECT
    CASE
        WHEN COUNT(*) <> COUNT(result_value) THEN 'not support'
        ELSE COALESCE(SUM(result_value), 'not support')
    END AS extra_info_size
FROM (
    SELECT
        CASE
            WHEN vdt.data_type_class IN (1, 2, 3, 4, 6, 8, 9, 14, 27, 28) THEN 8 -- 数値型の場合、extra_info_size += 8
            WHEN oc.data_type = 22 THEN oc.data_length -- varchar型の場合、extra_info_size += data_length
            ELSE NULL -- その他の型はサポートされていません
        END AS result_value
    FROM
        oceanbase.__all_column oc
    JOIN
        oceanbase.__all_virtual_data_type vdt
    ON
        oc.data_type = vdt.data_type
    WHERE
        oc.rowkey_position != 0
        AND oc.table_id = (SELECT table_id FROM oceanbase.__all_table WHERE table_name = @table_name)
) AS result_table;

-- 計算結果は8バイト
```

tab IVF

テーブル作成時のインデックス作成構文：

```sql
CREATE TABLE table_name (
    column_name1 data_type1,
    column_name2 data_type2,
    ...,
    VECTOR INDEX index_name (column_name) WITH (param1=value1, param2=value2, ...)
);
```

インデックスの後付け構文：

```sql
-- インデックスを後から追加する場合、並列度を設定することでインデックス構築のパフォーマンスを向上させることができます。並列度の最大設定値はCPUコア数 * 2を超えません。
CREATE [/*+ paralell $value*/] VECTOR INDEX index_name ON table_name(column_name) WITH (param1=value1, param2=value2, ...);
```

`param`パラメータの説明：

| パラメータ | デフォルト値 | 値の範囲 | 必須 | 説明 | 備考 |
|------|--------|----------|----------|------|------|
| distance | | l2/inner_product/cosine | はい | ベクトル距離アルゴリズムのタイプを指定します。 | l2はユークリッド距離、inner_productは内積距離、cosineはコサイン距離を表します。 |
| type | | ivf_flat/ivf_sq8/ivf_pq | はい | IVFインデックスのタイプを指定します。 | |
| lib | ob | ob | いいえ | ベクトルインデックスライブラリのタイプを指定します。 | |
| nlist | 128 | [1,65536] | いいえ | クラスタ中心の数。 | <ul>V4.3.5 BP5バージョンの場合：<li>データ量が100万件未満の場合、推奨値は `データ量/1000` です。</li><li>データ量が100万件を超える場合、推奨値は `sqrt(データ量)` です。</li>マルチパーティション表の場合、`データ量`は最大パーティションのデータ量に基づいて見積もります。</ul> |
| sample\_per\_nlist | 256 | [1,int64_max] | はい | 各クラスタ中心からサンプリングするデータ量で、インデックスを後付けする際に使用されます。 | V4.3.5 BP5バージョンでは、デフォルト値を維持することを推奨します。変更は推奨しません。|
| nbits | 8 | [1,24] | いいえ | 量子化ビット数を指定します。<main id="notice" type='notice'><h4>注意</h4><p>このパラメータはV4.3.5 BP3バージョンからサポートされており、IVF_PQインデックスの作成時にのみ指定できます。</p></main> | 推奨値は8で、推奨範囲は[8,10]です。この値が大きいほど、量子化の精度が高まり、検索の正解率も向上しますが、同時に検索性能に影響が出ます。 |
| m | デフォルト値なし、指定必須 | [1,65536] | はい | 量子化後のベクトル次元数を指定します。<main id="notice" type='notice'><h4>注意</h4><p>このパラメータはV4.3.5 BP3バージョンからサポートされており、IVF_PQインデックスの作成時にのみ指定できます。</p></main> | この値が大きいほど、インデックスの構築は遅くなり、検索の正解率も向上しますが、同時に検索性能に影響が出ます。 |

**IVF/IVF_PQインデックス（V4.3.5 BP5バージョンのみ適用）**に関する補足事項：

* インデックスの制限：
  * ヒープテーブルとパーティションテーブルを組み合わせた構成では、IVF/IVF_PQインデックスの作成はサポートされていません。
* 作成時の推奨事項：
  * データのインポートが完了した後に、IVF/IVF_PQインデックスを作成することを強く推奨します。テーブル作成と同時にIVFインデックスを作成することは推奨されません。データが存在しない状態で作成すると、インデックスのクラスタリングが行えず、利用不可となるためです。この状態になった場合、手動で `REBUILD INDEX` を実行するか、`DROP` してから再度 `CREATE INDEX` を実行する必要があります。
  * インデックスを作成する前に、本記事の「ベクトルインデックス作成のメモリ見積もり」セクションを参照し、メモリ使用量の見積もりと確認を行うことを推奨します。これにより、作成プロセスにおけるメモリ不足の発生を回避できます。
  * インデックスを作成する前に、`ALTER SYSTEM major freeze` を実行し、メジャーコンパクションが完了するまで待機することを推奨します。
  * マルチノードクラスタ構成の場合、SYSテナントのメモリを1GB以上に設定することを推奨します。
  * インデックスを作成する前に、[parallel_servers_target](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001972258) パラメータの値を、テナントの `max_cpu * 10` に設定することを推奨します。
  * 単一パーティションのデータ量が1,000万件を超え、かつテナントのCPUリソースが10コアを超える環境では、インデックスを作成する前に `ALTER SYSTEM SET _px_object_sampling = 5000` を実行してサンプリング比率を変更することを推奨します。これにより、インデックス構築の効率を向上させることができます。

:::

## 検索構文と説明

ベクトルインデックス検索は、一種の近似近傍検索であり、100%の正解を保証するものではありません。これに対応するベクトル検索の正解率の指標がリコール率です。例えば、10個の最近傍を検索する際に、安定して9個の正しい結果が返される場合、リコール率は90%となります。リコール率の説明は以下の通りです：

* リコール率は、インデックス構築時のパラメータと検索時のパラメータに影響されます。
* 検索パラメータはインデックス作成時に指定し、その後は変更できません。ただし、session変数を通じて設定することができます：HNSW/HNSW_SQインデックスは `ob_hnsw_ef_search` を通じて、IVF/IVF_SQ/IVF_PQインデックスは `ob_ivf_nprobes` を通じて設定されます。session変数が設定されている場合には、その値が優先的に使用されます。具体的な設定方法については、[ob_hnsw_ef_search](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001976680)および [ob_ivf_nprobes](https://en.oceanbase.com/docs/common-oceanbase-database-10000000002179539)を参照してください。

密ベクトルインデックスの検索構文は以下の通りです。

```sql
SELECT ... FROM $table_name ORDER BY $distance_function($column_name, $vector_expr) [APPROXIMATE|APPROX] LIMIT $num (OFFSET $num) [PARAMETERS ($param1=$value1, ...)];
```

検索の使用説明は以下の通りです。

* 検索構文の要件：
  * `APPROXIMATE`/`APPROX`キーワードを必ず指定してください。これにより、テーブルフルスキャンではなくベクトルインデックスが検索に使用されます。
  * `ORDER BY`と`LIMIT`句を必ず含める必要があります。
  * `ORDER BY`句は、単一のベクトル条件のみをサポートします。
  * `LIMIT + OFFSET`の値の範囲は、`(0, 16384]`です。
  * `PARAMETERS`句は、検索パラメータを指定するために使用します。IVF/IVF_PQインデックスでは、`nprobes`パラメータがサポートされています（例：`PARAMETERS(nprobes=200)`）。このパラメータはV4.3.5 BP5バージョン以降でサポートされており、検索時に対象とするクラスタ中心の数を指定するために使用します。

* 距離関数の使用ルール：
  * `APPROXIMATE`/`APPROX`を指定し、現在のバージョンでサポートされている距離関数がベクトルインデックスのアルゴリズムと一致する場合、検索にベクトルインデックスが使用されます。
  * `APPROXIMATE`/`APPROX`を指定しても、距離関数がベクトルインデックスのアルゴリズムと一致しない場合、検索にベクトルインデックスは使用されませんが、エラーは発生しません。
  * `APPROXIMATE`/`APPROX`を指定した際に、現在のバージョンでサポートされていない距離関数を使用すると、検索にベクトルインデックスは使用されず、エラーが発生します。
  * `APPROXIMATE`/`APPROX`を指定しない場合、現在のバージョンでサポートされている距離関数を使用しても、検索にベクトルインデックスは使用されず、エラーも発生しません。

<main id="notice" type='notice'>
  <h4>注意</h4>
  <p>V4.3.5 BP5バージョン以降、<code>PARAMETERS(similarity=$value)</code>句を使用して、類似度のしきい値を指定した検索がサポートされています。</p>
</main>

* 類似度のしきい値パラメータ（`similarity`）：
  * 構文：`LIMIT` 句の後に `PARAMETERS (similarity=$value)` を追加します。ここで `$value` は類似度の閾値です（値の範囲は `[0, 1]`）。通常、類似度の値が大きいほど類似性が高いことを示し、距離は小さくなります。ただし、`inner_product` は例外であり、距離が大きいほど類似性が高くなります。
  * 機能：類似度の閾値を指定すると、類似度がその閾値以上である結果のみが返されます。
  * サポートされるインデックスの種類：HNSW、HNSW_SQ、HNSW_BQ、IVF、IVF_PQ。
  * サポートされる距離タイプ：
    * クエリ実行時、距離タイプが `cosine_distance` および `l2_distance` のインデックスに対して類似度を指定できます。`l2_distance` の場合、ベクトルに対してL2正規化を行うことを推奨します。これにより、類似度検索の精度向上が期待できます。ベクトルの正規化に関する説明と例については、[SQL関数の使用 - ベクトル正規化](250.ob-vector-function.md)を参照してください。
    * 距離タイプが `inner_product` のインデックスでは、クエリ実行時の類似度指定はサポートされていません（`not support` エラーが発生します）。
  * 類似度と距離の対応関係：
    * `cosine_distance`=`2 - 2 * similarity`
    * `l2_distance`=`sqrt(1 / similarity -1)`

* その他の説明：
  * `WHERE`条件は、ベクトルインデックス検索後のフィルタ条件として機能します。
  * `LIMIT`句を指定しないとエラーが発生します。

* IVF/IVF_PQインデックス検索の最適化に関するアドバイス（**V4.3.5 BP5 バージョンのみ適用**）：
  * テーブル作成時にメインテーブルに対して `ROW_FORMAT=COMPRESSED` を設定し、行圧縮フォーマットを有効にすると、IVFベクトルインデックスの検索性能を 20〜30% 向上させることができます。例：
    ```sql
    CREATE TABLE t1 (c1 INT PRIMARY KEY, c2 VECTOR(4)) ROW_FORMAT=COMPRESSED;
    ```
  * 並列検索の有効化は推奨しません。有効にした場合、検索性能への悪影響や、結果が不正確になる可能性があります。

## インデックスの作成、検索および削除の例

### テーブル作成時におけるインデックスの作成

#### 密ベクトルインデックスの例

##### HNSWインデックスの例

<main id="notice" type='notice'>
  <h4>注意</h4>
  <p>HNSWインデックスを作成する際、インデックス名の長さが25文字を超えるものについては今のところサポートされていません。インデックスの補助テーブル名超過 <code>index_name</code> 制限により異常が起きることになります。将来のバーションではより長いインデックス名がサポートされるようになります。</p>
</main>

テストテーブルを作成します。

```sql
CREATE TABLE t1(c1 INT, c0 INT, c2 VECTOR(10), c3 VECTOR(10), PRIMARY KEY(c1), VECTOR INDEX idx1(c2) WITH (distance=l2, type=hnsw, lib=vsag),  VECTOR INDEX idx2(c3) WITH (distance=l2, type=hnsw, lib=vsag));
```

テストデータを挿入します。

```sql
INSERT INTO t1 VALUES(1, 1,'[0.203846,0.205289,0.880265,0.824340,0.615737,0.496899,0.983632,0.865571,0.248373,0.542833]', '[0.203846,0.205289,0.880265,0.824340,0.615737,0.496899,0.983632,0.865571,0.248373,0.542833]');

INSERT INTO t1 VALUES(2, 2, '[0.735541,0.670776,0.903237,0.447223,0.232028,0.659316,0.765661,0.226980,0.579658,0.933939]', '[0.213846,0.205289,0.880265,0.824340,0.615737,0.496899,0.983632,0.865571,0.248373,0.542833]');

INSERT INTO t1 VALUES(3, 3, '[0.327936,0.048756,0.084670,0.389642,0.970982,0.370915,0.181664,0.940780,0.013905,0.628127]', '[0.223846,0.205289,0.880265,0.824340,0.615737,0.496899,0.983632,0.865571,0.248373,0.542833]');
```

近似最近傍探索を実行します。

```sql
SELECT * FROM t1 ORDER BY l2_distance(c2, [0.712338,0.603321,0.133444,0.428146,0.876387,0.763293,0.408760,0.765300,0.560072,0.900498]) APPROXIMATE LIMIT 1;
```

結果は次のとおりです：

```shell
+----+------+-------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------+
| c1 | c0   | c2                                                                                        | c3                                                                                         |
+----+------+-------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------+
|  3 |    3 | [0.327936,0.048756,0.08467,0.389642,0.970982,0.370915,0.181664,0.94078,0.013905,0.628127] | [0.223846,0.205289,0.880265,0.82434,0.615737,0.496899,0.983632,0.865571,0.248373,0.542833] |
+----+------+-------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------+
1 row in set
```

##### HNSW_SQインデックスの例

```sql
CREATE TABLE t2 (c1 INT AUTO_INCREMENT, c2 VECTOR(3), PRIMARY KEY(c1), VECTOR INDEX idx1(c2) WITH (distance=l2, type=hnsw_sq, lib=vsag));
```

##### HNSW_BQの例

```sql
CREATE TABLE t3 (c1 INT AUTO_INCREMENT, c2 VECTOR(3), PRIMARY KEY(c1), VECTOR INDEX idx3(c2) WITH (distance=l2, type=hnsw_bq, lib=vsag));
```

HNSW_BQでは、`distance`パラメータはl2のみサポートします。

##### IVFの例

<main id="notice" type='notice'>
  <h4>注意</h4>
  <p>IVFインデックスを作成する際、インデックス名の長さが33文字を超えるとサポートされなくなります。インデックス補助テーブル名超過 <code>index_name</code> 制限により異常が発生します。将来のバーションではより長いインデックス名がサポートされるようになります。</p>
</main>

```sql
CREATE TABLE ivf_vecindex_suite_table_test (c1 INT, c2 VECTOR(3), PRIMARY KEY(c1), VECTOR INDEX idx2(c2) WITH (distance=l2, type=ivf_flat));
```

### 後から作成されるインデックス

<main id="notice" type='notice'>
  <h4>注意</h4>
  <p>現時点では、密ベクトルインデックスを後から作成することのみをサポートしています。</p>
</main>

#### HNSWインデックスの例

テストテーブルを作成します。

```sql
CREATE TABLE vec_table_hnsw (id INT, c2 VECTOR(10));
```

HNSWインデックスを作成する。

```sql
CREATE VECTOR INDEX vec_idx1 ON vec_table_hnsw(c2) WITH (distance=l2, type=hnsw);
```

作成したテーブルを確認する。

```sql
SHOW CREATE TABLE vec_table_hnsw;
```

返される結果は次のとおりです：

```shell
+-----------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Table     | Create Table                                                                                                                                                                                                                                                                                                                                                                                         |
+-----------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| vec_table_hnsw | CREATE TABLE `vec_table_hnsw` (
  `id` int(11) DEFAULT NULL,
  `c2` VECTOR(10) DEFAULT NULL,
  VECTOR KEY `vec_idx1` (`c2`) WITH (DISTANCE=L2, TYPE=HNSW, LIB=VSAG, M=16, EF_CONSTRUCTION=200, EF_SEARCH=64) BLOCK_SIZE 16384
) DEFAULT CHARSET = utf8mb4 ROW_FORMAT = DYNAMIC COMPRESSION = 'zstd_1.3.8' REPLICA_NUM = 2 BLOCK_SIZE = 16384 USE_BLOOM_FILTER = FALSE TABLET_SIZE = 134217728 PCTFREE = 0 |
+-----------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set

OceanBase(root@oceanbase)>SHOW INDEX FROM vec_table_hnsw;
+-----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+-----------+---------------+---------+------------+
| Table     | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment   | Index_comment | Visible | Expression |
+-----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+-----------+---------------+---------+------------+
| vec_table |          1 | vec_idx1 |            1 | c2          | A         |        NULL | NULL     | NULL   | YES  | VECTOR     | available |               | YES     | NULL       |
+-----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+-----------+---------------+---------+------------+
1 row in set
```

#### HNSW_SQインデックスの例

テストテーブルを作成します。

```sql
CREATE TABLE vec_table_hnsw_sq (c1 INT AUTO_INCREMENT, c2 VECTOR(3), PRIMARY KEY(c1));
```

HNSW_SQインデックスを作成します。

```sql
CREATE VECTOR INDEX vec_idx2 ON vec_table_hnsw_sq(c2) WITH (distance=l2, type=hnsw_sq, lib=vsag, m=16, ef_construction = 200);
```

##### HNSW_BQインデックスの例

```sql
CREATE VECTOR INDEX vec_idx3 ON vec_table_hnsw_bq(c2) WITH (distance=l2, type=hnsw_bq, lib=vsag, m=16, ef_construction = 200);
```

HNSW_BQインデックスでは、`distance`パラメータはl2のみをサポートします。

#### IVFインデックスの例

テストテーブルを作成します。

```sql
CREATE TABLE vec_table_ivf (c1 INT, c2 VECTOR(3), PRIMARY KEY(c1));
```

IVFインデックスを作成します。

```sql
CREATE VECTOR INDEX vec_idx3 ON vec_table_ivf(c2) WITH (distance=l2, type=ivf_flat);
```

### 削除

ベクトルインデックスを削除する構文は以下のとおりです。

```sql
DROP INDEX vec_idx1 ON vec_table;
```

結果を確認します。

```sql
SHOW INDEX FROM vec_table;
```

結果は次のとおりです：

```shell
Empty set
```

## メンテナンス

増分データが多すぎる場合、検索性能が低下します。増分データテーブルのデータ量を抑えるために、OceanBaseではベクトルインデックスを管理するための`DBMS_VECTOR`が導入されています。

### 増分リフレッシュ

<main id="notice" type='notice'>
  <h4>注意</h4>
  <p>IVF/IVF_SQ/IVF_PQインデックスには増分リフレッシュメカニズムがありません。</p>
</main>

インデックス作成後の入力データが多い場合には、`REFRESH_INDEX`プロシージャで増分リフレッシュすることを推奨します。詳細については、[REFRESH_INDEX](https://en.oceanbase.com/docs/common-oceanbase-database-10000000002753999)を参照してください。

15分ごとに増分データの件数がチェックされ、1万件を超えている場合に増分リフレッシュが自動で実行されます。

### フルリフレッシュ（再構築）

#### 手動による全テーブル再構築

インデックス作成後の更新または削除データが多い場合には、`REBUILD_INDEX`プロシージャを使用してインデックスを完全に再構築することを推奨します。詳細は[REBUILD_INDEX](https://en.oceanbase.com/docs/common-oceanbase-database-10000000002754000)を参照してください。

24時間ごとにフルリフレッシュの実行条件がチェックされ、新規データが既存データの20%を超えている場合に自動で実行されます。フルリフレッシュはバックグラウンドで非同期に実行され、まず新しいインデックスを作成した後に、古いインデックスと置き換えます。この再構築のプロセス中も古いインデックスは利用可能な状態が維持されますが、処理全体には比較的長い時間がかかります。

また、`vector_index_memory_saving_mode`構成パラメータを使用して、インデックス再構築時のメモリ使用量を制御することもできます。このモードを有効にすると、パーティションテーブルのベクトルインデックス再構築（rebuild）プロセスにおけるメモリ消費を削減できます。通常、ベクトルインデックスの再構築には、インデックスの2倍のメモリが必要です。メモリ節約モードを有効にすると、システムはパーティションテーブルの単一パーティションを構築した後に、そのパーティションのメモリインデックスを一時的に削除することでメモリを解放し、再構築操作に必要な総メモリを効果的に削減します。構文と例については、`vector_index_memory_saving_mode`のページを参照してください。

注意事項は以下のとおりです：

* [オフラインDDL](https://en.oceanbase.com/docs/common-oceanbase-database-10000000001974221)操作（例：`ALTER TABLE`によるテーブル構造や主キーの変更）を実行すると、インデックスが再構築されます。インデックスの再構築では並列度を指定できず、システムはデフォルトでシングルスレッドを使用します。そのため、データ量が大きい場合、再構築処理に時間がかかり、オフラインDDL全体の実行効率に影響を与えることがあります。
* インデックスの再構築時にインデックスパラメータを変更する場合、パラメータリストで`type`と`distance`を同時に指定する必要があり、これらは元のインデックスと一致している必要があります。例えば、元のインデックスタイプが`hnsw`で距離計算アルゴリズムが`l2`の場合、再構築時も`type=hnsw`と`distance=l2`を同時に指定しなければなりません。
* インデックス再構築でサポートされている操作：
    * `m`、`ef_search`、`ef_construction`の値を変更すること。
    * V4.3.5 BP5バージョンのIVF/IVF_PQでは、`nlist`、`sample_per_nlist`、`distance`、`nbits`、`m`の値を変更可能です。なお、`m`と`nbits`はIVF_PQインデックス固有のパラメータとなります。
    * `ef_search`パラメータをオンラインで再構築すること。
    * `hnsw`<->`hnsw_sq`間でのインデックスタイプの再構築。
    * `ivf_flat`同士、`ivf_sq8`同士、`ivf_pq`同士でのインデックスの再構築。
    * 再構築時に並列度を設定すること。使用例については [REBUILD_INDEX](https://en.oceanbase.com/docs/common-oceanbase-database-10000000002754000)をご参照ください。
* インデックス再構築でサポートされていない操作：
    * `type`と`distance`を変更すること。
    * `hnsw`<->`ivf`間でのインデックスの再構築。
    * `hnsw`<->`hnsw_bq`間でのインデックスの再構築。
    * `ivf_flat`、`ivf_pq`、`ivf_sq8`間での相互の再構築。
* IVF/IVF_PQインデックス再構築に関する推奨事項（V4.3.5 BP5バージョンのみ適用）：
    * `REBUILD INDEX` を実行する前に、タイムアウトの発生を回避するため、`ob_trx_timeout` パラメータの値を、インデックスの再構築（rebuild）にかかる時間よりも大きく設定することを推奨します。

#### 自動パーティション再構築（推奨）

<main id="notice" type='notice'>
  <h4>注意</h4>
  <p><li>この機能はV4.3.5 BP3バージョンからサポートされています。ベクトルクラスタが旧バージョンからV4.3.5 BP3にアップグレードされた場合、アップグレード後は手動で全テーブルのベクトルインデックスを再構築する必要があります。そうでない場合、アップグレード後はパーティション再構築タスクが自動的に実行されない可能性があります。</li><li>現在のバージョンでは、HNSW/HNSW_SQ/HNSW_BQインデックスタイプのみサポートされています。</li></p>
</main>

現在のバージョンでは、自動パーティション再構築タスクがトリガーされる状況は2つあります：

* ベクトルインデックス検索ステートメントを実行するとき。
* 定期的なチェック。実行周期を手動で設定できます。

1. 実行周期の設定

    `oceanbase`データベースで、vector_index_optimize_duty_time構成パラメータで実行周期を設定します。例は以下のとおりです：

    ```sql
    ALTER SYSTEM SET vector_index_optimize_duty_time='[23:00:00, 24:00:00]';
    ```

    上記の設定を完了すると、パーティション再構築タスクは23:00:00～24:00:00の時間帯にのみ実行され、その他の時間帯では実行されません。詳細なパラメータの説明については、対応する構成パラメータのドキュメントを参照してください。

2. タスクの進捗状況や履歴タスクの確認

    CDB/DBA_OB_VECTOR_INDEX_TASKSまたはCDB/DBA_OB_VECTOR_INDEX_TASK_HISTORYビューを使用して、タスクの進捗状況や履歴タスクを確認できます。

    `status`フィールドでタスクの現在の状態を判断します：

    * 0（PREPARE）：タスクが実行を待機しています。
    * 1（RUNNING）：タスクが実行中です。
    * 2（PENDING）：タスクが一時停止されています。
    * 3（FINISHED）：タスクが完了しました。
    実行が終了したタスク、つまり`status=FINISHED`のタスクは、成功したかどうかにかかわらず、履歴テーブルに移されます。詳細な使用例については、対応するビューのドキュメントを参照してください。

3. タスクのキャンセル

    タスクをキャンセルするには、`DBA_OB_VECTOR_INDEX_TASKS`または`CDB_OB_VECTOR_INDEX_TASKS`ビューからtrace_idを取得した後、次のコマンドを実行します：

    ```sql
    ALTER SYSTEM CANCEL TASK <trace_id>;
    ```

    例は以下のとおりです：

    ```sql
    ALTER SYSTEM CANCEL TASK "Y61480BA2D976-00063084E80435E2-0-1";
    ```

## パフォーマンス最適化

<main id="notice" type='notice'>
  <h4>注意</h4>
  <p>この機能はV4.3.5 BP3からサポートされており、現在はIVFインデックスのみ対応しています。</p>
</main>

OceanBaseのベクトル検索は、IVFインデックスに対して自動的なパフォーマンス最適化メカニズムを提供しており、キャッシュ管理と定期的なメンテナンスを通じて検索性能を向上させます。

### 最適化の仕組み

IVFインデックスのパフォーマンスを最適化するには、主に2種類の自動化タスクが利用できます：

1. キャッシュのウォームアップタスク：定期的にすべてのIVFインデックスをチェックし、インデックスに対応するキャッシュが存在しない場合は、自動的にキャッシュのウォームアップを実行してインデックスデータをメモリにロードします。また、IVFインデックスの作成時にも、キャッシュは自動的にウォームアップされます。
2. キャッシュのクリーンアップタスク：定期的にすべてのIVFキャッシュをチェックし、キャッシュに対応するインデックスが削除されている場合は、自動的に無効なキャッシュをクリーンアップしてメモリリソースを解放します。また、IVFインデックスの削除時にも、キャッシュは自動的にクリーンアップされます。

### 最適化実行サイクルの設定

業務のピークタイムにパフォーマンスへの影響が出るのを避けるため、システムはパフォーマンス最適化タスクの実行時間帯をカスタマイズできます。

oceanbaseデータベースで、構成パラメータ`vector_index_optimize_duty_time`を使用して実行サイクルを設定します。

```sql
ALTER SYSTEM SET vector_index_optimize_duty_time='[23:00:00, 24:00:00]';
```

設定の詳細は以下の通りです:

* 時間は`[開始時間, 終了時間]`の形式で指定します。
* 上記の設定は、23:00:00から24:00:00の時間帯にのみ最適化タスクを実行することを示します。
* 他の時間帯では最適化タスクは実行されないため、通常の業務への影響を避けることができます。

### 最適化タスクの監視

1. 現在のタスク状態を確認する

    `DBA_OB_VECTOR_INDEX_TASKS`ビューを使用することで、実行中または待機中のタスクを確認できます：

    ```sql
    -- MySQLテナントでクエリを実行する必要があります
    SELECT * FROM oceanbase.DBA_OB_VECTOR_INDEX_TASKS;
    ```

    結果の例：

    ```shell
    +----------+---------------------+---------+----------------------------+----------------------------+--------------+----------+-----------+------------------+----------+------------------------------------+
    | TABLE_ID | TABLET_ID           | TASK_ID | START_TIME                 | MODIFY_TIME                | TRIGGER_TYPE | STATUS   | TASK_TYPE | TASK_SCN         | RET_CODE | TRACE_ID                           |
    +----------+---------------------+---------+----------------------------+----------------------------+--------------+----------+-----------+------------------+----------+------------------------------------+
    |   500020 | 1152921504606846990 | 2002281 | 1970-08-23 17:10:23.174127 | 1970-08-23 17:10:23.174137 | USER         | FINISHED |         2 | 1750671687770026 |        0 | YAFF00B9E4D97-00063839E6BD9BBC-0-1 |
    +----------+---------------------+---------+----------------------------+----------------------------+--------------+----------+-----------+------------------+----------+------------------------------------+
    1 row in set
    ```

    任务状态说明：

    * `STATUS = 0`: PREPARE - タスクは実行待機中です。
    * `STATUS = 1`: RUNNING - タスクは実行中です。
    * `STATUS = 3`: FINISHED - タスクは完了しました。

    タスクタイプの説明：

    * `TASK_TYPE = 2`: IVFキャッシュのウォームアップタスク
    * `TASK_TYPE = 3`: 無効になったIVFキャッシュのクリーンアップタスク

2. 過去のタスク履歴を確認する

    完了したタスク（`STATUS = 3`）は、成功したかどうかにかかわらず、10秒ごとに自動的に履歴テーブルへ転送されます。`DBA_OB_VECTOR_INDEX_TASKS_HISTORY`ビューを使用して、過去の履歴を確認できます。

    ```sql
    -- 指定したタスクIDの履歴を照会する
    SELECT * FROM oceanbase.DBA_OB_VECTOR_INDEX_TASKS_HISTORY WHERE TASK_ID=2002281;
    ```

    結果の例：

    ```shell
    +----------+---------------------+---------+----------------------------+----------------------------+--------------+----------+-----------+------------------+----------+------------------------------------+
    | TABLE_ID | TABLET_ID           | TASK_ID | START_TIME                 | MODIFY_TIME                | TRIGGER_TYPE | STATUS   | TASK_TYPE | TASK_SCN         | RET_CODE | TRACE_ID                           |
    +----------+---------------------+---------+----------------------------+----------------------------+--------------+----------+-----------+------------------+----------+------------------------------------+
    |   500020 | 1152921504606846990 | 2002281 | 1970-08-23 17:10:23.174127 | 1970-08-23 17:10:23.174137 | AUTO         | FINISHED |         2 | 1750671687770026 |        0 | YAFF00B9E4D97-00063839E6BD9BBC-0-1 |
    +----------+---------------------+---------+----------------------------+----------------------------+--------------+----------+-----------+------------------+----------+------------------------------------+
    1 row in set
    ```

### 最適化タスクのキャンセル

以下のコマンドで指定したタスクをキャンセルできます。

```sql
-- trace_idは上記のDBA_OB_VECTOR_INDEX_TASKS_HISTORYビューから取得します
ALTER SYSTEM CANCEL TASK <trace_id>;
```

<main id="notice" type='notice'>
  <h4>注意</h4>
  <p>タスクのキャンセルは、タスクが失敗しリトライしている段階で、かつ<code>ALTER SYSTEM CANCEL TASK</code>コマンドを実行した場合にのみ可能です。バックグラウンドタスクが特定の実行段階で停止してしまった場合、このコマンドでタスクをキャンセルすることはできません。</p>
</main>

実行例：

```sql
-- SYSシステムテナントにログインし、指定したタスクのtrace_idを取得します
SELECT * FROM oceanbase.DBA_OB_VECTOR_INDEX_TASK_HISTORY WHERE TASK_ID=2037736;
+----------+---------------------+---------+----------------------------+----------------------------+--------------+----------+-----------+------------------+----------+------------------------------------+
| TABLE_ID | TABLET_ID           | TASK_ID | START_TIME                 | MODIFY_TIME                | TRIGGER_TYPE | STATUS   | TASK_TYPE | TASK_SCN         | RET_CODE | TRACE_ID                           |
+----------+---------------------+---------+----------------------------+----------------------------+--------------+----------+-----------+------------------+----------+------------------------------------+
|   500041 | 1152921504606847008 | 2037736 | 1970-08-23 17:10:23.203821 | 1970-08-23 17:10:23.203821 | USER         | PREPARED |         2 | 1750682301145225 |       -1 | YAFF00B9E4D97-00063839E6BDDEE0-0-1 |
+----------+---------------------+---------+----------------------------+----------------------------+--------------+----------+-----------+------------------+----------+------------------------------------+
1 row in set
```

```sql
-- タスクをキャンセルします
ALTER SYSTEM CANCEL TASK "YAFF00B9E4D97-00063839E6BDDEE0-0-1";
```

タスクをキャンセルすると、タスクのステータスは`CANCELLED`に変わります。

```sql
-- ユーザーテナントにログインし、タスクのステータスを照会します
SELECT * FROM oceanbase.DBA_OB_VECTOR_INDEX_TASK_HISTORY;
+----------+---------------------+---------+----------------------------+----------------------------+--------------+----------+-----------+------------------+----------+------------------------------------+
| TABLE_ID | TABLET_ID           | TASK_ID | START_TIME                 | MODIFY_TIME                | TRIGGER_TYPE | STATUS   | TASK_TYPE | TASK_SCN         | RET_CODE | TRACE_ID                           |
+----------+---------------------+---------+----------------------------+----------------------------+--------------+----------+-----------+------------------+----------+------------------------------------+
|   500041 | 1152921504606847008 | 2037736 | 1970-08-23 17:10:23.203821 | 1970-08-23 17:10:23.203821 | USER         | FINISHED |         2 | 1750682301145225 |    -4072 | YAFF00B9E4D97-00063839E6BDDEE0-0-1 |
+----------+---------------------+---------+----------------------------+----------------------------+--------------+----------+-----------+------------------+----------+------------------------------------+
1 row in set
```

## 関連ドキュメント

* [SQL関数の使用](250.ob-vector-function.md)
