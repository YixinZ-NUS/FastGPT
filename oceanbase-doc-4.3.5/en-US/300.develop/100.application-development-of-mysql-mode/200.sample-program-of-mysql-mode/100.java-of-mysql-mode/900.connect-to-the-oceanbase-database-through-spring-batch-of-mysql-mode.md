|description||
|---|---|
|keywords||
|dir-name|SpringBatch|
|dir-name-en| Spring Batch |
|tenant-type|MySQL Mode|

# Connect to OceanBase Database by using Spring Batch

This topic describes how to build an application using the Spring Batch framework and OceanBase Database. It also covers the use of the application for fundamental database operations, including table creation, data insertion, and data query.

<div role="videolist">
      <a role='link' href='https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer/V4.3.0/%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91demo/springbatch-mysql.zip'>
          <img src='https://file.oceanbase.com/doc/img/lQLPJyFovGIOcJQWFrAqhLlgRRsPvwU-H7hJ_i0A_22_22.png'/>
          Download the java-oceanbase-springbatch sample project
      </a>
</div>

## Prerequisites

* You have installed OceanBase Database.
* You have installed Java Development Kit (JDK) 1.8 and Maven.
* You have installed IntelliJ IDEA.

<main id="notice" type='explain'>
  <h4>Note</h4>
  <p>In this topic, IntelliJ IDEA Community Edition 2021.3.2 is used to run the sample code. You can also choose a suitable tool as needed. </p>
</main>

## Procedure

<main id="notice" type='explain'>
  <h4>Note</h4>
  <p>The following procedure applies to Windows. If you use another operating system or compiler, the procedure can be slightly different. </p>
</main>

1. Obtain the OceanBase Database connection string.
2. Import the `java-oceanbase-springbatch` project to IntelliJ IDEA.
3. Modify the database connection information in the `java-oceanbase-springbatch` project.
4. Run the `java-oceanbase-springbatch` project.

### Step 1: Obtain the OceanBase Database connection string

1. Contact the deployment personnel or administrator of OceanBase Database to obtain the connection string.

    ```shell
    obclient -hxx.xx.xx.xx -P2883 -uroot@sys#cluster -p**** -A
    ```

2. Enter the URL of OceanBase Database.

    <main id="notice" type='explain'>
    <h4>Note</h4>
    <p>The URL of OceanBase Database is required in the <code>application.properties</code> file. </p>
    </main>

    ```java
    jdbc:oceanbase://host:port/schema_name?user=$user_name&password=$password&characterEncoding=utf-8
    ```

    **The parameters are described as follows:**

    * `host`: the IP address for connecting to OceanBase Database, which is the IP address of OceanBase Database Proxy (ODP) for connection through ODP, or the IP address of an OBServer node for direct connection.
    * `port`: the port for connecting to OceanBase Database. For connection through ODP, the default value is `2883`, which can be customized when ODP is deployed. For direct connection, the default value is `2881`, which can be customized when OceanBase Database is deployed.
    * `schema_name`: the name of the schema to be accessed.
    * `user_name`: the username of the account in the format of **user@tenant#cluster name** or **username@SERVICE:service name**, which is specified by the `-u` parameter. When the value is in the **user@tenant#cluster name** format, the default tenant is `sys` and the default administrator is `root`. The cluster name is not required when you directly connect to OceanBase Database, but is required when you connect to OceanBase Database through ODP.
    * `password`: the password of the account.
    * `characterEncoding`: the character encoding format.

For more information about URL parameters, see [Database URL](https://en.oceanbase.com/docs/common-oceanbase-connector-j-en-10000000000911660).

### Step 2: Import the `java-oceanbase-springbatch` project to IntelliJ IDEA

1. Start **IntelliJ IDEA** and choose **File** > **Open...**.

   ![file](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/demo/java/mybatis/file.jpg)

2. In the **Open File or Project** window, select the project files and click **OK** to import the files.

3. IntelliJ IDEA automatically identifies various files in the project. You can view project information such as the directory structure, file list, module list, and dependencies in the **Project** window. Generally, the **Project** window is at the leftmost of the UI of IntelliJ IDEA and is opened by default. If the **Project** window is closed, you can choose **View** > **Tool Windows** > **Project** in the menu bar or press **Alt + 1** to open it.

    <main id="notice" type='explain'>
    <h4>Note</h4>
    <p>When you use IntelliJ IDEA to import a project, IntelliJ IDEA automatically detects the <code>pom.xml</code> file in the project, downloads the required dependency libraries based on the dependencies described in the file, and adds them to the project. </p>
    </main>

4. View the project.

  ![springbatch](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/demo/java/java-oceanbase-springbatch/springbatch.jpg)

### Step 3: Modify the database connection information in the `java-oceanbase-springbatch` project

Modify the database connection string in the `application.properties` file based on the information obtained in **Step 1: Obtain the OceanBase Database connection string**.

**Here is a connection information example:**

* The name of the database driver is `com.mysql.cj.jdbc.Driver`.
* The IP address of the OBServer node is `10.10.10.1`.
* The access port is 2881.
* The name of the schema to be accessed is `test`.
* The tenant account is `root@mysql001`. `mysql001` is a MySQL user tenant created in OceanBase Database, and `root` is the username of a user in the `mysql001` tenant.
* The password is `******`.

**Here is the sample code:**

```java
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:oceanbase://10.10.10.1:2881/test?characterEncoding=utf-8
spring.datasource.username=root@mysql001
spring.datasource.password=******

spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=update

spring.batch.job.enabled=false

logging.level.org.springframework=INFO
logging.level.com.example=DEBUG
```

### Step 4: Run the `java-oceanbase-springbatch` project

* Run the `AddDescPeopleWriterTest.java` file.

    1. Find the `AddDescPeopleWriterTest.java` file under **src** > **test** > **java** in the project package.
    2. Choose **Run** > **Run...** > **AddDescPeopleWriterTest.testWrite** in the menu bar or click the green triangle in the upper-right corner to run the file.
    3. View the logs and output of the project in the **Console** window of IDEA.

    ```java
    Data in the people_desc table:
    PeopleDESC [name=John, age=25, desc=This is John with age 25]
    PeopleDESC [name=Alice, age=30, desc=This is Alice with age 30]
    Batch Job execution completed.
    ```

* Run the `AddPeopleWriterTest.java` file.

    1. Find the `AddDescPeopleWriterTest.java` file under **src** > **test** > **java** in the project package.
    2. Choose **Run** > **Run...** > **AddPeopleWriterTest.testWrite** in the menu bar or click the green triangle in the upper-right corner to run the file.
    3. View the logs and output of the project in the **Console** window of IDEA.

    ```java
    Data in the people table:
    People [name=zhangsan, age=27]
    People [name=lisi, age=35]
    Batch Job execution completed.
    ```

## Project code

Click [here](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.0/3.develop/demo/java/java-oceanbase-springbatch/java-oceanbase-springbatch.zip) to download the project code, which is a package named `java-oceanbase-springbatch`.

Decompress the package to obtain a folder named `java-oceanbase-springbatch`. The directory structure is as follows:

```java
│  pom.xml
│
├─.idea
│
├─src
│  ├─main
│  │  ├─java
│  │  │  └─com
│  │  │      └─oceanbase
│  │  │          └─example
│  │  │              └─batch
│  │  │                  │──BatchApplication.java
│  │  │                  │
│  │  │                  ├─config
│  │  │                  │   └─BatchConfig.java
│  │  │                  │
│  │  │                  ├─model
│  │  │                  │   ├─People.java
│  │  │                  │   └─PeopleDESC.java
│  │  │                  │
│  │  │                  ├─processor
│  │  │                  │   └─AddPeopleDescProcessor.java
│  │  │                  │
│  │  │                  └─writer
│  │  │                      ├─AddDescPeopleWriter.java
│  │  │                      └─AddPeopleWriter.java
│  │  │
│  │  └─resources
│  │      └─application.properties
│  │
│  └─test
│      └─java
│          └─com
│              └─oceanbase
│                  └─example
│                      └─batch
│                          ├─config
│                          │   └─BatchConfigTest.java
│                          │
│                          ├─processor
│                          │   └─AddPeopleDescProcessorTest.java
│                          │
│                          └─writer
│                              ├─AddDescPeopleWriterTest.java
│                              └─AddPeopleWriterTest.java
│
└─target
```

**The files and directories are described as follows:**

* `pom.xml`: the configuration file of the Maven project, which contains the dependencies, plug-ins, and build rules of the project.
* `.idea`: a directory used in an Integrated Development Environment (IDE) to store configuration information related to the project.
* `src`: a directory that stores the source code in the project.
* `main`: a directory that stores the main source code and resource files.
* `java`: a directory that stores the Java source code.
* `com.oceanbase.example.batch`: The name of the package.
* `BatchApplication.java`: the entry class to the application, which contains the main methods of the application.
* `config`: the configuration class folder that contains the configuration classes of the application.
* `BatchConfig.java`: the configuration class of the application, which is used to configure some properties and behavior of the application.
* `model`: the model class folder that contains the data model classes of the application.
* `People.java`: the personnel data model class.
* `PeopleDESC.java`: the personnel description data model class.
* `processor`: the processor class folder that contains the processor classes of the application.
* `AddPeopleDescProcessor.java`: the processor class that adds personnel description information.
* `writer`: the writer class folder that contains the writer classes of the application.
* `AddDescPeopleWriter.java`: the writer class that writes personnel description information.
* `AddPeopleWriter.java`: the writer class that writes personnel information.
* `resources`: the resource folder that contains the configuration file and other static resource files of the application.
* `application.properties`: the configuration file of the application, which is used to configure the properties of the application.
* `test`: a directory that stores the test code and resource files.
* `BatchConfigTest.java`: the test class for the configuration class of the application.
* `AddPeopleDescProcessorTest.java`: the test class for the processor class that adds personnel description information.
* `AddDescPeopleWriterTest.java`: the test class for the writer class that writes personnel description information.
* `AddPeopleWriterTest.java`: the test class for the writer class that writes personnel information.
* `target`: a directory that stores compiled class files and JAR packages.

### Code in pom.xml

<main id="notice" type='explain'>
  <h4>Note</h4>
  <p>You can retain the default code in this file for verification purposes or modify the code in the file as needed. </p>
</main>

Perform the following steps to configure the `pom.xml` file:

1. Declare the file.

    Declare the file to be an XML file that uses the XML standard 1.0 and character encoding format UTF-8.

    **Here is the sample code:**

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    ```

2. Configure namespaces and the POM model version.

   1. `xmlns`: the default XML namespace for the POM, which is set to `http://maven.apache.org/POM/4.0.0`.
   2. `xmlns:xsi`: the XML namespace for XML elements prefixed with `xsi`, which is set to `http://www.w3.org/2001/XMLSchema-instance`.
   3. `xsi:schemaLocation`: the location of an XML schema definition (XSD) file. The value consists of two parts: the default XML namespace (`http://maven.apache.org/POM/4.0.0`) and the URI of the XSD file (`https://maven.apache.org/xsd/maven-4.0.0.xsd`).
   4. `<modelVersion>`: the POM model version used by the POM file, which is set to `4.0.0`.

   **Here is the sample code:**

   ```xml
    <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
        <modelVersion>4.0.0</modelVersion>
   </project>
   ```

3. Configure parent project information.

   1. `<groupId>`: the ID of the parent project group, which is set to `org.springframework.boot`.
   2. `<artifactId>`: the name of the parent project, which is set to `spring-boot-starter-parent`.
   3. `<version>`: the version of the parent project, which is set to `2.7.11`.
   4. `<relativePath>`: an empty path for the parent project.

   **Here is the sample code:**

   ```xml
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.7.11</version>
        <relativePath/>
    </parent>
   ```

4. Configure basic information.

   1. `<groupId>`: the ID of the project group, which is set to `com.oceanbase`.
   2. `<artifactId>`: the name of the project, which is set to `java-oceanbase-springboot`.
   3. `<version>`: the version of the project, which is set to `0.0.1-SNAPSHOT`.
   4. `<description>`: the project information, which is set to `Demo project for Spring Batch`.

   **Here is the sample code:**

   ```xml
    <groupId>com.oceanbase</groupId>
    <artifactId>java-oceanbase-springboot</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>java-oceanbase-springbatch</name>
    <description>Demo project for Spring Batch</description>
   ```

5. Configure the Java version.

    Specify to use Java 1.8 for the project.

    **Here is the sample code:**

    ```xml
      <properties>
          <java.version>1.8</java.version>
      </properties>
    ```

6. Configure core dependencies.

   1. Define a dependency named `spring-boot-starter` that belongs to the `org.springframework.boot` group. This dependency contains default features provided by Spring Boot, such as web, data processing, security, and testing.

        **Here is the sample code:**

        ```xml
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>
        ```

   2. Define a dependency named `spring-boot-starter-jdbc` that belongs to the `org.springframework.boot` group. This dependency contains Java Database Connectivity (JDBC) features provided by Spring Boot, such as connection pool and data source configuration.

        **Here is the sample code:**

        ```xml
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-jdbc</artifactId>
        </dependency>
        ```

   3. Define a dependency named `spring-boot-starter-test` that belongs to the `org.springframework.boot` group. This dependency takes effect in the `test` scope and provides test frameworks and tools of Spring Boot, such as JUnit, Mockito, and Hamcrest.

        **Here is the sample code:**

        ```xml
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        ```

   4. Define a dependency named `oceanbase-client` that belongs to the `com.oceanbase` group and whose version is `2.4.12`. With this dependency, you can use the features of OceanBase Command-Line Client (OBClient), such as connections, queries, and transactions.

      **Here is the sample code:**

        ```xml
            <dependency>
                <groupId>com.oceanbase</groupId>
                <artifactId>oceanbase-client</artifactId>
                <version>2.4.12</version>
            </dependency>
        ```

   5. Define a dependency named `spring-boot-starter-batch` that belongs to the `org.springframework.boot` group. This dependency contains the batch processing feature provided by Spring Boot.

      **Here is the sample code:**

        ```xml
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-batch</artifactId>
        </dependency>
        ```

   6. Define a dependency named `spring-boot-starter-data-jpa` that belongs to the `org.springframework.boot` group. This dependency contains necessary dependencies and configurations for Java Persistence API (JPA)-based data accesses, and is a Spring Boot starter.

        **Here is the sample code:**

        ```xml
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        ```

   7. Define a dependency named `tomcat-jdbc` that belongs to the `org.apache.tomcat` group. This dependency allows the application to use JDBC connection pool features provided by Tomcat, including connection pool configuration, connection acquisition and release, and connection management.

        **Here is the sample code:**

        ```xml
        <dependency>
            <groupId>org.apache.tomcat</groupId>
            <artifactId>tomcat-jdbc</artifactId>
        </dependency>
        ```

   8. Define a dependency named `junit` that belongs to the `junit` group and whose version is `4.10` and effective scope is `test`. This dependency allows the application to use JUnit.

        **Here is the sample code:**

        ```xml
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.10</version>
            <scope>test</scope>
        </dependency>
        ```

   9. Define a dependency named `javax.activation-api` that belongs to the `javax.activation` group and whose version is `1.2.0`. This dependency provides the Java Activation Framework (JAF) API.

        **Here is the sample code:**

        ```xml
        <dependency>
            <groupId>javax.activation</groupId>
            <artifactId>javax.activation-api</artifactId>
            <version>1.2.0</version>
        </dependency>
        ```

   10. Define a dependency named `jakarta.persistence-api` that belongs to the `jakarta.persistence` group and whose version is `2.2.3`. This dependency provides the Jakarta Persistence API.
        **Here is the sample code:**

        ```xml
        <dependency>
            <groupId>jakarta.persistence</groupId>
            <artifactId>jakarta.persistence-api</artifactId>
            <version>2.2.3</version>
        </dependency>
        ```

7. Configure the Maven plug-in.

   Define a plug-in named `spring-boot-maven-plugin` that belongs to the `org.springframework.boot` group. This plug-in can be used to package Spring Boot applications as executable JAR packages or WAR packages, or directly run Spring Boot applications.

   **Here is the sample code:**

   ```xml
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
   ```

### Code in application.properties

The `application.properties` file contains database connection configurations, such as the database driver, URL, username, and password. It also contains configurations related to the JPA, Spring Batch, and log level.

1. Configure the database connection.

    * `spring.datasource.driver`: the database driver used to establish a connection with OceanBase Database, which is set to `com.mysql.cj.jdbc.Driver`.
    * `spring.datasource.url`: the URL for connecting to the database.
    * `spring.datasource.username`: the username for connecting to the database.
    * `spring.datasource.password`: the password for connecting to the database.

    **Here is the sample code:**

    ```java
    spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
    spring.datasource.url=jdbc:oceanbase://host:port/schema_name?characterEncoding=utf-8
    spring.datasource.username=user_name
    spring.datasource.password=******
    ```

2. Configure the JPA.

    * `spring.jpa.show-sql`: specifies whether to display SQL statements in logs. The value `true` here indicates that SQL statements are displayed in logs.
    * `spring.jpa.hibernate.ddl-auto`: the DDL operation performed by Hibernate. The value `update` here indicates that Hibernate automatically updates the database schema when the application starts.

    **Here is the sample code:**

    ```java
    spring.jpa.show-sql=true
    spring.jpa.hibernate.ddl-auto=update
    ```

3. Configure Spring Batch.

    `spring.batch.job.enable`: specifies whether to enable Spring Batch jobs. The value `false` here indicates that Spring Batch jobs are disabled.

    **Here is the sample code:**

    ```java
    spring.batch.job.enabled=false
    ```

    <main id="notice" type='explain'>
    <h4>Note</h4>
    <p>In Spring Batch, the <code>spring.batch.job.enabled</code> property specifies whether to execute Spring Batch jobs. The settings are described as follows: <ul><li><code>spring.batch.job.enabled=true</code> (default value): enables Spring Batch jobs, which means that Spring Boot automatically detects and executes all defined jobs when the Spring Boot application starts. </li><li><code>spring.batch.job.enabled=false</code>: disables Spring Batch jobs. Set the property to <code>false</code> in a development or testing environment, or when you want to manually execute jobs by calling REST APIs or using a command-line tool. </li></ul>
    To sum up, <code>spring.batch.job.enabled=false</code> allows you to flexibly execute Spring Batch jobs at any time you want. </p></main>

4. Configure the log level.

    * `logging.level.org.springframework`: the log level of the Spring framework, which is set to `INFO`.
    * `logging.level.com.example`: the log level for the custom code of the application, which is set to `DEBUG`.

    **Here is the sample code:**

    ```java
    logging.level.org.springframework=INFO
    logging.level.com.example=DEBUG
    ```

### Code in BatchApplication.java

The `BatchApplication.java` file is the entry file to the Spring Boot application.

Perform the following steps to configure the `BatchApplication.java` file:

1. Reference other classes and interfaces.

    Declare this file to contain the following interfaces and classes:

    * `SpringApplication` class: launches a Spring Boot application.
    * `SpringBootApplication` annotation: marks the class as the entry to the Spring Boot application.

    **Here is the sample code:**

    ```java
        import org.springframework.boot.SpringApplication;
        import org.springframework.boot.autoconfigure.SpringBootApplication;
    ```

2. Define the `BatchApplication` class.

   `@SpringBootApplication` annotation: marks the `BatchApplication` class as the entry to the Spring Boot application. `BatchApplication` class: defines a static `main` method as the entry to the application. In the `main` method, use the `SpringApplication.run` method to launch the Spring Boot application. Define a method named `runBatchJob` to run batch jobs.

    **Here is the sample code:**

    ```java


        @SpringBootApplication
        public class BatchApplication {
            public static void main(String[] args) {
                SpringApplication.run(BatchApplication.class, args);
            }
    
            public void runBatchJob() {
            }
        }
    ```

### Code in BatchConfig.java

The `BatchConfig.java` file configures components such as the steps, reader, processor, and writer for batch jobs.

Perform the following steps to configure the `BatchConfig.java` file:

1. Reference other classes and interfaces.

    Declare this file to contain the following interfaces and classes:

    * `People` class: stores personnel information read from the database.
    * `PeopleDESC` class: stores the description converted or processed from personnel information.
    * `AddPeopleDescProcessor` class: converts a `People` object to a `PeopleDESC` object. This class implements the `ItemProcessor` interface.
    * `AddDescPeopleWriter` class: writes a `PeopleDESC` object to a specified destination. This class implements the `ItemWriter` interface.
    * `Job` interface: indicates a batch job.
    * `Step` interface: indicates a step in a job.
    * `EnableBatchProcessing` annotation: enables and configures Spring Batch features.
    * `JobBuilderFactory` class: creates and configures jobs.
    * `StepBuilderFactory` class: creates and configures steps.
    * `RunIdIncrementer` class: the run ID incrementer of Spring Batch, which is used to increment the run ID each time a job is run.
    * `ItemProcessor` interface: processes or converts the read items.
    * `ItemReader` interface: reads items from the data source.
    * `ItemWriter` interface: writes processed or converted items to a specified destination.
    * `JdbcCursorItemReader` class: reads data from the database and returns a cursor result set.
    * `Autowired` annotation: injects dependencies.
    * `Bean` annotation: creates and configures beans.
    * `ComponentScan` annotation: specifies the package or class to scan for components.
    * `Configuration` annotation: marks a class as a configuration class.
    * `EnableAutoConfiguration` annotation: enables automatic configuration of Spring Boot.
    * `SpringBootApplication` annotation: marks the class as the entry to the Spring Boot application.
    * `DataSource` interface: obtains database connections.

    **Here is the sample code:**

    ```java
    import com.oceanbase.example.batch.model.People;
    import com.oceanbase.example.batch.model.PeopleDESC;
    import com.oceanbase.example.batch.processor.AddPeopleDescProcessor;
    import com.oceanbase.example.batch.writer.AddDescPeopleWriter;
    import org.springframework.batch.core.Job;
    import org.springframework.batch.core.Step;
    import org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;
    import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
    import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
    import org.springframework.batch.core.launch.support.RunIdIncrementer;
    import org.springframework.batch.item.ItemProcessor;
    import org.springframework.batch.item.ItemReader;
    import org.springframework.batch.item.ItemWriter;
    import org.springframework.batch.item.database.JdbcCursorItemReader;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
    import org.springframework.boot.autoconfigure.SpringBootApplication;
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.ComponentScan;
    import org.springframework.context.annotation.Configuration;
    import org.springframework.jdbc.core.BeanPropertyRowMapper;

    import javax.sql.DataSource;
    ```

2. Define the `BatchConfig` class.

    It is a simple batch job of Spring Batch. In the class, define how data is read, processed, and written, and encapsulate these steps as a simple Spring Batch job. Use the annotations and automatic configuration feature of Spring Batch to create corresponding component instances by calling various `@Bean` methods, and use these components to read, process, and write data in `step1`.

    * Use `@Configuration` to mark this class as a configuration class.
    * Use `@EnableBatchProcessing` to enable Spring Batch. The annotation automatically creates necessary beans, such as `JobRepository` and `JobLauncher`.
    * Use `@SpringBootApplication` to mark the main class of the Spring Boot application. The Spring Boot application is launched from the main class.
    * Use `@ComponentScan` to specify the package to scan for components. Spring Boot scans and registers all components in the package and its sub-packages.
    * Use `@EnableAutoConfiguration` to automatically configure the infrastructure of the Spring Boot application.

    **Here is the sample code:**

    ```java
     @Configuration
     @EnableBatchProcessing
     @SpringBootApplication
     @ComponentScan("com.oceanbase.example.batch.writer")
     @EnableAutoConfiguration
     public class BatchConfig {
     }
    ```

   1. Define the `@Autowired` annotation.

      Use the `@Autowired` annotation to inject `JobBuilderFactory`, `StepBuilderFactory`, and `DataSource` as member variables in the `BatchConfig` class. `JobBuilderFactory` is the factory class used to create and configure jobs. `StepBuilderFactory` is the factory class used to create and configure steps. `DataSource` is the interface used to obtain database connections.

        **Here is the sample code:**

        ```java
        @Autowired
        private JobBuilderFactory jobBuilderFactory;

        @Autowired
        private StepBuilderFactory stepBuilderFactory;

        @Autowired
        private DataSource dataSource;
        ```

   2. Define the `@Bean` annotation.

      Use the `@Bean` annotation to define methods for creating readers, processors, writers, steps, and jobs.

      * Call the `peopleReader` method to create an instance of the `ItemReader` component. The component uses `JdbcCursorItemReader` to read `People` objects from the database. Set the data source in `dataSource`, set `RowMapper` to map database rows to `People` objects, and set the SQL query statement to `SELECT * FROM people`.
      * Call the `addPeopleDescProcessor` method to create an instance of the `ItemProcessor` component. The component uses `AddPeopleDescProcessor` to process `People` objects and return `PeopleDESC` objects.
      * Call the `addDescPeopleWriter` method to create an instance of the `ItemWriter` component. The component uses `AddDescPeopleWriter` to write `PeopleDESC` objects to the destination.
      * Call the `step1` method to create an instance of the `Step` component. Name the instance as `step1`. Call `stepBuilderFactory.get` to get the step builder. Set the reader to the `ItemReader` component, the processor to the `ItemProcessor` component, the writer to the `ItemWriter` component, and the chunk size to `10`. Call `build` to build and return the configured `Step` instance.
      * Call the `importJob` method to create an instance of the `Job` component. Name the job as `importJob`. Call `jobBuilderFactory.get` to get the job builder. Set the incrementer to `RunIdIncrementer` and the initial step in `flow` to `Step`. Call `build` to build and return the configured `Job` instance.

        **Here is the sample code:**

        ```java
        @Bean
        public ItemReader<People> peopleReader() {
            JdbcCursorItemReader<People> reader = new JdbcCursorItemReader<>();
            reader.setDataSource((javax.sql.DataSource) dataSource);
            reader.setRowMapper(new BeanPropertyRowMapper<>(People.class));
            reader.setSql("SELECT * FROM people");
            return reader;
        }
        
        @Bean
        public ItemProcessor<People, PeopleDESC> addPeopleDescProcessor() {
            return new AddPeopleDescProcessor();
        }
        
        @Bean
        public ItemWriter<PeopleDESC> addDescPeopleWriter() {
            return new AddDescPeopleWriter();
        }
        
        @Bean
        public Step step1(ItemReader<People> reader, ItemProcessor<People, PeopleDESC> processor,
                        ItemWriter<PeopleDESC> writer) {
            return stepBuilderFactory.get("step1")
                    . <People, PeopleDESC>chunk(10)
                    .reader(reader)
                    .processor(processor)
                    .writer(writer)
                    .build();
        }
        
        @Bean
        public Job importJob(Step step1) {
            return jobBuilderFactory.get("importJob")
                    .incrementer(new RunIdIncrementer())
                    .flow(step1)
                    .end()
                    .build();
        }
        ```

### Code in People.java

The `People.java` file defines a data model class named `People` to represent personnel information. The class contains two private member variables: `name` and `age`, and corresponding `getter` and `setter` methods. The `toString` method is overridden to print the object information. `name` indicates the name of a person, and `age` indicates the age of a person. The `getter` and `setter` methods respectively get and set the values of these attributes.

The class provides data storage and transfer means for the input and output of a batch program. In batch reads and writes, `People` objects store data, `setter` methods set data, and `getter` methods get data.

**Here is the sample code:**

```java
    public class People {
        private String name;
        private int age;

            // getters and setters

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public int getAge() {
            return age;
        }

        public void setAge(int age) {
            this.age = age;
        }
        @Override
        public String toString() {
            return "People [name=" + name + ", age=" + age + "]";
        }
        // Getters and setters
    }
```

### Code in PeopleDESC.java

The `PeopleDESC.java` file defines a data model class named `PeopleDESC` to represent the description of personnel information. The `PeopleDESC` class contains four attributes: `name`, `age`, `desc`, and `id`, which respectively represent the name, age, description, and identifier of a person. The class also contains corresponding `getter` and `setter` methods for getting and setting the attribute values. The `toString` method is overridden to return a string representation of the class, including the name, age, and description.

Similar to the `People` class, the `PeopleDESC` class provides data storage and transfer means for the input and output of a batch program.

**Here is the sample code:**

```java
    public class PeopleDESC {
        private String name;
        private int age;
        private String desc;
        private int id;

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public int getAge() {
            return age;
        }

        public void setAge(int age) {
            this.age = age;
        }

        public String getDesc() {
            return desc;
        }

        public void setDesc(String desc) {
            this.desc = desc;
        }

        public int getId() {
            return id;
        }

        public void setId(int id) {
            this.id = id;
        }

        @Override
        public String toString() {
            return "PeopleDESC [name=" + name + ", age=" + age + ", desc=" + desc + "]";
        }
    }
```

### Code in AddPeopleDescProcessor.java

The `AddPeopleDescProcessor.java` file defines a class named `AddPeopleDescProcessor` that implements the `ItemProcessor` interface for converting `People` objects to `PeopleDESC` objects.

Perform the following steps to configure the `AddPeopleDescProcessor.java` file:

1. Reference other classes and interfaces.

    Declare this file to contain the following interfaces and classes:

    * `People` class: stores personnel information read from the database.
    * `PeopleDESC` class: stores the description converted or processed from personnel information.
    * `ItemProcessor` interface: processes or converts the read items.

    **Here is the sample code:**

    ```java
    import com.oceanbase.example.batch.model.People;
    import com.oceanbase.example.batch.model.PeopleDESC;
    import org.springframework.batch.item.ItemProcessor;
    ```

2. Define the `AddPeopleDescProcessor` class.

    The `AddPeopleDescProcessor` class of the `ItemProcessor` interface converts `People` objects to `PeopleDESC` objects, thus implementing the batch processing logic for the input data.

    In the `process` method of this class, create a `PeopleDESC` object named `desc`, and then use the `item` parameter to obtain the attributes (`name` and `age`) of the `People` object and populate these attributes to the `desc` object. At the same time, assign a value to the `desc` attribute of the `desc` object. The value assignment logic is to generate the description of the `People` object based on its attributes. Finally, return the processed `PeopleDESC` object.

    **Here is the sample code:**

    ```java
    public class AddPeopleDescProcessor implements ItemProcessor<People, PeopleDESC> {
        @Override
        public PeopleDESC process(People item) throws Exception {
            PeopleDESC desc = new PeopleDESC();
            desc.setName(item.getName());
            desc.setAge(item.getAge());
            desc.setDesc("This is " + item.getName() + " with age " + item.getAge());
            return desc;
        }
    }
    ```

### Code in AddDescPeopleWriter.java

The `AddPeopleWriter.java` file implements the `AddDescPeopleWriter` class of the `ItemWriter` interface to write `People` objects to the database.

Perform the following steps to configure the `AddDescPeopleWriter.java` file:

1. Reference other classes and interfaces.

    Declare this file to contain the following interfaces and classes:

    * `PeopleDESC` class: stores the description converted or processed from personnel information.
    * `ItemWriter` interface: writes processed or converted items to a specified destination.
    * `Autowired` annotation: injects dependencies.
    * `JdbcTemplate` class: provides methods for executing SQL statements.
    * `List` interface: operates the query result set.

    **Here is the sample code:**

    ```java
    import com.oceanbase.example.batch.model.PeopleDESC;
    import org.springframework.batch.item.ItemWriter;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.jdbc.core.JdbcTemplate;

    import java.util.List;
    ```

2. Define the `AddDescPeopleWriter` class.

   1. Use the `@Autowired` annotation to automatically inject the `JdbcTemplate` instance, which will be used to perform database operations for data writes.

        **Here is the sample code:**

        ```java
            @Autowired
            private JdbcTemplate jdbcTemplate;
        ```

   2. In the `write` method, traverse `List<? extends PeopleDESC>` that is passed in to fetch all `PeopleDESC` objects in sequence. Execute the SQL statement `DROP TABLE people_desc` to drop the table named `people_desc` that may already exist. Execute the SQL statement `CREATE TABLE people_desc (id INT PRIMARY KEY, name VARCHAR2(255), age INT, description VARCHAR2(255))` to create a table named `people_desc` with four columns: `id`, `name`, `age`, and `description`. Execute the SQL statement `INSERT INTO people_desc (id, name, age, description) VALUES (?, ?, ?, ?)` to insert the attribute values of each `PeopleDESC` object into the `people_desc` table.

        **Here is the sample code:**

        ```java
            @Override
            public void write(List<? extends PeopleDESC> items) throws Exception {
                // Drop the table that may already exist.
                jdbcTemplate.execute("DROP TABLE people_desc");
                // Create the table.
                String createTableSql = "CREATE TABLE people_desc (id INT PRIMARY KEY, name VARCHAR2(255), age INT, description VARCHAR2(255))";
                jdbcTemplate.execute(createTableSql);
                for (PeopleDESC item : items) {
                    String sql = "INSERT INTO people_desc (id, name, age, description) VALUES (?, ?, ?, ?) ";
                    jdbcTemplate.update(sql, item.getId(), item.getName(), item.getAge(), item.getDesc());
                }
            }
        ```

### Code in AddPeopleWriter.java

The `AddPeopleWriter.java` file implements the `AddDescPeopleWriter` class of the `ItemWriter` interface to write `PeopleDESC` objects to the database.

Perform the following steps to configure the `AddPeopleWriter.java` file:

1. Reference other classes and interfaces.

    Declare this file to contain the following interfaces and classes:

    * `People` class: stores personnel information read from the database.
    * `ItemWriter` interface: writes processed or converted items to a specified destination.
    * `Autowired` annotation: injects dependencies.
    * `JdbcTemplate` class: provides methods for executing SQL statements.
    * `Component` annotation: marks the class as a Spring component.
    * `List` interface: operates the query result set.

    **Here is the sample code:**

    ```java
    import com.oceanbase.example.batch.model.People;
    import org.springframework.batch.item.ItemWriter;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.jdbc.core.JdbcTemplate;
    import org.springframework.stereotype.Component;

    import java.util.List;
    ```

2. Define the `AddPeopleWriter` class.

   1. Use the `@Autowired` annotation to automatically inject the `JdbcTemplate` instance, which will be used to perform database operations for data writes.

        **Here is the sample code:**

        ```java
            @Autowired
            private JdbcTemplate jdbcTemplate;
        ```

   2. In the `write` method, traverse `List<? extends People>` that is passed in to fetch all `People` objects in sequence. Execute the SQL statement `DROP TABLE people` to drop the table named `people` that may already exist. Execute the SQL statement `CREATE TABLE people (name VARCHAR2(255), age INT)` to create a table named `people` with two columns: `name` and `age`. Execute the SQL statement `INSERT INTO people (name, age) VALUES (?, ?)` to insert the attribute values of each `People` object into the `people` table.

        **Here is the sample code:**

        ```java
        @Override
        public void write(List<? extends People> items) throws Exception {
            // Drop the table that may already exist.
            jdbcTemplate.execute("DROP TABLE people");
            // Create the table.
            String createTableSql = "CREATE TABLE people (name VARCHAR2(255), age INT)";
            jdbcTemplate.execute(createTableSql);
            for (People item : items) {
                String sql = "INSERT INTO people (name, age) VALUES (?, ?) ";
                jdbcTemplate.update(sql, item.getName(), item.getAge());
            }
        }
        ```

### Code in BatchConfigTest.java

The `BatchConfigTest.java` file defines a class that uses JUnit for testing and is used to test the job configuration of Spring Batch.

Perform the following steps to configure the `BatchConfigTest.java` file:

1. Reference other classes and interfaces.

    Declare this file to contain the following interfaces and classes:

    * `Assert` class: asserts test results.
    * `Test` annotation: marks a test method.
    * `RunWith` annotation: specifies the test runner.
    * `Job` interface: indicates a batch job.
    * `JobExecution` class: indicates the execution of a batch job.
    * `JobParameters` class: indicates the parameters of a batch job.
    * `JobParametersBuilder` class: builds parameters of a batch job.
    * `JobLauncher` interface: launches a batch job.
    * `Autowired` annotation: injects dependencies.
    * `SpringBootTest` annotation: marks the test class as a Spring Boot test.
    * `SpringRunner` class: specifies SpringRunner as the test runner.

    **Here is the sample code:**

    ```java
    import org.junit.Assert;
    import org.junit.jupiter.api.Test;
    import org.junit.runner.RunWith;
    import org.springframework.batch.core.Job;
    import org.springframework.batch.core.JobExecution;
    import org.springframework.batch.core.JobParameters;
    import org.springframework.batch.core.JobParametersBuilder;
    import org.springframework.batch.core.launch.JobLauncher;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.test.context.SpringBootTest;
    import org.springframework.test.context.junit4.SpringRunner;

    import javax.batch.runtime.BatchStatus;
    import java.util.UUID;
    ```

2. Define the `BatchConfigTest` class.

   With the `SpringBootTest` annotation and the `SpringRunner` runner, this class can perform Spring Boot integration tests. In the `testJob` method, use the `JobLauncherTestUtils` helper class to launch a batch job and use an assertion to verify the execution status of the job.

   1. Use the `@Autowired` annotation to automatically inject the `JobLauncherTestUtils` instance.

        **Here is the sample code:**

        ```java
        @Autowired
        private JobLauncherTestUtils jobLauncherTestUtils;
        ```

   2. Use the `@Test` annotation to mark the `testJob` method as a test method. In this method, create a `JobParameters` object, call the `jobLauncherTestUtils.launchJob` method to launch the batch job, and then call the `Assert.assertEquals` method to assert the execution status of the job as `COMPLETED`.

        **Here is the sample code:**

        ```java
        @Test
        public void testJob() throws Exception {
            JobParameters jobParameters = new JobParametersBuilder()
                    .addString("jobParam", "paramValue")
                    .toJobParameters();

            JobExecution jobExecution = jobLauncherTestUtils.launchJob(jobParameters);

            Assert.assertEquals(BatchStatus.COMPLETED, jobExecution.getStatus());
        }
        ```

   3. Use the `@Autowired` annotation to automatically inject the `JobLauncher` instance.

        **Here is the sample code:**

        ```java
        @Autowired
        private JobLauncher jobLauncher;
        ```

   4. Use the `@Autowired` annotation to automatically inject the `Job` instance.

        **Here is the sample code:**

        ```java
        @Autowired
        private Job job;
        ```

   5. Define an inner class named `JobLauncherTestUtils` to assist in launching a batch job. In the class, define the `launchJob` method for launching a batch job. In this method, call the `jobLauncher.run` method to launch a job and return the execution result of the job.

        **Here is the sample code:**

        ```java
        private class JobLauncherTestUtils {
            public JobExecution launchJob(JobParameters jobParameters) throws Exception {
                return jobLauncher.run(job, jobParameters);
            }
        }
        ```

### Code in AddPeopleDescProcessorTest.java

The `AddPeopleDescProcessorTest.java` file defines a class that uses JUnit for testing and is used to test the job configuration of Spring Batch.

Perform the following steps to configure the `AddPeopleDescProcessorTest.java` file:

1. Reference other classes and interfaces.

    Declare this file to contain the following interfaces and classes:

    * `People` class: stores personnel information read from the database.
    * `PeopleDESC` class: stores the description converted or processed from personnel information.
    * `Assert` class: checks whether the actual test result meets the expectation.
    * `Test` annotation: marks a test method.
    * `RunWith` annotation: specifies the test runner.
    * `Autowired` annotation: injects dependencies.
    * `SpringBootTest` annotation: marks the test class as a Spring Boot test.
    * `SpringRunner` class: specifies SpringRunner as the test runner.

    **Here is the sample code:**

    ```java
    import com.oceanbase.example.batch.model.People;
    import com.oceanbase.example.batch.model.PeopleDESC;
    import org.junit.Assert;
    import org.junit.jupiter.api.Test;
    import org.junit.runner.RunWith;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.test.context.SpringBootTest;
    import org.springframework.test.context.junit4.SpringRunner;
    ```

2. Define the `AddPeopleDescProcessorTest` class.

   With the `SpringBootTest` annotation and the `SpringRunner` runner, this class can perform Spring Boot integration tests.

   1. Use the `@Autowired` annotation to automatically inject the `AddPeopleDescProcessor` instance.

      **Here is the sample code:**

        ```java
        @Autowired
        private AddPeopleDescProcessor processor;
        ```

   2. Use the `@Test` annotation to mark the `testProcess` method as a test method. In this method, create a `People` object, call the `processor.process` method to process the object, and then assign the result to a `PeopleDESC` object.

        **Here is the sample code:**

        ```java
        @Test
        public void testProcess() throws Exception {
        People people = new People();
        people.setName("John");
        people.setAge(25);
        
        PeopleDESC desc = processor.process(people);
        }
        ```

### Code in AddDescPeopleWriterTest.java

The `AddDescPeopleWriterTest.java` file is a class that uses JUnit for testing and is used to test the write logic of `AddDescPeopleWriter`.

Perform the following steps to configure the `AddDescPeopleWriterTest.java` file:

1. Reference other classes and interfaces.

    Declare this file to contain the following interfaces and classes:

    * `PeopleDESC` class: stores the description converted or processed from personnel information.
    * `Assert` class: asserts test results.
    * `Test` annotation: marks a test method.
    * `RunWith` annotation: specifies the test runner.
    * `Autowired` annotation: injects dependencies.
    * `SpringBootTest` annotation: marks the test class as a Spring Boot test.
    * `JdbcTemplate` class: provides methods for executing SQL statements.
    * `SpringRunner` class: specifies SpringRunner as the test runner.
    * `ArrayList` class: creates an empty list.
    * `List` interface: operates the query result set.

    **Here is the sample code:**

    ```java
    import com.oceanbase.example.batch.model.PeopleDESC;
    import org.junit.Assert;
    import org.junit.jupiter.api.Test;
    import org.junit.runner.RunWith;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.test.context.SpringBootTest;
    import org.springframework.jdbc.core.JdbcTemplate;
    import org.springframework.test.context.junit4.SpringRunner;

    import java.util.ArrayList;
    import java.util.List;
    ```

2. Define the `AddDescPeopleWriterTest` class.

   With the `SpringBootTest` annotation and the `SpringRunner` runner, this class can perform Spring Boot integration tests.

   1. Use `@Autowired` to inject instances.
      Use the `@Autowired` annotation to automatically inject the `AddDescPeopleWriter` and `JdbcTemplate` instances.

      **Here is the sample code:**

        ```java
        @Autowired
        private AddDescPeopleWriter writer;
        @Autowired
        private JdbcTemplate jdbcTemplate;
        ```

   2. Use the method marked with `@Test` to test data insertion and output.
      Use the `@Test` annotation to mark the `testWrite` method as a test method. In this method, create an empty `peopleDescList` list and then add two `PeopleDESC` objects to the list. Call the `writer.write` method to write data in the list to the database. Use `jdbcTemplate` to execute the query statement that obtains data from the `people_desc` table. Execute the assertion statement to verify the correctness of the data. Return the query results to the console and return a message to indicate that job execution is complete.

      1. Insert data into the `people_desc` table.
         Create an empty `PeopleDESC` object list named `peopleDescList`. Create two `PeopleDESC` objects named `desc1` and `desc2` and set their attribute values. Add `desc1` and `desc2` to the `peopleDescList` list. Call the `write` method of `writer` to write the objects in the `peopleDescList` list to the `people_desc` table in the database. Call `JdbcTemplate` to execute the query statement `SELECT COUNT(*) FROM people_desc` that obtains the number of records in the `people_desc` table. Assign the result to the `count` variable. Call the `Assert.assertEquals` method to assert whether the value of `count` is `2`.

         **Here is the sample code:**

         ```java
            List<PeopleDESC> peopleDescList = new ArrayList<>();
            PeopleDESC desc1 = new PeopleDESC();
            desc1.setId(1);
            desc1.setName("John");
            desc1.setAge(25);
            desc1.setDesc("This is John with age 25");
            peopleDescList.add(desc1);
            PeopleDESC desc2 = new PeopleDESC();
            desc2.setId(2);
            desc2.setName("Alice");
            desc2.setAge(30);
            desc2.setDesc("This is Alice with age 30");
            peopleDescList.add(desc2);
            writer.write(peopleDescList);
         
            String selectSql = "SELECT COUNT(*) FROM people_desc";
            int count = jdbcTemplate.queryForObject(selectSql, Integer.class);
            Assert.assertEquals(2, count);
         ```

      2. Return data in the `people_desc` table.
         Use `JdbcTemplate` to execute the query statement `SELECT * FROM people_desc`, and use the `lambda` expression to process the query results. In the `lambda` expression, use methods such as `rs.getInt` and `rs.getString` to obtain field values in the query result set and populate the field values to the newly created `PeopleDESC` objects. Add all the newly created `PeopleDESC` objects to the result list `resultDesc`. Print the prompt line `Data in the people_desc table:`. Then, use a `FOR` loop to traverse the `resultDesc` list and use `System.out.println` to print the `PeopleDESC` objects in the list one by one. Finally, print a message to indicate that job execution is complete.

         **Here is the sample code:**

         ```java
         List<PeopleDESC> resultDesc = jdbcTemplate.query("SELECT * FROM people_desc", (rs, rowNum) -> {
            PeopleDESC desc = new PeopleDESC();
            desc.setId(rs.getInt("id"));
            desc.setName(rs.getString("name"));
            desc.setAge(rs.getInt("age"));
            desc.setDesc(rs.getString("description"));
            return desc;
         });
         
         System.out.println("Data in the people_desc table:" );
         for (PeopleDESC desc : resultDesc) {
            System.out.println(desc);
         }
         
         // Return a message to indicate that job execution is complete.
         System.out.println("Batch Job execution completed." );
         ```

### Code in AddPeopleWriterTest.java

The `AddPeopleWriterTest.java` file is a class that uses JUnit for testing and is used to test the write logic of `AddPeopleWriterTest`.

Perform the following steps to configure the `AddPeopleWriterTest.java` file:

1. Reference other classes and interfaces.

    Declare this file to contain the following interfaces and classes:

    * `People` class: stores personnel information read from the database.
    * `Test` annotation: marks a test method.
    * `RunWith` annotation: specifies the test runner.
    * `Autowired` annotation: injects dependencies.
    * `SpringBootApplication` annotation: marks the class as the entry to the Spring Boot application.
    * `SpringBootTest` annotation: marks the test class as a Spring Boot test.
    * `ComponentScan` annotation: specifies the package or class to scan for components.
    * `JdbcTemplate` class: provides methods for executing SQL statements.
    * `SpringRunner` class: specifies `SpringRunner` as the test runner.
    * `ArrayList` class: creates an empty list.
    * `List` interface: operates the query result set.

    **Here is the sample code:**

    ```java
    import com.oceanbase.example.batch.model.People;
    import org.junit.jupiter.api.Test;
    import org.junit.runner.RunWith;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.autoconfigure.SpringBootApplication;
    import org.springframework.boot.test.context.SpringBootTest;
    import org.springframework.context.annotation.ComponentScan;
    import org.springframework.jdbc.core.JdbcTemplate;
    import org.springframework.test.context.junit4.SpringRunner;

    import java.util.ArrayList;
    import java.util.List;
    ```

2. Define the `AddPeopleWriterTest` class.

   Use the `SpringBootTest` annotation and the `SpringRunner` runner for Spring Boot integration testing, and use the `@ComponentScan` annotation to specify the package to scan.

   1. Use `@Autowired` to inject instances.
      Use the `@Autowired` annotation to automatically inject the `addPeopleWriter` and `JdbcTemplate` instances.

      **Here is the sample code:**

        ```java
        @Autowired
        private AddPeopleWriter addPeopleWriter;
        @Autowired
        private JdbcTemplate jdbcTemplate;
        ```

   2. Use the method marked with `@Test` to test data insertion and output.

      1. Insert data into the `people` table.
         First, create an empty `People` object list named `peopleList`. Then, create two `People` objects: `person1` and `person2`, and set their name and age attributes. Add the two `People` objects to the `peopleList` list. Call the `write` method of `addPeopleWriter` and pass `peopleList` to the method as a parameter, so as to write the `People` objects to the database.

         **Here is the sample code:**

         ```java
            List<People> peopleList = new ArrayList<>();
            People person1 = new People();
            person1.setName("zhangsan");
            person1.setAge(27);
            peopleList.add(person1);
            People person2 = new People();
            person2.setName("lisi");
            person2.setAge(35);
            peopleList.add(person2);
            addPeopleWriter.write(peopleList);
         ```

      2. Return data in the `people` table.
         Use `JdbcTemplate` to execute the query statement `SELECT * FROM people`, and use the `lambda` expression to process the query results. In the `lambda` expression, use the `rs.getString` and `rs.getInt` methods to obtain field values in the query result set and populate the field values to a new `People` object. Add all the newly created `People` objects to the result list `result`. Print the prompt line `Data in the people table:`. Then, use a `FOR` loop to traverse the result list and use `System.out.println` to print the `People` objects in the list one by one. Finally, print a message to indicate that job execution is complete.

         **Here is the sample code:**

         ```java
            List<People> result = jdbcTemplate.query("SELECT * FROM people", (rs, rowNum) -> {
                People person = new People();
                person.setName(rs.getString("name"));
                person.setAge(rs.getInt("age"));
                return person;
            });
         
            System.out.println("Data in the people table:" );
            for (People person : result) {
                System.out.println(person);
            }
         
            // Return a message to indicate that job execution is complete.
            System.out.println("Batch Job execution completed." );
         ```

### Complete code

:::tab
tab pom.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.7.11</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.oceanbase</groupId>
    <artifactId>java-oceanbase-springboot</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>java-oceanbase-springbatch</name>
    <description>Demo project for Spring Batch</description>
    <properties>
        <java.version>1.8</java.version>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>
        <dependency>
            <groupId>com.oceanbase</groupId>
            <artifactId>oceanbase-client</artifactId>
            <version>2.4.3</version>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-jdbc</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-batch</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.apache.tomcat</groupId>
            <artifactId>tomcat-jdbc</artifactId>
        </dependency>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.10</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>javax.activation</groupId>
            <artifactId>javax.activation-api</artifactId>
            <version>1.2.0</version>
        </dependency>
        <dependency>
            <groupId>jakarta.persistence</groupId>
            <artifactId>jakarta.persistence-api</artifactId>
            <version>2.2.3</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>

```

tab application.properties

```properties
#configuration database

spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:oceanbase://host:port/schema_name?characterEncoding=utf-8
spring.datasource.username=user_name
spring.datasource.password=

# JPA
spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=update

# Spring Batch
spring.batch.job.enabled=false

#
logging.level.org.springframework=INFO
logging.level.com.example=DEBUG
```

tab BatchApplication.java

```java
package com.oceanbase.example.batch;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class BatchApplication {
    public static void main(String[] args) {
        SpringApplication.run(BatchApplication.class, args);
    }

    public void runBatchJob() {
    }
}

```

tab BatchConfig.java

```java
package com.oceanbase.example.batch.config;

import com.oceanbase.example.batch.model.People;
import com.oceanbase.example.batch.model.PeopleDESC;
import com.oceanbase.example.batch.processor.AddPeopleDescProcessor;
import com.oceanbase.example.batch.writer.AddDescPeopleWriter;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;
import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.batch.core.launch.support.RunIdIncrementer;
import org.springframework.batch.item.ItemProcessor;
import org.springframework.batch.item.ItemReader;
import org.springframework.batch.item.ItemWriter;
import org.springframework.batch.item.database.JdbcCursorItemReader;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.BeanPropertyRowMapper;

import javax.sql.DataSource;
//import javax.activation.DataSource;

@Configuration
@EnableBatchProcessing
@SpringBootApplication
@ComponentScan("com.oceanbase.example.batch.writer")
@EnableAutoConfiguration
public class BatchConfig {
    @Autowired
    private JobBuilderFactory jobBuilderFactory;

    @Autowired
    private StepBuilderFactory stepBuilderFactory;

    @Autowired
    private DataSource dataSource;// Use the default dataSource provided by automatic Spring Boot configuration



    @Bean
    public ItemReader<People> peopleReader() {
        JdbcCursorItemReader<People> reader = new JdbcCursorItemReader<>();
        reader.setDataSource((javax.sql.DataSource) dataSource);
        reader.setRowMapper(new BeanPropertyRowMapper<>(People.class));
        reader.setSql("SELECT * FROM people");
        return reader;
    }

    @Bean
    public ItemProcessor<People, PeopleDESC> addPeopleDescProcessor() {
        return new AddPeopleDescProcessor();
    }

    @Bean
    public ItemWriter<PeopleDESC> addDescPeopleWriter() {
        return new AddDescPeopleWriter();
    }

    @Bean
    public Step step1(ItemReader<People> reader, ItemProcessor<People, PeopleDESC> processor,
                      ItemWriter<PeopleDESC> writer) {
        return stepBuilderFactory.get("step1")
                . <People, PeopleDESC>chunk(10)
                .reader(reader)
                .processor(processor)
                .writer(writer)
                .build();
    }

    @Bean
    public Job importJob(Step step1) {
        return jobBuilderFactory.get("importJob")
                .incrementer(new RunIdIncrementer())
                .flow(step1)
                .end()
                .build();
    }
}
```

tab People.java

```java
package com.oceanbase.example.batch.model;

public class People {
    private String name;
    private int age;

        // getters and setters

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
    @Override
    public String toString() {
        return "People [name=" + name + ", age=" + age + "]";
    }
    // Getters and setters
}
```

tab PeopleDESC.java

```java
package com.oceanbase.example.batch.model;

public class PeopleDESC {
    private String name;
    private int age;
    private String desc;
    private int id;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getDesc() {
        return desc;
    }

    public void setDesc(String desc) {
        this.desc = desc;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    @Override
    public String toString() {
        return "PeopleDESC [name=" + name + ", age=" + age + ", desc=" + desc + "]";
    }
}
```

tab AddPeopleDescProcessor.java

```java
package com.oceanbase.example.batch.processor;

import com.oceanbase.example.batch.model.People;
import com.oceanbase.example.batch.model.PeopleDESC;
import org.springframework.batch.item.ItemProcessor;


public class AddPeopleDescProcessor implements ItemProcessor<People, PeopleDESC> {
    @Override
    public PeopleDESC process(People item) throws Exception {
        PeopleDESC desc = new PeopleDESC();
        desc.setName(item.getName());
        desc.setAge(item.getAge());
        desc.setDesc("This is " + item.getName() + " with age " + item.getAge());
        return desc;
    }
}
```

tab AddDescPeopleWriter.java

```java
package com.oceanbase.example.batch.writer;

import com.oceanbase.example.batch.model.PeopleDESC;
import org.springframework.batch.item.ItemWriter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;

import java.util.List;

public class AddDescPeopleWriter implements ItemWriter<PeopleDESC> {
    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Override
    public void write(List<? extends PeopleDESC> items) throws Exception {
        // Drop the table that may already exist.
        jdbcTemplate.execute("DROP TABLE people_desc");
        // Create the table.
        String createTableSql = "CREATE TABLE people_desc (id INT PRIMARY KEY, name VARCHAR2(255), age INT, description VARCHAR2(255))";
        jdbcTemplate.execute(createTableSql);
        for (PeopleDESC item : items) {
            String sql = "INSERT INTO people_desc (id, name, age, description) VALUES (?, ?, ?, ?) ";
            jdbcTemplate.update(sql, item.getId(), item.getName(), item.getAge(), item.getDesc());
        }
    }
}
```

tab AddPeopleWriter.java

```java
package com.oceanbase.example.batch.writer;

import com.oceanbase.example.batch.model.People;
import org.springframework.batch.item.ItemWriter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

import java.util.List;

@Component
public class AddPeopleWriter implements ItemWriter<People> {
    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Override
    public void write(List<? extends People> items) throws Exception {
        // Drop the table that may already exist.
        jdbcTemplate.execute("DROP TABLE people");
        // Create the table.
        String createTableSql = "CREATE TABLE people (name VARCHAR2(255), age INT)";
        jdbcTemplate.execute(createTableSql);
        for (People item : items) {
            String sql = "INSERT INTO people (name, age) VALUES (?, ?) ";
            jdbcTemplate.update(sql, item.getName(), item.getAge());
        }
    }
}

```

tab BatchConfigTest.java

```java
package com.oceanbase.example.batch.config;

import com.oceanbase.example.batch.writer.AddDescPeopleWriter;
import org.junit.Assert;
import org.junit.jupiter.api.Test;
import org.junit.runner.RunWith;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobParameters;
import org.springframework.batch.core.JobParametersBuilder;
import org.springframework.batch.core.launch.JobLauncher;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import org.springframework.test.context.junit4.SpringRunner;

import javax.annotation.Resource;
import javax.batch.runtime.BatchStatus;
import java.util.UUID;

@RunWith(SpringRunner.class)
@SpringBootTest
public class BatchConfigTest {

    @Test
    public void testJob() throws Exception {
        JobParameters jobParameters = new JobParametersBuilder()
                .addString("jobParam", UUID.randomUUID().toString())
                .toJobParameters();

        JobLauncherTestUtils jobLauncherTestUtils = new JobLauncherTestUtils();
        JobExecution jobExecution = jobLauncherTestUtils.launchJob(jobParameters);
        Assert.assertEquals(BatchStatus.COMPLETED.toString(), jobExecution.getStatus().toString());
    }

    @Autowired
    private JobLauncher jobLauncher;

    @Autowired
    private Job job;

    private class JobLauncherTestUtils {

        public JobExecution launchJob(JobParameters jobParameters) throws Exception {
            return jobLauncher.run(job, jobParameters);
        }
    }
}

```

tab AddPeopleDescProcessorTest.java

```java
package com.oceanbase.example.batch.processor;

import com.oceanbase.example.batch.model.People;
import com.oceanbase.example.batch.model.PeopleDESC;
import org.junit.jupiter.api.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

@RunWith(SpringRunner.class)
@SpringBootTest
public class AddPeopleDescProcessorTest {
    @Autowired
    private AddPeopleDescProcessor processor;

    @Test
    public void testProcess() throws Exception {
        People people = new People();
  //      people.setName("John");
  //      people.setAge(25);

        PeopleDESC desc = processor.process(people);

//      Assert.assertEquals("John", desc.getName());
//        Assert.assertEquals(25, desc.getAge());
 //       Assert.assertEquals("This is John with age 25", desc.getDesc());
    }
}

```

tab AddDescPeopleWriterTest.java

```java
package com.oceanbase.example.batch.writer;

import com.oceanbase.example.batch.model.PeopleDESC;
import org.junit.Assert;
import org.junit.jupiter.api.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.test.context.junit4.SpringRunner;

import java.util.ArrayList;
import java.util.List;

@RunWith(SpringRunner.class)
@SpringBootTest
public class AddDescPeopleWriterTest {
    @Autowired
    private AddDescPeopleWriter writer;
    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Test
    public void testWrite() throws Exception {


        // Insert data into the people_desc table.
        List<PeopleDESC> peopleDescList = new ArrayList<>();
        PeopleDESC desc1 = new PeopleDESC();
        desc1.setId(1);
        desc1.setName("John");
        desc1.setAge(25);
        desc1.setDesc("This is John with age 25");
        peopleDescList.add(desc1);
        PeopleDESC desc2 = new PeopleDESC();
        desc2.setId(2);
        desc2.setName("Alice");
        desc2.setAge(30);
        desc2.setDesc("This is Alice with age 30");
        peopleDescList.add(desc2);
        writer.write(peopleDescList);

        String selectSql = "SELECT COUNT(*) FROM people_desc";
        int count = jdbcTemplate.queryForObject(selectSql, Integer.class);
        Assert.assertEquals(2, count);

        // Return data in the people_desc table.
        List<PeopleDESC> resultDesc = jdbcTemplate.query("SELECT * FROM people_desc", (rs, rowNum) -> {
            PeopleDESC desc = new PeopleDESC();
            desc.setId(rs.getInt("id"));
            desc.setName(rs.getString("name"));
            desc.setAge(rs.getInt("age"));
            desc.setDesc(rs.getString("description"));
            return desc;
        });

        System.out.println("Data in the people_desc table:" );
        for (PeopleDESC desc : resultDesc) {
            System.out.println(desc);
        }

        // Return a message to indicate that job execution is complete.
        System.out.println("Batch Job execution completed." );
    }
}
```

tab AddPeopleWriterTest.java 

```java
package com.oceanbase.example.batch.writer;

import com.oceanbase.example.batch.model.People;
import org.junit.jupiter.api.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.test.context.junit4.SpringRunner;

import java.util.ArrayList;
import java.util.List;

@RunWith(SpringRunner.class)
@SpringBootTest
@SpringBootApplication
@ComponentScan("com.oceanbase.example.batch.writer")
public class AddPeopleWriterTest {

    @Autowired
    private AddPeopleWriter addPeopleWriter;
    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Test
    public void testWrite() throws Exception {
        // Insert data into the people table.
        List<People> peopleList = new ArrayList<>();
        People person1 = new People();
        person1.setName("zhangsan");
        person1.setAge(27);
        peopleList.add(person1);
        People person2 = new People();
        person2.setName("lisi");
        person2.setAge(35);
        peopleList.add(person2);
        addPeopleWriter.write(peopleList);

        // Query and return the result.
        List<People> result = jdbcTemplate.query("SELECT * FROM people", (rs, rowNum) -> {
            People person = new People();
            person.setName(rs.getString("name"));
            person.setAge(rs.getInt("age"));
            return person;
        });

        System.out.println("Data in the people table:" );
        for (People person : result) {
            System.out.println(person);
        }

        // Return a message to indicate that job execution is complete.
        System.out.println("Batch Job execution completed." );
    }
}

```

:::

## References

For more information about OceanBase Connector/J, see [OceanBase Connector/J](https://en.oceanbase.com/docs/oceanbase-connector-j-en).
