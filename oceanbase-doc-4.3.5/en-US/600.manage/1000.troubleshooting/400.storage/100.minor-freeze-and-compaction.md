| description ||
|---|---|
| keywords ||
| dir-name ||
| dir-name-en ||
| tenant-type ||

# Minor compaction and major compaction

Minor compaction consists of two processes: mini compaction and minor compaction. When the size of the MemTable exceeds a certain threshold, the data in the MemTable needs to be dumped into a Mini SSTable to free up memory. This process is called mini compaction. As user data continues to be written, the number of mini SSTables increases. When the number of mini SSTables exceeds a certain threshold, minor compaction is automatically triggered in the background. Mini compaction generates new mini SSTables. When the number of mini compaction operations exceeds a certain threshold, or during the daily business off-peak hours, the system will merge the baseline SSTable (major SSTable) with the incremental SSTables generated by subsequent dumps (Mini/Minor SSTables) into a new major SSTable. This process is called major compaction.

The percentage of memory allowed for MemTables to the total available MemStore memory of a tenant is specified by the `memstore_limit_percentage` parameter. MemTables are classified into active MemTables and frozen MemTables. When the memory usage of MemTable reaches `memstore_limit_percentage` Ã— `freeze_trigger_percentage`, a freeze is automatically triggered to generate a new active MemTable. The existing active MemTable becomes a frozen MemTable. Then, a minor compaction is automatically scheduled. When the minor compaction is completed, the memory occupied by the frozen MemTable is released.

<main id="notice" type='explain'>
<h4>Note</h4>
<ul>
<li><code>memstore_limit_percentage</code> specifies the percentage of the total available memory of a tenant that can be used for MemStores. The default value is 0. The range of values is [0, 100). For more information about this parameter, see <a href="../../../700.reference/800.configuration-items-and-system-variables/100.system-configuration-items/300.cluster-level-configuration-items/13800.memstore_limit_percentage.md">memstore_limit_percentage</a>.
<li><code>freeze_trigger_percentage</code> specifies the threshold of memory usage for triggering a global freeze for tenants. When the memory usage reaches the threshold, the system will freeze the tenant. The default value is 20, and the value range is (0, 100). For more information about this parameter, see <a href="../../../700.reference/800.configuration-items-and-system-variables/100.system-configuration-items/400.tenant-level-configuration-items/3300.freeze_trigger_percentage.md">freeze_trigger_percentage</a>.
</ul>
</main>

You can increase the frequency of minor compaction by using the following methods:

* Set the `freeze_trigger_percentage` parameter to a smaller value.

* Manually trigger a minor compaction by running the following command: `alter system minor freeze`.

A major compaction is automatically triggered when the number of freezes in a tenant reaches the threshold specified by using the `major_compact_trigger` parameter. In OceanBase Database V4.x, the default value is 0, which indicates that the automatic triggering of a major compaction based on the number of freezes is disabled.

<main id="notice" type='explain'>
    <h4>Note</h4>
    <p>The <code>major_compact_trigger</code> parameter specifies the threshold of the number of freezes at which a major compaction is triggered. The value range is [0, 65535]. For more information about this parameter, see <a href="../../../700.reference/800.configuration-items-and-system-variables/100.system-configuration-items/400.tenant-level-configuration-items/5200.major_compact_trigger.md">major_compact_trigger</a>. </p>
</main>

You can increase the frequency of major compaction by using the following methods:

* Set the `major_compact_trigger` parameter to a smaller value.

* Manually trigger a major compaction by running the following command: `alter system major freeze`.

## Data inconsistencies during a major compaction

The following data inconsistencies may occur during a major compaction:

* The number of rows in the primary table is inconsistent with that in the index table.

* The checksum values of some columns in the major SSTable are inconsistent.

* The checksum values of all rows in the major SSTable are inconsistent.

