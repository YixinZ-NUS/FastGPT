|description||
|---|---|
|keywords||
|dir-name||
|dir-name-en||
|tenant-type|MySQL Mode|

# Automatic partition splitting

OceanBase Database allows you to predefine automatic partitioning rules, enabling the system to automatically split partitions when data grows to a certain threshold. This feature ensures that tables can scale automatically as data increases, avoiding issues such as unbalanced loads and degraded performance caused by oversized partitions.

## Supported scenarios

The current version supports automatic partition splitting only for primary key tables with partitions partitioned by RANGE or RANGE COLUMNS.

## Limitations and considerations

* Automatic partition splitting is not supported for tables partitioned by LIST or HASH.
* Automatic partition splitting is not supported for tables with subpartitions.
* Automatic partition splitting is not supported if the partition key of the table being automatically split does not match the prefix of the primary key.
* Automatic partition splitting is not supported for tables without a primary key.
* Automatic partition splitting is not supported for columnstore tables.
* Automatic partition splitting is not supported for columnstore replicas.
* If the table is in a `TABLEGROUP` (table group) that contains multiple tables, automatic partition splitting is not supported. However, if the `TABLEGROUP` contains only this table, automatic partition splitting is supported.
* Automatic partition splitting is not supported for materialized views.
* Automatic partition splitting is not supported for full-text indexes.
* Automatic partition splitting is not supported for GIS indexes.
* Automatic partition splitting is not supported for vector indexes.
* Starting from OceanBase Database V4.3.5 BP2, the [global_index_auto_split_policy](../../../../800.configuration-items-and-system-variables/100.system-configuration-items/400.tenant-level-configuration-items/3350.global_index_auto_split_policy.md) parameter is supported. This parameter is used to control whether the automatic partitioning feature is enabled for newly created global indexes. If automatic partitioning is enabled for a newly created global index, the partitioning rules will be regenerated based on the data volume, that is, pre-splitting will occur.

## Automatic partition splitting at the table level

You can configure automatic partitioning at the table level by using the `SIZE` clause when creating a table.

### Syntax for creating a table with automatic partition splitting

```sql
CREATE TABLE table_name (column_definition_list, PRIMARY KEY(column_name_list))
    PARTITION BY RANGE [COLUMNS]([column_name_list]) [SIZE('size_value')]
    [(range_partition_list)];

column_definition_list:
    column_definition[, column_definition ...]

column_name_list:
    column_name[, column_name ...]

range_partition_list:
    PARTITION partition_name VALUES LESS THAN (value_list)[, PARTITION partition_name VALUES LESS THAN (value_list) ...]

value_list:
    value[, value ...]
```

#### Parameters

| **Parameter** | **Description** |
|----------------------|----------|
| table_name           | The name of the table. |
| column_definition_list | The list of column definitions, including column names, data types, and constraints. For more information, see [CREATE TABLE](../../../../500.sql-reference/100.sql-syntax/200.common-tenant-of-mysql-mode/600.sql-statement-of-mysql-mode/2600.create-table-of-mysql-mode.md).|
| PRIMARY KEY | The primary key of the table. |
| PARTITION BY RANGE \[COLUMNS\]\(\[column_name_list\]\) | The pre-partitioning key. When automatic partition splitting is triggered, the specified pre-partitioning key is used as the actual partitioning key (if `column_name_list` is not specified, the primary key is used as the partitioning key).<main id="notice" type='notice'><h4>Notice</h4><p><ul><li>If you specify multiple columns as the pre-partitioning key, you must use <code>PARTITION BY RANGE COLUMNS()</code>. </li><li>The restrictions on pre-partitioning keys are the same as those on partitioning keys. </li></ul></p></main>|
| SIZE('size_value') | (Optional) The threshold for partition splitting. If the `SIZE()` clause is not specified, the value of the `auto_split_tablet_size` parameter at the tenant level is used as the default value. `size_value` can be set to `unlimited`, which indicates that partition splitting is not triggered and no new automatic partition splitting task is scheduled. |
| range_partition_list | (Optional) Predefined partitioning positions (partitioning rules).<main id="notice" type='notice'><h4>Notice</h4><p>If you specify predefined partitioning positions, you must specify the pre-partitioning key. Otherwise, an error is returned. </p></main>|

### Syntax for modifying automatic partition splitting attributes

```sql
ALTER TABLE table_name
    PARTITION BY RANGE [COLUMNS]([column_name_list]) [SIZE('size_value')]
    [(range_partition_list)];

column_name_list:
    column_name[, column_name ...]

range_partition_list:
    PARTITION partition_name VALUES LESS THAN (value_list)[, PARTITION partition_name VALUES LESS THAN (value_list) ...]

value_list:
    value[, value ...]
```

<main id="notice" type='explain'>
  <h4>Note</h4>
  <p>If you execute the <code>ALTER TABLE ... PARTITION BY ...</code> statement without specifying a partitioning rule, the automatic partition splitting attributes of the table are modified in online DDL mode, which does not affect the existing partitioning definitions. </p>
</main>

#### Parameters

| **Parameter** | **Description** |
|----------------------|----------|
| column_name_list     | The pre-partitioning key of a non-partitioned table. When you execute the `ALTER TABLE` statement to modify the automatic partition splitting attributes of a non-partitioned table, if the pre-partitioning key is specified in the `RANGE()` clause, the corresponding records in the schema are modified; otherwise, the original settings are retained.<main id="notice" type='notice'><h4>Notice</h4><p>If you specify multiple columns as the pre-partitioning key, you must use <code>PARTITION BY RANGE COLUMNS()</code>. </p></main>|
| SIZE('size_value')   | (Optional) The threshold for partition splitting. When `size_value` is set to `unlimited`, partition splitting is not triggered, and no new automatic partition splitting task is scheduled. |
| range_partition_list | (Optional) The partitioning rules. If you do not specify the `SIZE` clause but specify partitioning definitions, only the partitioning rules are modified, and the existing automatic partition splitting definitions are retained. |

## Automatic partition splitting at the tenant level

You can configure the `enable_auto_split` and `auto_split_tablet_size` parameters at the tenant level to control automatic partition splitting for tables that meet the criteria within a tenant. If the `SIZE` clause is omitted when creating a table, the system determines whether the table will use automatic partitioning based on the following tenant-level parameters (by default, the primary key column is used as the partitioning key):

* [enable_auto_split](../../../../800.configuration-items-and-system-variables/100.system-configuration-items/400.tenant-level-configuration-items/2350.enable_auto_split.md): A tenant-level parameter. The value specifies whether to enable automatic partition splitting for the tenant. The default value is `false`.
* [auto_split_tablet_size](../../../../800.configuration-items-and-system-variables/100.system-configuration-items/400.tenant-level-configuration-items/450.auto_split_tablet_size.md): A tenant-level parameter. The value specifies the threshold for triggering automatic partition splitting after automatic partition splitting is enabled for the tenant. The default value is 128 MB.

If you do not specify the `SIZE` clause and set `enable_auto_split` to `true`, automatic partition splitting is enabled for only tables that meet the partitioning criteria. For example, when you create a subpartitioned table, a table without a primary key, or a table whose partitioning key is different from the primary key prefix, the table is created as a non-automatic partitioned table (if you manually specify special DDL statements for automatic partition splitting, an error is returned).

<main id="notice" type='explain'>
  <h4>Note</h4>
  <p>You can query the automatic partition splitting attributes of a table by using the <code>information_schema.TABLES</code> view or the <code>oceanbase.CDB_TABLES</code> view in the system tenant. </p>
</main>

## Automatic partition splitting behavior

### DDL operations for automatic partition splitting

* Modify partitioning rules: Only changes to partitioning rules that use range partitioning by primary key are supported. Other partitioning rule modifications are not allowed.
* Modify the primary key: The primary key can only be modified if the automatic subpartitioning key remains a prefix of the primary key.
* Column operations: Limitations on pre-partitioning keys are the same as those on partitioning keys.

<main id="notice" type='explain'>
  <h4>Note</h4>
  <p>The limitations on other DDL operations are the same as those on non-automatic partitioned tables. </p>
</main>

### DML behavior

During partition splitting, the source and destination schemas coexist, and DML operations on both partitions are treated as operating on the same dataset. Specifically, writes and queries on the source partition are redirected to the corresponding destination partition, while writes and queries on the destination partition account for forwarded writes from the source partition. The following table outlines the behavior of DML operations in different scenarios.

| Scenario | DML on the source partition (INSERT INTO t1 PARTITION(p0) ...) | DML involving the source partition (SELECT * FROM t1) | DML on the destination partition | DML involving the destination partition |
|-----|---------------------------------------------------|------------------------------------|-------------------|-------------------|
| Before the partition splitting transaction is committed | Normal | Normal | Error. The behavior is the same as that for operations on non-existent partitions. | Not applicable. |
| During partition splitting | May result in an error. The behavior is the same as that for operations on non-existent partitions. | No error. The system retries write and query statements that fail due to stream switching. | Normal | Normal |
| After the partition splitting transaction is committed | Error. The behavior is the same as that for operations on non-existent partitions. | Not applicable. | Normal | Normal |

## Examples

### Example 1: Create an automatically partitioned table

1. Disable automatic partitioning.

    ```sql
    AlTER SYSTEM SET enable_auto_split = FALSE;
    ```

    <main id="notice" type='explain'>
      <h4>Note</h4>
      <p>You can execute <code>SHOW PARAMETERS LIKE 'enable_auto_split';</code> to check whether automatic partitioning is enabled. </p>
    </main>

2. Create an automatically partitioned table named `test1_tbl1` without specifying a prepartitioning key and set the split threshold to 10 GB.

    ```sql
    CREATE TABLE test1_tbl1 (col1 INT, col2 INT, col3 VARCHAR(30), PRIMARY KEY(col1, col2))
        PARTITION BY RANGE() SIZE('10GB');
    ```

3. Create an automatically partitioned table named `test1_tbl2` with a prepartitioning key of `col1` and a split threshold of 10 GB.

    ```sql
    CREATE TABLE test1_tbl2 (col1 INT, col2 INT, col3 VARCHAR(30), PRIMARY KEY(col1, col2))
        PARTITION BY RANGE(col1) SIZE('10GB');
    ```

4. Create an automatically partitioned table named `test1_tbl3` without specifying a prepartitioning key or a split threshold (the split threshold will use the value of `auto_split_tablet_size` by default).

    ```sql
    CREATE TABLE test1_tbl3 (col1 INT, col2 INT, col3 VARCHAR(30), PRIMARY KEY(col1, col2))
        PARTITION BY RANGE();
    ```

5. Create an automatically partitioned table named `test1_tbl4` with prepartitioning keys of `col1` and `col2`, a split threshold of 10 GB, and partitioning points of `P0`, `P1`, `P2`, and `P3`.

    ```sql
    CREATE TABLE test1_tbl4 (col1 INT, col2 INT, col3 VARCHAR(30), PRIMARY KEY(col1, col2))
        PARTITION BY RANGE COLUMNS(col1, col2) SIZE('10GB')
            (PARTITION P0 VALUES LESS THAN (100, MAXVALUE),
             PARTITION P1 VALUES LESS THAN (500, MAXVALUE),
             PARTITION P2 VALUES LESS THAN (800, MAXVALUE),
             PARTITION P3 VALUES LESS THAN (MAXVALUE, MAXVALUE));
    ```

6. View the automatic partitioning attributes of the table.

    ```sql
    SELECT TABLE_SCHEMA, TABLE_NAME, AUTO_SPLIT, AUTO_SPLIT_TABLET_SIZE
    FROM information_schema.TABLES
    WHERE TABLE_NAME LIKE "test1%"
    ORDER BY TABLE_NAME;
    ```

    The return result is as follows:

    ```shell
    +--------------+------------+------------+------------------------+
    | TABLE_SCHEMA | TABLE_NAME | AUTO_SPLIT | AUTO_SPLIT_TABLET_SIZE |
    +--------------+------------+------------+------------------------+
    | db_test      | test1_tbl1 | TRUE       |            10737418240 |
    | db_test      | test1_tbl2 | TRUE       |            10737418240 |
    | db_test      | test1_tbl3 | TRUE       |              134217728 |
    | db_test      | test1_tbl4 | TRUE       |            10737418240 |
    +--------------+------------+------------+------------------------+
    4 rows in set
    ```

### Example 2: Modify the automatic partitioning attributes of a table

1. Create an automatically partitioned table named `test2_tbl1` with a prepartitioning key of `col1` and a split threshold of 10 GB.

    ```sql
    CREATE TABLE test2_tbl1 (col1 INT, col2 INT, col3 VARCHAR(30), PRIMARY KEY(col1, col2))
        PARTITION BY RANGE(col1) SIZE('10GB');
    ```

2. Modify the split threshold of the `test2_tbl1` table to 1 GB.

    ```sql
    ALTER TABLE test2_tbl1 PARTITION BY RANGE() SIZE('1GB');
    ```

    Or

    ```sql
    ALTER TABLE test2_tbl1 PARTITION BY RANGE(col1) SIZE('1GB');
    ```

3. Create an automatically partitioned table named `test2_tbl2` with a prepartitioning key of `col1`, a split threshold of 10 GB, and partitioning points of `p0` (rows with values less than 100), `p1` (rows with values greater than or equal to 100 and less than 200), and `p_max` (rows with values greater than or equal to 200).

    ```sql
    CREATE TABLE test2_tbl2 (col1 INT, col2 INT, col3 VARCHAR(30), PRIMARY KEY(col1, col2))
        PARTITION BY RANGE(col1) SIZE('10GB')
            (PARTITION p0 VALUES LESS THAN(100),
             PARTITION p1 VALUES LESS THAN(200),
             PARTITION p_max VALUES LESS THAN (MAXVALUE));
    ```

4. Modify the split threshold of the `test2_tbl2` table to 5 GB and change the partitioning points to `p0` (rows with values less than 300) and `p_max` (rows with values greater than or equal to 300).

    ```sql
    ALTER TABLE test2_tbl2
        PARTITION BY RANGE(col1) SIZE('5GB')
            (PARTITION p0 VALUES LESS THAN(300),
             PARTITION p_max VALUES LESS THAN (MAXVALUE));
    ```

5. Create an automatically partitioned table named `test2_tbl3` with a prepartitioning key of `col1` and a split threshold of 10 GB.

    ```sql
    CREATE TABLE test2_tbl3 (col1 INT, col2 INT, col3 VARCHAR(30), PRIMARY KEY(col1, col2))
        PARTITION BY RANGE(col1) SIZE('10GB');
    ```

6. Disable automatic partitioning for the `test2_tbl3` table. This change does not affect existing partitions, and no new automatic partitioning splits will be scheduled.

    ```sql
    ALTER TABLE test2_tbl3 PARTITION BY RANGE() SIZE('unlimited');
    ```

7. Create an automatically partitioned table named `test2_tbl4` with a prepartitioning key of `col1` and a split threshold of 10 GB.

    ```sql
    CREATE TABLE test2_tbl4 (col1 INT, col2 INT, col3 VARCHAR(30), PRIMARY KEY(col1, col2))
        PARTITION BY RANGE(col1) SIZE('10GB');
    ```

8. Change the prepartitioning key of the `test2_tbl4` table from `col1` to `col1,col2`.

    ```sql
    ALTER TABLE test2_tbl4 PARTITION BY RANGE COLUMNS(col1,col2) SIZE('10GB');
    ```

9. Create a non-partitioned table named `test2_tbl5`.

    ```sql
    CREATE TABLE test2_tbl5 (col1 INT, col2 INT, col3 VARCHAR(30), PRIMARY KEY(col1, col2));
    ```

10. Execute the `ALTER TABLE` statement without the `SIZE` clause to convert the `test2_tbl5` table to an automatically partitioned table. The split threshold will use the value of `auto_split_tablet_size` by default.

    ```sql
    ALTER TABLE test2_tbl5 PARTITION BY RANGE COLUMNS(col1);
    ```

11. View the automatic partitioning attributes of the table.

    ```sql
    SELECT TABLE_SCHEMA, TABLE_NAME, AUTO_SPLIT, AUTO_SPLIT_TABLET_SIZE
    FROM information_schema.TABLES
    WHERE TABLE_NAME LIKE "test2%"
    ORDER BY TABLE_NAME;
    ```

    The return result is as follows:

    ```shell
    +--------------+------------+------------+------------------------+
    | TABLE_SCHEMA | TABLE_NAME | AUTO_SPLIT | AUTO_SPLIT_TABLET_SIZE |
    +--------------+------------+------------+------------------------+
    | db_test      | test2_tbl1 | TRUE       |             1073741824 |
    | db_test      | test2_tbl2 | TRUE       |             5368709120 |
    | db_test      | test2_tbl3 | FALSE      |                      0 |
    | db_test      | test2_tbl4 | TRUE       |            10737418240 |
    | db_test      | test2_tbl5 | TRUE       |              134217728 |
    +--------------+------------+------------+------------------------+
    5 rows in set
    ```

### Example 3: Create a table after automatic partitioning is enabled

1. Enable automatic partitioning.

    ```sql
    AlTER SYSTEM SET enable_auto_split = TRUE;
    ```

2. Create a non-partitioned table named `test3_tbl1`. Because all non-partitioned tables in the tenant are automatically partitioned by using the `SIZE` partitioning method, the following normal table creation statement will automatically partition the table. The tenant-level configuration item (128 MB by default) will be used as the split threshold.

    ```sql
    CREATE TABLE test3_tbl1 (col1 INT, col2 INT, PRIMARY KEY(col1));
    ```

3. Create a non-partitioned table named `test3_tbl2` for automatic partitioning. Because no partitioning key is specified, the primary key will be used as the partitioning key. The split threshold will use the value of `auto_split_tablet_size` by default.

    ```sql
    CREATE TABLE test3_tbl2 (col1 INT, col2 INT, PRIMARY KEY(col1))
        PARTITION BY RANGE ();
    ```

4. Create a non-partitioned table named `test3_tbl3` for automatic partitioning. The split threshold will use the value of `auto_split_tablet_size` by default.

    ```sql
    CREATE TABLE test3_tbl3 (col1 INT, col2 INT, PRIMARY KEY(col1))
        PARTITION BY RANGE () SIZE('1024MB');
    ```

5. Create a non-partitioned table named `test3_tbl4`.

    ```sql
    CREATE TABLE test3_tbl4 (col1 INT, col2 INT, PRIMARY KEY(col1))
        PARTITION BY RANGE () SIZE('unlimited');
    ```

6. A table without a primary key does not meet the requirements for automatic partitioning. Even if `enable_auto_split = true`, automatic partitioning will not be enabled.

    ```sql
    CREATE TABLE test3_tbl5 (col1 INT, col2 INT);
    ```

7. A table without a primary key does not meet the requirements for automatic partitioning. The automatic partitioning feature cannot be manually enabled for such a table.

    ```sql
    CREATE TABLE test3_tbl6 (col1 INT, col2 INT)
        PARTITION BY RANGE ();
    ```

    The return result is as follows:

    ```shell
    ERROR 1235 (0A000): auto partitioned table without primary key is not supported
    ```

8. View the automatic partitioning attributes of the table.

    ```sql
    SELECT TABLE_SCHEMA, TABLE_NAME, AUTO_SPLIT, AUTO_SPLIT_TABLET_SIZE
    FROM information_schema.TABLES
    WHERE TABLE_NAME LIKE "test3%"
    ORDER BY TABLE_NAME;
    ```

    The return result is as follows:

    ```shell
    +--------------+------------+------------+------------------------+
    | TABLE_SCHEMA | TABLE_NAME | AUTO_SPLIT | AUTO_SPLIT_TABLET_SIZE |
    +--------------+------------+------------+------------------------+
    | db_test      | test3_tbl1 | TRUE       |              134217728 |
    | db_test      | test3_tbl2 | TRUE       |              134217728 |
    | db_test      | test3_tbl3 | TRUE       |             1073741824 |
    | db_test      | test3_tbl4 | FALSE      |                      0 |
    | db_test      | test3_tbl5 | FALSE      |                      0 |
    +--------------+------------+------------+------------------------+
    5 rows in set
    ```

### Example 4: Enable automatic partitioning for global indexes

<main id="notice" type='explain'>
  <h4>Note</h4>
  <p>For tables with automatic partitioning enabled, global indexes created on them will be automatically partitioned, even if the <a href="../../../../800.configuration-items-and-system-variables/100.system-configuration-items/400.tenant-level-configuration-items/3350.global_index_auto_split_policy.md">global_index_auto_split_policy</a> parameter is not enabled.</p>
</main>

1. Create an automatically partitioned table `test4_tbl1` (with a split threshold of 1024 MB, using user configuration).

    ```sql
    CREATE TABLE test4_tbl1 (col1 INT, col2 INT, col3 INT, PRIMARY KEY(col1))
        PARTITION BY RANGE () SIZE('1024MB');
    ```

2. Create a global index `idx1_test4_tbl1` on the table `test4_tbl1`.

    ```sql
    CREATE INDEX idx1_test4_tbl1 ON test4_tbl1 (col2) GLOBAL;
    ```

3. Enable the automatic partitioning feature for newly created global indexes.

    ```sql
    ALTER SYSTEM SET global_index_auto_split_policy = 'ALL';
    ```

4. Create a partitioned table `test4_tbl2` without automatic partitioning.

    ```sql
    CREATE TABLE test4_tbl2(col1 INT, col2 INT, col3 INT, PRIMARY KEY(col1))
        PARTITION BY RANGE(col1)
        (PARTITION p0 VALUES LESS THAN(100),
        PARTITION p1 VALUES LESS THAN(200),
        PARTITION p2 VALUES LESS THAN(300));
    ```

5. Create a global index `idx1_test4_tbl2` on the table `test4_tbl2`.

    ```sql
    CREATE INDEX idx1_test4_tbl2 ON test4_tbl2 (col2) GLOBAL;
    ```

## References

* [enable_auto_split](../../../../800.configuration-items-and-system-variables/100.system-configuration-items/400.tenant-level-configuration-items/2350.enable_auto_split.md)
* [auto_split_tablet_size](../../../../800.configuration-items-and-system-variables/100.system-configuration-items/400.tenant-level-configuration-items/450.auto_split_tablet_size.md)
* [global_index_auto_split_policy](../../../../800.configuration-items-and-system-variables/100.system-configuration-items/400.tenant-level-configuration-items/3350.global_index_auto_split_policy.md)
* [ALTER TABLE](../../../../500.sql-reference/100.sql-syntax/200.common-tenant-of-mysql-mode/600.sql-statement-of-mysql-mode/1600.alter-table-of-mysql-mode.md)