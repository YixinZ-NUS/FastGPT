| Description   |                 |
|---------------|-----------------|
| keywords      |                 |
| dir-name      |                 |
| dir-name-en   |                 |
| tenant-type   | Oracle Mode     |
|machine-translation||

# Hierarchical query

A hierarchical query is a special query that can present hierarchical data in a hierarchical order.

Hierarchical data refers to data with a hierarchical relationship in relational tables. This type of relationship is very common in our daily life. Here are some examples:

* Relationship between team leaders and team members

* Relationship between upper-level and lower-level departments in enterprises

* Relationship between source and destination web pages in page jumping scenarios

## Limitations and considerations

You cannot use the `FOR UPDATE` clause in a hierarchical query in the following scenarios:

* A subquery uses the `DISTINCT` keyword or an aggregate function.
* A Common Table Expression (CTE) is used. In other words, you cannot use the `FOR UPDATE` clause in a `SELECT` query if the query already contains a `WITH ... AS ...` clause. For more information about the `WITH ... AS ...` clause, see [WITH CLAUSE](../900.sql-statement-of-oracle-mode/200.dml-of-oracle-mode/500.select-of-oracle-mode/300.select-with-clause-of-oracle-mode.md).

For normal operations and performance optimization of the database, do not use the `FOR UPDATE` clause in the preceding two scenarios.

## Syntax

The syntax of the `SELECT` statement for a simple hierarchical query is as follows:

```sql
SELECT [LEVEL], column, expr... FROM table [WHERE condition]
[ START WITH start_expression ] CONNECT BY [NOCYCLE] { PRIOR child_expr = parent_expr | parent_expr = PRIOR child_expr } [ ORDER SIBLINGS BY ...]
[ GROUP BY ... ] [ HAVING ... ] [ ORDER BY ... ]
[FOR UPDATE [OF column] [ {NOWAIT | WAIT integer | SKIP LOCKED } ] ]
```

For more information about the `SELECT` statement, see [SIMPLE SELECT](../900.sql-statement-of-oracle-mode/200.dml-of-oracle-mode/500.select-of-oracle-mode/100.simple-select-of-oracle-mode.md).

## Parameters

| Parameter | Description |
|--------------------|------------------------|
| LEVEL              | The level, namely, the hierarchy of the node. It is a pseudocolumn. Counting from the start point of a query, the level starts from 1, and so forth. |
| CONNECT_BY_ISLEAF  | Indicates whether the current row is a leaf node. It is a pseudocolumn. Valid values: <ul><li>`0`: indicates that the current row is not a leaf node. </li><li>`1`: indicates that the current row is a leaf node. </li></ul>|
| CONNECT_BY_ISCYCLE | Indicates whether the current row is in a cycle. It is a pseudocolumn. Valid values: <ul><li>`0`: indicates that the current row is not in a cycle. </li><li>`1`: indicates that the current row is in a cycle. </li></ul>|
| CONNECT_BY_ROOT    | `CONNECT_BY_ROOT` is a unary operator, indicating that the column in the parameter comes from the root node of the hierarchical query. It has the same precedence as the unary operators `+` and `-`. |
| condition          | The condition. |
| CONNECT BY         | The method to determine the parent-child relationship. An equality expression is usually used. Other expressions are also supported. |
| START WITH         | The root row in the hierarchical query. |
| PRIOR              | `PRIOR` is a unary operator, indicating that the column in the parameter comes from the parent row. It has the same precedence as the unary operators `+` and `-`.               |
| NOCYCLE            | If this keyword is specified, the result can still be returned even if it contains a cycle. The `CONNECT_BY_ISCYCLE` pseudocolumn can be used to specify where the cycle occurs. Otherwise, an error is returned. |
| ORDER SIBLINGS BY  | The sorting order for rows of siblings of the same parent. |
| FOR UPDATE           | Optional. Adds an exclusive lock on all the rows in the query results to prevent other concurrent transactions from changing or reading the rows in some transaction isolation levels. <ul><li><code>OF column</code>: locks the rows of only a particular table (the table where the column specified by the <code>column</code> keyword is located) in multi-table joins. </li><li><code>NOWAIT</code>: immediately locks rows in the query result set. If any row in the result set is locked by another session, the query fails afterward. </li><li><code>WAIT integer</code>: waits for a period specified by <code>Integer</code> before locking the rows in the query result set. If any row in the result set has been locked by another session, the query fails afterward. </li><li><code>SKIP LOCKED</code>: skips the rows in the result set that are locked by another session and returns the unlocked rows. <main id="notice" type='notice'><h4>Notice</h4><p><code>SKIP LOCKED</code> is not supported in a multi-table join. </p></main> </li></ul>|

## Execution process

Before you take use of a hierarchical query, you must understand its execution process. The following describes the general execution process of a hierarchical query:

1. Execute the `SCAN` or `JOIN` operation after the `FROM` clause.

2. Generate a hierarchical relationship based on `START WITH` and `CONNECT BY`.

   The procedure for generating a hierarchical relationship is as follows:

   1. Obtain the root rows based on the expression in `START WITH`.

   2. Select the child rows of each root row based on the expression in `CONNECT BY`.

3. Use the child rows generated in Step 2 as the new root rows and generate child rows for them. Repeat these steps cyclically until no new rows are generated.

4. Execute the rest clauses such as `WHERE`, `GROUP`, and `ORDER BY` based on the general query execution process.

## Examples

1. Create a table named `emp` and insert data into the `emp_id`, `position`, and `mgr_id` columns of the table.

    ```sql
    CREATE TABLE emp(emp_id INT,position VARCHAR(50),mgr_id INT);
    INSERT INTO emp VALUES (1,'Global manager',NULL);
    INSERT INTO emp VALUES (2,'Manager of European region',1);
    INSERT INTO emp VALUES (3,'Manager of Asia-Pacific region',1);
    INSERT INTO emp VALUES (4,'Manager of Americas region',1);
    INSERT INTO emp VALUES (5,'Manager of Italy region',2);
    INSERT INTO emp VALUES (6,'Manager of France region',2);
    INSERT INTO emp VALUES (7,'Manager of China region',3);
    INSERT INTO emp VALUES (8,'Manager of South Korea region',3);
    INSERT INTO emp VALUES (9,'Manager of Japan region',3);
    INSERT INTO emp VALUES (10,'Manager of US region',4);
    INSERT INTO emp VALUES (11,'Manager of Canada region',4);
    INSERT INTO emp VALUES (12,'Manager of Beijing, China region',7);
    ```

    In the preceding table, the `position` column has a clear hierarchical relationship.

    <!-- ![Hierarchical query](https://help-static-aliyun-doc.aliyuncs.com/assets/img/zh-CN/2345220461/p371444.png)  -->

2. Execute the following statement to present the results in a hierarchical structure:

    ```sql
    SELECT emp_id, mgr_id, position, level
    FROM emp
    START WITH mgr_id IS NULL
        CONNECT BY PRIOR emp_id = mgr_id;
    ```

    The return result is as follows:

    ```shell
    +--------+--------+--------------------+-------+
    | EMP_ID | MGR_ID | POSITION           | LEVEL |
    +--------+--------+--------------------+-------+
    |      1 |   NULL | Global manager           |     1 |
    |      2 |      1 | Manager of Europe region         |     2 |
    |      5 |      2 | Manager of Italy region       |     3 |
    |      6 |      2 | Manager of France region         |     3 |
    |      3 |      1 | Manager of Asia-Pacific region         |     2 |
    |      7 |      3 | Manager of China region         |     3 |
    |     12 |      7 | Manager of Beijing, China region         |     4 |
    |      8 |      3 | Manager of South Korea region         |     3 |
    |      9 |      3 | Manager of Japan region         |     3 |
    |      4 |      1 | Manager of Americas region         |     2 |
    |     10 |      4 | Manager of US region         |     3 |
    |     11 |      4 | Manager of Canada region       |     3 |
    +--------+--------+--------------------+-------+
    12 rows in set
    ```

3. Execute the following statement to query the hierarchical structure of the Asia-Pacific region and use the `FOR UPDATE` clause to lock the query results:

    ```sql
    SELECT emp_id, mgr_id, position, LEVEL
    FROM emp
    START WITH position = 'Manager of Asia-Pacific region'
        CONNECT BY PRIOR emp_id = mgr_id
    FOR UPDATE;
    ```

    The return result is as follows:

    ```shell
    +--------+--------+-----------------+-------+
    | EMP_ID | MGR_ID | POSITION        | LEVEL |
    +--------+--------+-----------------+-------+
    |      3 |      1 | Manager of Asia-Pacific region      |     1 |
    |      7 |      3 | Manager of China region      |     2 |
    |     12 |      7 | Manager of Beijing, China region      |     3 |
    |      8 |      3 | Manager of South Korea region      |     2 |
    |      9 |      3 | Manager of Japan region      |     2 |
    +--------+--------+-----------------+-------+
    5 rows in set
    ```

## References

* [SIMPLE SELECT](../900.sql-statement-of-oracle-mode/200.dml-of-oracle-mode/500.select-of-oracle-mode/100.simple-select-of-oracle-mode.md)
* [WITH CLAUSE](../900.sql-statement-of-oracle-mode/200.dml-of-oracle-mode/500.select-of-oracle-mode/300.select-with-clause-of-oracle-mode.md)
* [Use the SELECT FOR UPDATE statement to lock query results](../../../../../300.develop/200.application-development-of-oracle-mode/500.read-data-of-oracle-mode/300.use-operators-and-functions-in-query-of-oracle-mode/1000.lock-query-result-select-for-update-of-oracle-mode.md)
