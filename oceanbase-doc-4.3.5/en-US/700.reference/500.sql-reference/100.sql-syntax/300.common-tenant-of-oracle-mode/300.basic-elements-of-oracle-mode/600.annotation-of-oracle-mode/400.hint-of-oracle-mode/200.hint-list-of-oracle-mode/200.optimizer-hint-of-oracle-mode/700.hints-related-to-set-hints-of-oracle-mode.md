| Description   |                 |
|---------------|-----------------|
| keywords      |                 |
| dir-name      |Set Hint         |
| dir-name-en   |Set Hint         |
| tenant-type   | Oracle Mode     |
|machine-translation||

# Optimized hints: Set hint

Control the behavior of set operations.

The set hints cannot be specified after the set operation clauses because the clauses do not provide a position to specify hints. You must use the qb name to specify the set operation to which a set hint applies. For more information about the use of a set hint, see the Examples column of the hint.


| Hint                        | Description                                                  |
|----------------------------------|-------------------------------------------------------|
|`PQ_SET`                          | Controls the distributed execution mode of set operations.                             |
|`USE_HASH_SET`                    | Instructs the optimizer to use the hash method for set operations. The opposite hint is `NO_USE_HASH_SET`.   |
|`NO_USE_HASH_SET`                 | Instructs the optimizer not to use the hash method for set operations. The opposite hint is `USE_HASH_SET`.     |

## `PQ_SET` hint

The `PQ_SET` hint specifies how data is distributed for set operations during distributed execution.

### Syntax

```sql
PQ_SET ( [ @qb_name ] [left_branch_qb_name] method_list )
```

#### Parameters

- `left_branch_qb_name`: specifies the left branch for the `UNION` or `INTERSECT` set operation.

- `method_list`: specifies the distributed execution method.

The following table describes the data distribution methods and provides examples.

| Data distribution method | outline data hint | Description |
|----------------------|------------------------------|-----------|
| DIST_BASIC_METHOD    | PQ_SET ( @SET$1 ), without adding a hint to the outline |           |
| DIST_PARTITION_WISE  |   PQ_SET ( @SET$1 NONE NONE)   |    |
|DIST_PULL_TO_LOCAL    |  PQ_SET ( @SET$1 LOCAL LOCAL)  |    |
|DIST_SET_RANDOM       |  PQ_SET ( @SET$1 RANDOM NONE)  |  Valid only for `UNION ALL`. |
|DIST_SET_RANDOM       |  PQ_SET ( @SET$1 NONE RANDOM)|  Valid only for `UNION ALL`. |
|DIST_SET_RANDOM       |  PQ_SET ( @SET$1 RANDOM NONE RANDOM)|  Valid only for `UNION ALL`. |
|DIST_HASH_HASH        | PQ_SET ( @SET$1 SEL$1 HASH HASH)|  Valid only for two-branch `UNION` or `INTERSECT`, with SEL$1 as the left branch. |
|DIST_NONE_PARTITION   | PQ_SET ( @SET$1 SEL$2 NONE PARTITION )| Valid only for two-branch `UNION` or `INTERSECT`, with SEL$2 as the left branch. |
|DIST_PARTITION_NONE   | PQ_SET ( @SET$1 SEL$1 PARTITION NONE )|Valid only for two-branch `UNION` or `INTERSECT`, with SEL$1 as the left branch. |

### Examples

The following query demonstrates the use of `pq_set(@set$1 local local)` to specify direct data pullback to the local node for distributed execution, the use of `pq_set(@set$1 sel$2 hash hash)` to specify the `HASH` method for data redistribution and set operation, and the use of `sel$2` as the left branch for the set operation.

```sql
-- Specify the distributed execution method for set operations by using the PQ_SET hint.
CREATE TABLE tp1(c1 INT, c2 INT, c3 INT) PARTITION BY HASH(c1) PARTITIONS 10;
EXPLAIN BASIC SELECT /*+ PQ_SET(@set$1 local local) */ c2, c3 FROM tp1 a UNION SELECT c2, c3 FROM tp1 b;
+------------------------------------------------------------------+
| Query Plan                                                       |
+------------------------------------------------------------------+
| =========================================                        |
| |ID|OPERATOR                   |NAME    |                        |
| -----------------------------------------                        |
| |0 |HASH UNION DISTINCT        |        |                        |
| |1 |├─PX COORDINATOR           |        |                        |
| |2 |│ └─EXCHANGE OUT DISTR     |:EX10000|                        |
| |3 |│   └─PX PARTITION ITERATOR|        |                        |
| |4 |│     └─TABLE FULL SCAN    |A       |                        |
| |5 |└─PX COORDINATOR           |        |                        |
| |6 |  └─EXCHANGE OUT DISTR     |:EX20000|                        |
| |7 |    └─PX PARTITION ITERATOR|        |                        |
| |8 |      └─TABLE FULL SCAN    |B       |                        |
| =========================================                        |
| Outputs & filters:                                               |
| -------------------------------------                            |
|   0 - output([UNION([1])], [UNION([2])]), filter(nil), rowset=16 |
|   1 - output([A.C2], [A.C3]), filter(nil), rowset=16             |
|   2 - output([A.C2], [A.C3]), filter(nil), rowset=16             |
|       dop=1                                                      |
|   3 - output([A.C2], [A.C3]), filter(nil), rowset=16             |
|       force partition granule                                    |
|   4 - output([A.C2], [A.C3]), filter(nil), rowset=16             |
|       access([A.C2], [A.C3]), partitions(p[0-9])                 |
|       is_index_back=false, is_global_index=false,                |
|       range_key([A.__pk_increment]), range(MIN ; MAX)always true |
|   5 - output([B.C2], [B.C3]), filter(nil), rowset=16             |
|   6 - output([B.C2], [B.C3]), filter(nil), rowset=16             |
|       dop=1                                                      |
|   7 - output([B.C2], [B.C3]), filter(nil), rowset=16             |
|       force partition granule                                    |
|   8 - output([B.C2], [B.C3]), filter(nil), rowset=16             |
|       access([B.C2], [B.C3]), partitions(p[0-9])                 |
|       is_index_back=false, is_global_index=false,                |
|       range_key([B.__pk_increment]), range(MIN ; MAX)always true |
+------------------------------------------------------------------+
34 rows in set

EXPLAIN BASIC
SELECT /*+ PQ_SET(@set$1 sel$2 hash hash) */ c2, c3 FROM tp1 a
UNION
SELECT c2, c3 FROM tp1 b;
+-----------------------------------------------------------------------------------+
| Query Plan                                                                        |
+-----------------------------------------------------------------------------------+
| ===============================================                                   |
| |ID|OPERATOR                         |NAME    |                                   |
| -----------------------------------------------                                   |
| |0 |PX COORDINATOR                   |        |                                   |
| |1 |└─EXCHANGE OUT DISTR             |:EX10002|                                   |
| |2 |  └─HASH UNION DISTINCT          |        |                                   |
| |3 |    ├─EXCHANGE IN DISTR          |        |                                   |
| |4 |    │ └─EXCHANGE OUT DISTR (HASH)|:EX10000|                                   |
| |5 |    │   └─PX PARTITION ITERATOR  |        |                                   |
| |6 |    │     └─TABLE FULL SCAN      |B       |                                   |
| |7 |    └─EXCHANGE IN DISTR          |        |                                   |
| |8 |      └─EXCHANGE OUT DISTR (HASH)|:EX10001|                                   |
| |9 |        └─PX PARTITION ITERATOR  |        |                                   |
| |10|          └─TABLE FULL SCAN      |A       |                                   |
| ===============================================                                   |
| Outputs & filters:                                                                |
| -------------------------------------                                             |
|   0 - output([INTERNAL_FUNCTION(UNION([1]), UNION([2]))]), filter(nil), rowset=16 |
|   1 - output([INTERNAL_FUNCTION(UNION([1]), UNION([2]))]), filter(nil), rowset=16 |
|       dop=1                                                                       |
|   2 - output([UNION([1])], [UNION([2])]), filter(nil), rowset=16                  |
|   3 - output([B.C2], [B.C3]), filter(nil), rowset=16                              |
|   4 - output([B.C2], [B.C3]), filter(nil), rowset=16                              |
|       (#keys=2, [B.C2], [B.C3]), dop=1                                            |
|   5 - output([B.C2], [B.C3]), filter(nil), rowset=16                              |
|       force partition granule                                                     |
|   6 - output([B.C2], [B.C3]), filter(nil), rowset=16                              |
|       access([B.C2], [B.C3]), partitions(p[0-9])                                  |
|       is_index_back=false, is_global_index=false,                                 |
|       range_key([B.__pk_increment]), range(MIN ; MAX)always true                  |
|   7 - output([A.C2], [A.C3]), filter(nil), rowset=16                              |
|   8 - output([A.C2], [A.C3]), filter(nil), rowset=16                              |
|       (#keys=2, [A.C2], [A.C3]), dop=1                                            |
|   9 - output([A.C2], [A.C3]), filter(nil), rowset=16                              |
|       force partition granule                                                     |
|  10 - output([A.C2], [A.C3]), filter(nil), rowset=16                              |
|       access([A.C2], [A.C3]), partitions(p[0-9])                                  |
|       is_index_back=false, is_global_index=false,                                 |
|       range_key([A.__pk_increment]), range(MIN ; MAX)always true                  |
+-----------------------------------------------------------------------------------+
39 rows in set
```


## `USE_HASH_SET` hint

The `USE_HASH_SET` hint controls the specific algorithm used for set operations. The reverse operation of this hint is `NO_USE_HASH_SET`.

### Syntax

```sql
/*+ USE_HASH_SET [ ( [ @ qb_name ] ) ] */
```

### Examples

The following query demonstrates how to use the `USE_HASH_SET` hint to enable the `HASH` algorithm for set operations.

```sql
-- Use the USE_HASH_SET hint to enforce the use of the HASH method for set operations.
EXPLAIN BASIC
SELECT /*+ USE_HASH_SET(@set$1) */ c1, c2, c3 FROM t1
UNION
SELECT c1, c2, c3 FROM t1;
+--------------------------------------------------------------------------------+
| Query Plan                                                                     |
+--------------------------------------------------------------------------------+
| =============================                                                  |
| |ID|OPERATOR           |NAME|                                                  |
| -----------------------------                                                  |
| |0 |HASH UNION DISTINCT|    |                                                  |
| |1 |├─TABLE FULL SCAN  |T1  |                                                  |
| |2 |└─TABLE FULL SCAN  |T1  |                                                  |
| =============================                                                  |
| Outputs & filters:                                                             |
| -------------------------------------                                          |
|   0 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=16 |
|   1 - output([T1.C1], [T1.C2], [T1.C3]), filter(nil), rowset=16                |
|       access([T1.C1], [T1.C2], [T1.C3]), partitions(p0)                        |
|       is_index_back=false, is_global_index=false,                              |
|       range_key([T1.__pk_increment]), range(MIN ; MAX)always true              |
|   2 - output([T1.C1], [T1.C2], [T1.C3]), filter(nil), rowset=16                |
|       access([T1.C1], [T1.C2], [T1.C3]), partitions(p0)                        |
|       is_index_back=false, is_global_index=false,                              |
|       range_key([T1.__pk_increment]), range(MIN ; MAX)always true              |
+--------------------------------------------------------------------------------+
18 rows in set
```

## `NO_USE_HASH_SET` hint

The `NO_USE_HASH_SET` hint controls the specific algorithm used for set operations. Its inverse operation is `USE_HASH_SET`.

### Syntax

```sql
/*+ NO_USE_HASH_SET [ ( [ @ qb_name ] ) ] */
```

### Examples

In the following example, the `NO_USE_HASH_SET` hint is used to prevent the HASH algorithm from being used in set operations. OceanBase Database supports both HASH and MERGE algorithms for set operations. Therefore, the actual effect of the `NO_USE_HASH_SET` hint is to use the `MERGE` algorithm for set operations. The `UNION ALL` set operation does not have deduplication semantics and is not controlled by this hint.

```sql
-- Use the NO_USE_HASH_SET hint to guide the optimizer to avoid using the HASH method in set operations.
EXPLAIN BASIC
SELECT /*+ NO_USE_HASH_SET(@set$1) */ c1, c2, c3 FROM t1
UNION
SELECT c1, c2, c3 FROM t1;
+--------------------------------------------------------------------------------+
| Query Plan                                                                     |
+--------------------------------------------------------------------------------+
| ==============================                                                 |
| |ID|OPERATOR            |NAME|                                                 |
| ------------------------------                                                 |
| |0 |MERGE UNION DISTINCT|    |                                                 |
| |1 |├─SORT              |    |                                                 |
| |2 |│ └─TABLE FULL SCAN |T1  |                                                 |
| |3 |└─SORT              |    |                                                 |
| |4 |  └─TABLE FULL SCAN |T1  |                                                 |
| ==============================                                                 |
| Outputs & filters:                                                             |
| -------------------------------------                                          |
|   0 - output([UNION([1])], [UNION([2])], [UNION([3])]), filter(nil), rowset=16 |
|   1 - output([T1.C1], [T1.C2], [T1.C3]), filter(nil), rowset=16                |
|       sort_keys([T1.C1, ASC], [T1.C2, ASC], [T1.C3, ASC])                      |
|   2 - output([T1.C1], [T1.C2], [T1.C3]), filter(nil), rowset=16                |
|       access([T1.C1], [T1.C2], [T1.C3]), partitions(p0)                        |
|       is_index_back=false, is_global_index=false,                              |
|       range_key([T1.__pk_increment]), range(MIN ; MAX)always true              |
|   3 - output([T1.C1], [T1.C2], [T1.C3]), filter(nil), rowset=16                |
|       sort_keys([T1.C1, ASC], [T1.C2, ASC], [T1.C3, ASC])                      |
|   4 - output([T1.C1], [T1.C2], [T1.C3]), filter(nil), rowset=16                |
|       access([T1.C1], [T1.C2], [T1.C3]), partitions(p0)                        |
|       is_index_back=false, is_global_index=false,                              |
|       range_key([T1.__pk_increment]), range(MIN ; MAX)always true              |
+--------------------------------------------------------------------------------+
24 rows in set
```