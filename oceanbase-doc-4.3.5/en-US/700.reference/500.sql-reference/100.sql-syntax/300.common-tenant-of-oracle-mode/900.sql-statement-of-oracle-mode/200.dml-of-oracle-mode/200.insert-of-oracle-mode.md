| Description   |                 |
|---------------|-----------------|
| keywords      |                 |
| dir-name      |                 |
| dir-name-en   |                 |
| tenant-type   | Oracle Mode     |
|machine-translation||

# INSERT

## Purpose

You can use this statement to add one or more records to a table.

## Syntax

```sql
INSERT [hint_options] { single_table_insert | multi_table_insert | overwrite_table_insert};

single_table_insert:
    { INTO insert_table_clause opt_nologging '(' column_list ')' values_clause [{ RETURNING | RETURN } returning_exprs [into_clause]]
    | INTO insert_table_clause opt_nologging '(' ')' values_clause [{ RETURNING | RETURN } returning_exprs [into_clause]]
    | INTO insert_table_clause opt_nologging values_clause [{ RETURNING | RETURN } returning_exprs [into_clause]]
    }

opt_nologging:
    { NOLOGGING | /*EMPTY*/ }

returning_exprs:
    projection_col_name [,projection_col_name ...]

insert_into_clause:
    { INTO into_var_list | BULK COLLECT INTO into_var_list}

into_var_list:
    { USER_VARIABLE | ref_name } [, { USER_VARIABLE | ref_name }...]

values_clause:
    VALUES ({ expr | DEFAULT } [, { expr | DEFAULT } ]...  )

multi_table_insert:
    { ALL { insert_into_clause [ values_clause ] [error_logging_clause] }
    | conditional_insert_clause
    } subquery

conditional_insert_clause:
    [ ALL | FIRST ]
    WHEN condition
    THEN insert_into_clause
    [ values_clause ]
    [ error_logging_clause ]
    [ insert_into_clause [ values_clause ] [ error_logging_clause ] ]...
    [ WHEN condition
        THEN insert_into_clause
        [ values_clause ]
        [ error_logging_clause ]
        [ insert_into_clause [ values_clause ] [ error_logging_clause ] ]...
    ]...
    [ ELSE insert_into_clause
        [ values_clause ]
        [ error_logging_clause ]
        [ insert_into_clause [ values_clause ] [ error_logging_clause ] ]...
    ]

error_logging_clause:
    LOG ERRORS [ INTO [schema.] table_name ] [ (simple_expression) ] [ REJECT LIMIT { integer | UNLIMITED } ]

overwrite_table_insert:
    [/*+PARALLEL(N)*/] OVERWRITE table_name [(list_of_columns)] [PARTITION (partition_name, ...)] select_stmt
```

## Parameters

|    Parameter     |      Description       |
|---------------------------|---------------------------------------------------------------------|
| hint_options | Optional. You can use hints to enable direct load. For more information about hints, see [Overview of hints](../../300.basic-elements-of-oracle-mode/600.annotation-of-oracle-mode/400.hint-of-oracle-mode/100.hint-overview-of-oracle-mode.md). <main id="notice" type='notice'><h4>Notice</h4><p>We recommend that you do not upgrade OceanBase Database while a direct load task is in progress. Otherwise, the direct load task may fail. </p></main> The `INSERT INTO SELECT` statement supports the `APPEND \| DIRECT(bool, int, load_mode)` hint to control the import method. The syntax is `/*+ [APPEND \| DIRECT(bool, int, load_mode)} enable_parallel_dml PARALLEL(N) \| NO_DIRECT */`. The parameters are described as follows:<ul><li><code>APPEND</code>: Equivalent to <code>DIRECT(true, 0)</code> by default. It can also enable online statistics collection (the <code>GATHER_OPTIMIZER_STATISTICS</code> hint). </li><li><code>DIRECT()</code>:<ul><li><code>bool</code>: Indicates whether the data to be written needs to be sorted. The value <code>true</code> indicates that the data needs to be sorted, and the value <code>false</code> indicates that it does not. </li><li><code>int</code>: The maximum number of rows that can be tolerated to be incorrect. </li><li><code>load_mode</code>: Optional. Indicates the direct load mode. The value must be enclosed in single quotation marks. Valid values are as follows:<ul><li><code>full</code>: The default value. Indicates full import. </li><li><code>inc</code>: Indicates incremental import, which supports <code>INSERT</code> and <code>IGNORE</code> semantics. </li><li><code>inc_replace</code>: Indicates incremental import without checking for duplicate primary keys. This is equivalent to incremental import with <code>REPLACE</code> semantics. </li></ul> </li><li><code>enable_parallel_dml parallel(N)</code>: The degree of parallelism for data loading. The default value of <code>N</code> is 4. <main id="notice" type='explain'><h4>Note</h4><p>The <code>enable_parallel_dml</code> hint and the <code>parallel</code> hint must be used together to enable parallel DML. However, if the schema of the target table specifies the table-level degree of parallelism, you only need to specify the <code>enable_parallel_dml</code> hint. </p></main></li></ul><li><code>NO_DIRECT</code>: Forces a single SQL statement to use direct load. If this hint is specified for an SQL statement, other direct load hints in the statement are ignored, and the statement is executed in the normal import mode.  </li></ul>For more information about direct load using the `INSERT INTO SELECT` statement, see [Direct load using the INSERT INTO SELECT statement](../../../../../../620.obap/300.obap-import-data/20.bypass-import/200.full-bypass-import.md). |
| single_table_insert       | Inserts data into a single table.                                                                                                                                                                                                             |
| insert_table_clause       | The table into which the records are inserted, which can be a base table, an updatable view, or a special subquery.                                                                                                                                                                                        |
| opt_nologging             | Minimizes the number of logs generated by an insert.                                                                                                                                                                                                     |
| column_list               | The name of the column into which the records are inserted.                                                                                                                                                                                                         |
| returning_exprs           | Returns the projected column into which the records are inserted.                                                                                                                                                                                                     |
| insert_into_clause        | Inserts, into the specified table, the column into which the records are inserted.                                                                                                                                                                                               |
| multi_table_insert        | Inserts data into multiple tables.                                                                                                                                                                                                             |
| conditional_insert_clause | Conditionally inserts data into multiple tables. <ul><li> `ALL`: traverses all the conditional branches and inserts data into the corresponding tables that meet the condition.   </li><li> `FIRST`: inserts data into the table corresponding to the first conditional branch that is met and ignores the remaining branches. </li></ul> |
| error_logging_clause      | Saves the SQL errors and the values in the columns of affected rows in an error record table.                                                                                                                                                                                    |
| overwrite_table_insert  | Overwrites existing data in the target table or partition with the query results. For more information about how to use the `INSERT OVERWRITE SELECT` statement, see the **Use the INSERT OVERWRITE SELECT statement to insert data** section in the [Insert data](../../../../../../300.develop/200.application-development-of-oracle-mode/400.write-data-of-oracle-mode/100.insert-data-of-oracle-mode-in-develop.md) topic. |
| list_of_columns   | The table columns into which data is to be inserted.                     |
| select_stmt  | The `SELECT` clause. For more information, see [SIMPLE SELECT](500.select-of-oracle-mode/100.simple-select-of-oracle-mode.md). |

  <main id="notice" type='notice'>
    <h4>Notice</h4>
    <p>A special subquery is similar to a subquery that defines an updatable view. These subqueries must not contain complex operators, such as <code>group by</code>, <code>distinct</code>, and <code>window functions</code>. </p>
  </main>

## Examples

Sample tables and their data are defined as follows:

```sql
obclient> CREATE TABLE tbl1(col1 INT PRIMARY KEY, col2 INT,col3 INT);
Query OK, 0 rows affected
```

* Single-table insert: Insert a row of data into the `tbl1` table.

  ```sql
  obclient> INSERT INTO tbl1 VALUES(1,2,3);
  Query OK, 1 row affected

  obclient> SELECT * FROM tbl1;
  +------+------+------+
  | COL1 | COL2 | COL3 |
  +------+------+------+
  |    1 |    2 |    3 |
  +------+------+------+
  1 row in set
  ```

* Single-table insert: Insert data into the result set of a subquery.

  ```javascript
  obclient>INSERT INTO (SELECT * FROM tbl1) VALUES(1,2,3);
  Query OK, 1 row affected

  obclient> SELECT * FROM tbl1;
  +----+------+------+
  | COL1 | COL2   | COL3   |
  +----+------+------+
  |  1 |    2 |    3 |
  +----+------+------+
  1 row in set
  ```

* Single-table insert: Insert data by using the `RETURNING` clause.

  ```javascript
  obclient> INSERT INTO tbl1 VALUES(1,2,3) RETURNING col1;
  +------+
  | COL1 |
  +------+
  |    1 |
  +------+
  1 row in set

  obclient> SELECT * FROM tbl1;
  +------+------+------+
  | COL1 | COL2 | COL3 |
  +------+------+------+
  |    1 |    2 |    3 |
  +------+------+------+
  1 row in set
  ```

* General multi-table insert: Insert one row `(1,1,1)` into the `tbl1` table and one row `(2,2,2)` into the `tbl2` table when the `tbl3` table contains at least one row.

  ```sql
  obclient> INSERT ALL INTO tbl1 VALUES(1,1,1)
                                      INTO tbl2 VALUES(2,2,2)
                  SELECT * FROM tbl3 WHERE ROWNUM< 2;
  Query OK, 2 rows affected
  Records: 2  Duplicates: 0  Warnings: 0

  obclient> SELECT * FROM tbl1;
  +------+------+------+
  | COL1 | COL2 | COL3 |
  +------+------+------+
  |    1 |    1 |    1 |
  +------+------+------+
  1 row in set

  obclient> SELECT * FROM tbl2;
  +------+------+------+
  | COL1 | COL2 | COL3 |
  +------+------+------+
  |    2 |    2 |    2 |
  +------+------+------+
  1 row in set
  ```

* Conditional multi-table insert: Use `INSERT ALL` to insert one row `(1,1,1)` into the `tbl1` table when the value of `col2` in the `tbl` table is greater than `1`. Insert one row `(2,2,2)` into the `tbl2` table when the value of `col3` in the `tbl` table is greater than `1`. Insert one row `(3,3,3)` into the `tbl1` table when both conditions are not met.

  ```sql
  obclient> INSERT INTO tbl VALUES(1,2,3);
  Query OK, 1 row affected

  obclient>INSERT ALL
                WHEN col2 > 1 THEN INTO tbl1 VALUES(1,1,1)
                WHEN col3 > 1 THEN INTO tbl2 VALUES(2,2,2)
                ELSE INTO tbl1 VALUES(3,3,3) SELECT col2,col3 FROM tbl;
  Query OK, 2 rows affected
  Records: 2  Duplicates: 0  Warnings: 0

  obclient> SELECT * FROM tbl1;
  +----+------+------+
  | COL1 | COL2   | COL3   |
  +----+------+------+
  |  1 |    1 |    1 |
  +----+------+------+
  1 row in set

  obclient> SELECT * FROM tbl2;
  +----+------+------+
  | COL1 | COL2   | COL3   |
  +----+------+------+
  |  2 |    2 |    2 |
  +----+------+------+
  1 row in set
  ```

* Conditional multi-table insert: Use `INSERT FIRST` to insert one row `(1,1,1)` into the `tbl1` table and one row `(4,4,4)` into the `tbl2` table when the value of `col2` in the `tbl` table is greater than `1`. Insert one row `(2,2,2)` into the `tbl2` table when the value of `col3` in the `tbl` table is greater than `1`. Insert one row `(3,3,3)` into the `tbl1` table when both conditions are not met.

  ```sql
  obclient>INSERT INTO tbl VALUES(1,2,3);
  Query OK, 1 row affected

  obclient>INSERT ALL
                WHEN col2 > 1 THEN INTO tbl1 VALUES(1,1,1) INTO tbl2 VALUES(4,4,4)
                WHEN col3 > 1 THEN INTO tbl2 VALUES(2,2,2)
                ELSE INTO tbl1 VALUES(3,3,3) SELECT col2,col3 FROM tbl;
  Query OK, 3 rows affected
  Records: 3  Duplicates: 0  Warnings: 0

  obclient> SELECT * FROM tbl1;
  +----+------+------+
  | COL1 | COL2   | COL3   |
  +----+------+------+
  |  1 |    1 |    1 |
  +----+------+------+
  1 row in set

  obclient> SELECT * FROM tbl2;
  +------+------+------+
  | COL1   | COL2   | COL3   |
  +------+------+------+
  |    4 |    4 |    4 |
  |    2 |    2 |    2 |
  +------+------+------+
  2 rows in set
  ```

* Specify the `load_mode` parameter of the `direct` hint to import data in incremental direct load mode.

  ```sql
  obclient [SYS]> INSERT /*+ direct(true, 0, 'inc_replace') enable_parallel_dml parallel(2) */ INTO tbl2 SELECT * FROM tbl1;
  ```

  The return result is as follows:

  ```sql
  Query OK, 8 rows affected
  Records: 8  Duplicates: 0  Warnings: 0
  ```

## References

* [Insert data](../../../../../../300.develop/200.application-development-of-oracle-mode/400.write-data-of-oracle-mode/100.insert-data-of-oracle-mode-in-develop.md)
* [Import data through direct load by using the INSERT INTO SELECT statement](../../../../../../620.obap/300.obap-import-data/20.bypass-import/200.full-bypass-import.md)
* [SIMPLE SELECT](500.select-of-oracle-mode/100.simple-select-of-oracle-mode.md)
