| Description   |                 |
|---------------|-----------------|
| keywords      |                 |
| dir-name      |                 |
| dir-name-en   |                 |
| tenant-type   | MySQL Mode      |
|machine-translation||

# SELECT

## Purpose

The statement is used to query data from one or more tables.

This topic describes the general syntax of the `SELECT` statement. For more information about other `SELECT` statements, see:

* [JOIN clause](200.join-clause-of-mysql-mode.md)
* [WINDOW clause](300.over-clause-of-mysql-mode.md)
* [UNION clause](400.union-clause-of-mysql-mode.md)
* [SELECT INTO](../8000.select-into-of-mysql-mode.md)

## Privilege requirements

To execute a `SELECT` statement, the current user must have the `SELECT` privilege. For more information about privileges in OceanBase Database, see [Privilege types in MySQL mode](../../../../../../600.manage/500.security-and-permissions/300.access-control/200.user-and-permission/200.permission-of-mysql-mode/100.permission-classification-of-mysql.md).

## Syntax

```sql
select_stmt:
    SELECT [hint_options]
        [{DISTINCT | UNIQUE} | ALL]
        [SQL_CALC_FOUND_ROWS]
        [STRAIGHT_JOIN]
        select_expr_list
        [FROM from_list]
        [WHERE where_condition]
        [GROUP BY group_by_condition_list [WITH ROLLUP]
         | GROUP BY [group_by_condition_list] group_by_summary_option (expression_list)]
        [HAVING having_condition]
        [window_clause]
        [ORDER BY order_by_condition_list]
        [LIMIT limit_clause]
        [lock_option];

select_expr_list:
    select_expr [, select_expr ...]

select_expr:
    *
    | table_name.{* | column_name}
    | table_alias_name.{* | column_name}
    | expr [[AS] column_alias_name]

from_list:
    DUAL
    | table_references

where_condition:
    expression

group_by_condition_list:
    group_by_condition [, group_by_condition ...]

group_by_condition:
    expression [ASC | DESC]

group_by_summary_option:
    GROUPING SETS
    | ROLLUP
    | CUBE

expression_list:
    expression [, expression ...]

having_condition:
    expression

order_by_condition_list:
    order_by_condition [, order_by_condition ...]

order_by_condition:
    expression [ASC | DESC]

limit_clause:
    [offset,] row_count
    | row_count OFFSET offset

lock_option:
    FOR UPDATE [opt_for_update_wait]
    | LOCK IN SHARE MODE

opt_for_update_wait:
    WAIT {decimal | intnum}
    | NOWAIT
    | NO_WAIT
    | SKIP LOCKED
```

## Parameters

| Parameter | Description |
|-----------|-------------|
| select_stmt | The part of the SQL statement that specifies which data to retrieve from the database. |
| hint_options | Optional. Specifies the `hint` option. For more information about hints, see [Optimizer hint](../../../../../1000.performance-tuning-guide/500.sql-optimization/400.sql-optimization/700.manage-execution-plans/100.optimizer-hint.md). |
| {DISTINCT \| UNIQUE} \| ALL | Optional. Specifies whether to return duplicate rows in the result set. <ul><li>`DISTINCT`/`UNIQUE`: indicates that duplicate rows are not returned in the result set. </li><li>`ALL`: indicates that all rows in the query result, including duplicate rows, are returned. The default value is `ALL`. </li></ul>|
| SQL_CACHE \| SQL_NO_CACHE | Optional. Specifies whether to cache the query result. <ul><li>`SQL_CACHE`: indicates that the query result is cached. </li><li>`SQL_NO_CACHE`: indicates that the query result is not cached. </li></ul>|
| SQL_CALC_FOUND_ROWS           | Optional. Records the number of all returned rows in a query that contains a `LIMIT` clause. You can call the `FOUND_ROWS()` function to obtain the total number of rows in the next execution. |
| STRAIGHT_JOIN                 | Optional. Forces the optimizer to join tables in the order specified in the `FROM` clause. This clause is an optimization hint that does not affect the execution result. <main id="notice" type='notice'><h4>Notice</h4><p>OceanBase Database is not fully compatible with the <code>STRAIGHT_JOIN</code> syntax in MySQL. If <code>STRAIGHT_JOIN</code> can explicitly specify the join order of tables, OceanBase Database will execute the command. If <code>STRAIGHT_JOIN</code> cannot determine a unique join order, OceanBase Database will ignore the command. </p></main>|
| select_expr_list              | A list of columns or expressions to be displayed in the query result. For more information about the columns or expressions, see [select_expr](#select_expr). |
| column_name                   | The name of a column. |
| FROM from_list                | Optional. The data source of the query, which can be a table, view, or subquery. For more information about the data source, see [from_list](#from_list). |
| WHERE where_condition         | Optional. The filter condition for the query. For more information, see [where_condition](#where_condition). |
| GROUP BY group_by_condition_list | Optional. Specifies the columns to group the result by. Usually, it is used with aggregate functions. For more information, see [group_by_condition](#group_by_condition). |
| WITH ROLLUP                   | Optional. Aggregates the groups to represent higher-level aggregations (also known as super aggregations) and generates additional rows. |
| GROUP BY [group_by_condition_list] group_by_summary_option (expression_list) | Optional. This parameter is used for advanced grouping and summary operations.<ul><li> `group_by_condition_list`: Optional. Specifies the columns or expressions for grouping. For more information, see [group_by_condition](#group_by_condition). <ul><li>When `group_by_condition_list` is explicitly specified, these columns are treated as fixed grouping conditions. They are combined with the subsequent `group_by_summary_option` to form the final grouping logic. For example, `GROUP BY col1, GROUPING SETS ((col2), (col3))` is equivalent to `GROUP BY GROUPING SETS ((col1, col2), (col1, col3))`.</li><li>If `group_by_condition_list` is not specified, all grouping logic is determined solely by `group_by_summary_option`. In this case, the grouping conditions depend entirely on the columns or expressions in `expression_list`.</li></ul></li><li> `group_by_summary_option`: Represents advanced summary options. For more information, see [group_by_summary_option](#group_by_summary_option). </li><li>`expression_list`: Represents a list of one or more column names, aliases, or expressions. It is used to specify the dimensions for summarization.</li></ul><main id="notice" type='explain'><h4>Note</h4><p>For OceanBase Database V4.3.5, advanced grouping and summary operations are supported starting from V4.3.5 BP1.</p></main> |
| HAVING having_condition       | Optional. Specifies the condition for filtering the grouped result. The `HAVING` clause is similar to the `WHERE` clause, but the `HAVING` clause can use aggregate functions (such as `SUM` and `AVG`). For more information, see [having_condition](#having_condition). |
| window_clause                 | Optional. Specifies the window definition for analytical functions (also known as window functions). For more information about the syntax of the `window_clause`, see [WINDOW clause](300.over-clause-of-mysql-mode.md). |
| ORDER BY order_by_condition_list | Optional. Specifies the columns to sort the result set by. You can specify one or more columns. For more information, see [order_by_condition](#order_by_condition). |
| LIMIT limit_clause            | Optional. Specifies the number of rows (number of rows) to be returned. For more information, see [limit_clause](#limit_clause). |
| lock_option                   | Optional. Specifies to lock the query result. For more information, see [lock_option](#lock_option).|

### select_expr

`select_expr`: specifies the columns or expressions to be included in the query result. Separate multiple expressions or column names with commas (`,`). Valid values are as follows:

* `*`: indicates to select all columns.

    **Here are some examples:**

    1. Create tables `tbl1` and `tbl2`.

        ```sql
        CREATE TABLE tbl1(col1 INT PRIMARY KEY, col2 VARCHAR(20), col3 INT)
          PARTITION BY HASH(col1)
          PARTITIONS 5;
        ```

        ```sql
        CREATE TABLE tbl2(col1 INT PRIMARY KEY, col2 VARCHAR(20), col3 INT);
        ```

    2. Insert test data into the `tbl1` table.

        ```sql
        INSERT INTO tbl1 VALUES(1, 'A1', 1),(2, 'A2', 2),(3, 'A3', 3);
        ```

        ```sql
        INSERT INTO tbl2 VALUES(1, 'A1', 1),(2, 'A2', 22),(3, 'A3', 33);
        ```

    3. View the data in the `tbl1` table.

        ```sql
        SELECT * FROM tbl1;
        ```

        The return result is as follows:

        ```shell
        +------+------+------+
        | col1 | col2 | col3 |
        +------+------+------+
        |    1 | A1   |    1 |
        |    2 | A2   |    2 |
        |    3 | A3   |    3 |
        +------+------+------+
        3 rows in set
        ```

* `table_name.{* | column_name}`: indicates to select all columns or a specific column in a table.

  * `table_name.*`: indicates to select all columns in a table.
  * `table_name.column_name`: indicates to select a specific column in a table.

    **Here are some examples:**

    Read the `col1` data from the `tbl1` table.

    ```sql
    SELECT tbl1.col1 FROM tbl1;
    ```

    The return result is as follows:

    ```shell
    +------+
    | col1 |
    +------+
    |    1 |
    |    2 |
    |    3 |
    +------+
    3 rows in set
    ```

* `table_alias_name.{* | column_name}`: similar to the preceding format, but uses a table alias when selecting columns.

* `expr [[AS] column_alias_name]`: indicates to select an expression and can specify an alias for the selected expression as the name of a column.

  * `expr`: indicates a column name, function, or calculation expression.

    * `expr AS column_alias_name`/`expr column_alias_name`: indicates to select an expression and name it as `column_alias_name`.

  **Here are some examples:**

  Read the `col1` data from the `tbl1` table, calculate the value of `col1+1`, and name the new column `col1_add`. Also, calculate `col3*2` and name the new column `col3_mul`.

  ```sql
  SELECT col1, col1+1 AS col1_add, col3*2 col3_mul FROM tbl1;
  ```

  The return result is as follows:

  ```shell
  +------+----------+----------+
  | col1 | col1_add | col3_mul |
  +------+----------+----------+
  |    1 |        2 |        2 |
  |    2 |        3 |        4 |
  |    3 |        4 |        6 |
  +------+----------+----------+
  3 rows in set
  ```

### from_list

* `DUAL`: indicates a virtual table name. It is usually used to perform some calculations or functions without actual tables.

  **Here are some examples:**

  ```sql
  SELECT 1+1, SYSDATE() FROM DUAL;
  ```

  The return result is as follows:

  ```shell
  +------+---------------------+
  | 1+1  | SYSDATE()           |
  +------+---------------------+
  |    2 | 2024-08-28 15:20:59 |
  +------+---------------------+
  1 row in set
  ```

* `table_references`: a list of table references, which can contain multiple table references separated by commas (`,`). This specifies the data source table list, which can be one or more tables. For more information about the syntax of `table_references`, see [JOIN clause](200.join-clause-of-mysql-mode.md).

### where_condition

`expression`: specifies the condition expression for filtering the rows to be updated.

**Here are some examples:**

Select all rows that meet the conditions `col1 > 1` and `col2 = 'A3'` from the `tbl1` table.

```sql
SELECT * FROM tbl1
  WHERE col1 > 1
  AND col2 = 'A3';
```

The return result is as follows:

```shell
+------+------+------+
| col1 | col2 | col3 |
+------+------+------+
|    3 | A3   |    3 |
+------+------+------+
1 row in set
```

### group_by_condition

`expression [ASC | DESC]`: specifies the condition expression for grouping. You can add `ASC` or `DESC` to control the order of groups in the result set after grouping.

**Here are some examples:**

Query the `col1` and `col2` columns from the `tbl1` table, group the result set by the `col2` column, sum up the `col3` values in each group, and output the result.

```sql
SELECT col1, col2, SUM(col3)
  FROM tbl1
  GROUP BY col2 DESC;
```

The return result is as follows:

```shell
+------+------+-----------+
| col1 | col2 | SUM(col3) |
+------+------+-----------+
|    3 | A3   |         3 |
|    2 | A2   |         2 |
|    1 | A1   |         1 |
+------+------+-----------+
3 rows in set
```

### group_by_summary_option

<main id="notice" type='explain'>
  <h4>Note</h4>
  <p>For OceanBase Database V4.3.5, advanced grouping and summary operations are supported starting from V4.3.5 BP1.</p>
</main>

* `GROUPING SETS`: specifies a custom grouping method that allows specifying multiple grouping combinations. It has the following characteristics:

  * Users can flexibly define the required grouping combinations.
  * The resulting dataset includes only the grouping combinations specified by the user.

  <main id="notice" type='explain'>
    <h4>Note</h4>
    <p><code>GROUP BY GROUPING SETS ((col1), (col2), (col3))</code> is equivalent to <code>GROUP BY GROUPING SETS (col1, col2, col3)</code>. </p>
  </main>

  **Here is an example:**

  ```sql
  SELECT col1, col2, col3, COUNT(*)
  FROM tbl1
  GROUP BY GROUPING SETS ((col1), (col2), (col3));
  ```

  The return result set is as follows:

  ```shell
  +------+------+------+----------+
  | col1 | col2 | col3 | COUNT(*) |
  +------+------+------+----------+
  |    1 | NULL | NULL |        1 |
  |    2 | NULL | NULL |        1 |
  |    3 | NULL | NULL |        1 |
  | NULL | A1   | NULL |        1 |
  | NULL | A2   | NULL |        1 |
  | NULL | A3   | NULL |        1 |
  | NULL | NULL |    1 |        1 |
  | NULL | NULL |    2 |        1 |
  | NULL | NULL |    3 |        1 |
  +------+------+------+----------+
  9 rows in set
  ```

* `ROLLUP`: specifies the hierarchical summarization method. It reduces the number of grouping columns step by step in the order of the grouping columns, generating multi-level summary results. It has the following characteristics:

  * Reduces grouping columns sequentially based on the order of columns in `expression_list` until only the grand total row remains.
  * The result set contains:

    * The detail data of each group.
    * The subtotal data of each group.
    * The total row.

  `ROLLUP` can be considered a special case of `GROUPING SETS`. For example:

    ```sql
    GROUP BY ROLLUP(col1, col2, col3)

    is equivalent to

    GROUP BY GROUPING SETS ((col1, col2, col3), (col1, col2), (col1), ())
    ```

  `ROLLUP` can also be combined with `GROUPING SETS`. For example:

    ```sql
    GROUP BY GROUPING SETS((col2), (col3), ROLLUP(col1, col2, col3))

    is equivalent to

    GROUP BY GROUPING SETS((col2), (col3), (col1, col2, col3), (col1, col2), (col1), ())
    ```

  **Here is an example:**

  ```sql
  SELECT col1, col2, col3, COUNT(*)
  FROM tbl1
  GROUP BY ROLLUP (col1, col2, col3);
  ```

  The return result set is as follows:

  ```shell
  +------+------+------+----------+
  | col1 | col2 | col3 | COUNT(*) |
  +------+------+------+----------+
  |    1 | A1   |    1 |        1 |
  |    1 | A1   | NULL |        1 |
  |    1 | NULL | NULL |        1 |
  |    2 | A2   |    2 |        1 |
  |    2 | A2   | NULL |        1 |
  |    2 | NULL | NULL |        1 |
  |    3 | A3   |    3 |        1 |
  |    3 | A3   | NULL |        1 |
  |    3 | NULL | NULL |        1 |
  | NULL | NULL | NULL |        3 |
  +------+------+------+----------+
  10 rows in set
  ```

* `CUBE`: specifies the multidimensional summarization method. It generates summaries of all possible groupings. It has the following characteristics:

  * The detail data of each group.
  * The summary data of all possible groupings.
  * The total row.

  `CUBE` can be considered a special case of `GROUPING SETS`. For example:

    ```sql
    GROUP BY CUBE(col1, col2, col3)

    is equivalent to

    GROUP BY GROUPING SETS ((col1, col2, col3), (col1, col2), (col1, col3), (col2, col3), (col1), (col2), (col3), ())
    ```

  `CUBE` can also be combined with `GROUPING SETS`. For example:
  
    ```sql
    GROUP BY col1, CUBE(col2, col3), GROUPING SETS((col4), (col5))

    is equivalent to

    GROUP BY GROUPING SETS(
      (col1, col2, col3, col4), (col1, col2, col3, col5),
      (col1, col2, col4), (col1, col2, col5),
      (col1, col3, col4), (col1, col3, col5),
      (col1, col4), (col1, col5))
    ```

  **Here is an example:**

  ```sql
  SELECT col1, col2, col3, COUNT(*)
  FROM tbl1
  GROUP BY CUBE (col1, col2, col3);
  ```

  The return result set is as follows:

  ```shell
  +------+------+------+----------+
  | col1 | col2 | col3 | COUNT(*) |
  +------+------+------+----------+
  | NULL | NULL | NULL |        3 |
  | NULL | NULL |    1 |        1 |
  | NULL | NULL |    2 |        1 |
  | NULL | NULL |    3 |        1 |
  | NULL | A1   | NULL |        1 |
  | NULL | A2   | NULL |        1 |
  | NULL | A3   | NULL |        1 |
  | NULL | A1   |    1 |        1 |
  | NULL | A2   |    2 |        1 |
  | NULL | A3   |    3 |        1 |
  |    1 | NULL | NULL |        1 |
  |    2 | NULL | NULL |        1 |
  |    3 | NULL | NULL |        1 |
  |    1 | NULL |    1 |        1 |
  |    2 | NULL |    2 |        1 |
  |    3 | NULL |    3 |        1 |
  |    1 | A1   | NULL |        1 |
  |    2 | A2   | NULL |        1 |
  |    3 | A3   | NULL |        1 |
  |    1 | A1   |    1 |        1 |
  |    2 | A2   |    2 |        1 |
  |    3 | A3   |    3 |        1 |
  +------+------+------+----------+
  22 rows in set
  ```

### having_condition

`expression`: specifies the condition expression for filtering the grouped result set.

**Here are some examples:**

Query the `col1` and `col2` columns from the `tbl1` table, group the result set by the `col2` column, sum up the `col3` values in each group, and output the rows where the sum is less than `3`.

```sql
SELECT col1, col2, SUM(col3)
  FROM tbl1
  GROUP BY col2
  HAVING SUM(col3) < 3;
```

The return result is as follows:

```shell
+------+------+-----------+
| col1 | col2 | SUM(col3) |
+------+------+-----------+
|    1 | A1   |         1 |
|    2 | A2   |         2 |
+------+------+-----------+
2 rows in set
```

### order_by_condition

`expression [ASC | DESC]`: specifies the condition expression for sorting the result set.

`ASC | DESC`: an optional parameter that specifies the sorting order. Valid values are `ASC` (default) and `DESC`.

**Here are some examples:**

Query the data from the `tbl1` table and output the query result in descending order (`DESC`) of `col3`.

```sql
SELECT * FROM tbl1
  ORDER BY col3 DESC;
```

The return result is as follows:

```shell
+------+------+------+
| col1 | col2 | col3 |
+------+------+------+
|    3 | A3   |    3 |
|    2 | A2   |    2 |
|    1 | A1   |    1 |
+------+------+------+
3 rows in set
```

### limit_clause

* `[offset,] row_count`: the parameters must be integer constants, which are described as follows:

  * `offset`: indicates the number of rows to skip from the start of the result set. The default initial record row offset is 0.
  * `row_count`: indicates the number of rows to return. If you specify only `row_count`, the first `row_count` rows of the result set are returned.

* `row_count OFFSET offset`: indicates to skip the first `offset` rows of the result set and return the next `row_count` rows.

**Here are some examples:**

Query the data from the `tbl1` table and return two rows of the result set starting from the second row.

```sql
SELECT * FROM tbl1
  LIMIT 1, 2;
```

The return result is as follows:

code-placeholder/58898481-9460-462b-979e-74ec2ad3da3

### lock_option

* `FOR UPDATE [opt_for_update_wait]`: indicates to add an exclusive lock to all rows in the query result to prevent concurrent modifications by other transactions or concurrent reads in some transaction isolation levels. For more information about exclusive locks, see [Lock query results SELECT FOR UPDATE](../../../../../../300.develop/100.application-development-of-mysql-mode/500.read-data-of-mysql-mode/300.use-operators-and-functions-in-query-of-mysql-mode/1000.lock-query-results-select-for-update-of-mysql-mode.md).

  * `opt_for_update_wait`: indicates the behavior when a lock is obtained. Valid values are as follows:

    * `WAIT {decimal | intnum}`: indicates to wait for the resources to be released by other transactions for the specified time. If the resources are not released within the specified time, the system returns an error indicating that the resources cannot be obtained. The unit of time is second.
    * `NOWAIT`/`NO_WAIT`: indicates not to wait for the resources to be released by other transactions and directly return an error indicating that the resources cannot be obtained.
    * `SKIP LOCKED`: indicates not to wait for the row locks to be obtained. The query is executed immediately, and the rows that are locked are removed from the result set.

  **Here are some examples:**

  * You can execute `SELECT ... FOR UPDATE` to add row-level locks to a table. If you use the `LIMIT 1` clause, the optimizer will push the operator down to the table scan step and add locks only to the rows returned by `LIMIT`.

      ```sql
      SELECT * FROM tbl1
        LIMIT 1
        FOR UPDATE;
      ```

  * If you use the `ORDER BY` clause to sort the query result, the result is sorted first and then `LIMIT 1` is executed. In this case, locks are added to all selected rows.

      ```sql
      SELECT * FROM tbl1
        ORDER BY col1
        LIMIT 1
        FOR UPDATE;
      ```

* `LOCK IN SHARE MODE`: indicates to obtain a shared lock when querying data to prevent other transactions from writing to the data but allow other transactions to read the data. For more information about shared locks, see [Lock query results LOCK IN SHARE MODE](../../../../../../300.develop/100.application-development-of-mysql-mode/500.read-data-of-mysql-mode/300.use-operators-and-functions-in-query-of-mysql-mode/1100.query-results-lock-in-share-mode.md).

## Examples

### Example of a simple table query

1. Create a table named `test_tbl1`.

    ```sql
    CREATE TABLE test_tbl1(col1 INT PRIMARY KEY, col2 VARCHAR(20), col3 INT);
    ```

2. Insert test data into the `test_tbl1` table.

    ```sql
    INSERT INTO test_tbl1 VALUES (1, 'A1', 10),(2, 'A2', 15),(3, 'A1', 8);
    ```

3. View the data in the `col2` column of the `test_tbl1` table and remove duplicates.

    ```sql
    SELECT DISTINCT col2 FROM test_tbl1;
    ```

    The return result is as follows:

    ```shell
    +------+
    | col2 |
    +------+
    | A1   |
    | A2   |
    +------+
    2 rows in set
    ```

### Example of querying data by using dblink

* Query data from the `number_t` table in the `test` database.

    ```sql
    SELECT * FROM number_t@ob_dblink;
    ```

    The return result is as follows:

    ```shell
    +--------+-------------+---------+---------------------+--------------------------------+
    | c_int  | c_bigint    | c_float |    c_double         |   c_decimal                    |
    +--------+-------------+---------+---------------------+--------------------------------+
    | 214748 | 92233720368 | 3.40282 | 1.7976931348623157  | 123456789123456789.1234567890  |
    +--------+-------------+---------+---------------------+--------------------------------+
    1 row in set
    ```

* Query data from the `number_t` table in the `test` database and join it with the local `number_t` table.

    ```sql
    SELECT a.c_decimal, b.c_double
      FROM number_t a, number_t@ob_dblink b
      WHERE a.c_int = b.c_int;
    ```

    The return result is as follows:

    ```shell
    +--------------------------------+---------------------+
    |   c_decimal                    |    c_double         |
    +---------------------+--------------------------------+
    | 123456789123456789.1234567890  |  1.7976931348623157 |
    +---------------------+--------------------------------+
    1 row in set
    ```

* Query data from the `datetime_t` table in the `mysql` database.

    ```sql
    SELECT * FROM mysql.datetime_t@ob_dblink;
    ```

    The return result is as follows:

    ```shell
    +-------------+------------+---------+----------------------+----------------------+
    | c_date      | c_time     | c_year  | c_datetime           |  c_timestamp         |
    +-------------+------------+---------+-----------------------+---------------------+
    |  2023-04-13 | 12:12:12   |  2078   | 2100-11-01 12:12:13  | 2100-12-01 21:14:15  |
    +-------------+------------+---------+----------------------+----------------------+
    1 row in set
    ```

## References

[Query a single table](../../../../../../300.develop/100.application-development-of-mysql-mode/500.read-data-of-mysql-mode/100.single-table-query-of-mysql-mode.md)