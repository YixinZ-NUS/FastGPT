| Description   |                 |
|---------------|-----------------|
| keywords      |                 |
| dir-name      |                 |
| dir-name-en   |                 |
| tenant-type   | MySQL Mode      |
|machine-translation||

# ALTER TABLE

## Purpose

This statement is used to modify the structure of an existing table. For example, you can use this statement to modify the table name and table attributes, add columns, modify column names and column attributes, and delete columns.

## Syntax

```sql
alter_table_stmt:
    ALTER TABLE [TEMPORARY] table_name alter_table_action_list;

alter_table_action_list:
    alter_table_action [, alter_table_action ...]

alter_table_action:
      ADD [COLUMN] column_definition
          [ opt_position_column ]
    | ADD [COLUMN] (column_definition_list)
    | ADD [CONSTRAINT [constraint_name]] UNIQUE {INDEX | KEY}
          [index_name] index_desc
    | ADD [CONSTRAINT [constraint_name]] FOREIGN KEY
          [index_name] index_desc
          REFERENCES reference_definition
          [match_action][opt_reference_option_list]
    | ADD PRIMARY KEY (column_name)
    | ADD CONSTRAINT [constraint_name] CHECK (expression)[[NOT] ENFORCED]
    | ADD PARTITION (range_partition_list)
    | ADD {INDEX | KEY} [index_name] [index_type] (key_part,...) [index_option_list][index_column_group_option] [algorithm = algorithm_value] [lock = lock_value]
    | ADD FULLTEXT [INDEX | KEY] [index_name](column_name, [column_name ...]) [WITH PARSER tokenizer_option] [PARSER_PROPERTIES[=](parser_properties_list)] [LOCAL]
    | ADD COLUMN GROUP([all columns, ]each column) [DELAYED]
    | ALTER [COLUMN] column_name {
          SET DEFAULT const_value
        | DROP DEFAULT
      }
    | ALTER {CHECK | CONSTRAINT} symbol [NOT] ENFORCED
    | ALTER INDEX index_name
          [VISIBLE | INVISIBLE]
    | CHANGE [COLUMN] column_name column_definition
    | DROP [COLUMN] column_name [, DROP COLUMN column_name ...]
    | DROP {PARTITION | SUBPARTITION} partition_name_list
    | DROP TABLEGROUP
    | DROP FOREIGN KEY fk_name
    | DROP PRIMARY KEY [, ADD PRIMARY KEY (column)]
    | DROP CHECK constraint_name
    | DROP COLUMN GROUP([all columns, ]each column)
    | MODIFY [COLUMN] column_definition
    | RENAME COLUMN old_col_name [TO|AS] new_col_name
    | RENAME [TO|AS] table_name
    | RENAME {INDEX | KEY} old_index_name [TO|AS] new_index_name
    | [SET] table_option_list
    | TRUNCATE {PARTITION | SUBPARTITION} partition_name_list
    | EXCHANGE PARTITION partition_name WITH TABLE origin_table_name WITHOUT VALIDATION
    | REORGANIZE PARTITION partition_name INTO (split_range_partition_list)
    | PARTITION BY {RANGE [COLUMNS]([column_name_list]) [SIZE('size_value')] [range_partition_list]
                   | partition_option}
    | MODIFY PARTITION partition_name ADD SUBPARTITION (add_subpartition_option)
    | FORCE

column_definition_list:
    column_definition [, column_definition ...]

column_definition:
    column_name data_type
    [DEFAULT const_value] [AUTO_INCREMENT]
    [NULL | NOT NULL] [[PRIMARY] KEY] [UNIQUE [KEY]] [COMMENT string_value] [SKIP_INDEX(skip_index_option_list)] [ opt_position_column ]

skip_index_option_list:
    skip_index_option [,skip_index_option ...]

skip_index_option:
    MIN_MAX
    | SUM

opt_position_column:
    FIRST | BEFORE | AFTER column_name

index_desc:
   (column_desc_list) [index_type] [index_option_list]

match_action:
   MATCH {SIMPLE | FULL | PARTIAL}

opt_reference_option_list:
   reference_option [,reference_option ...]

reference_option:
   ON {DELETE | UPDATE} {RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT}

column_desc_list:
    column_desc [, column_desc ...]

column_desc:
     column_name [(length)] [ASC | DESC]

key_part:
    {index_col_name [(length)] | (expr)} [ASC | DESC]

index_type:
    USING BTREE

index_option_list:
    index_option [ index_option ...]

index_option:
     [GLOBAL | LOCAL]
    | block_size
    | compression
    | STORING(column_name_list)
    | COMMENT string_value

index_column_group_option:
    WITH COLUMN GROUP([all columns, ]each column)

algorithm_value:
    default
    | inplace
    | copy
    | instant

lock_value:
    default
    | none
    | shared
    | exclusive

tokenizer_option:
    SPACE
    | NGRAM
    | BENG
    | IK
    | NGRAM2

parser_properties_list:
    parser_properties, [parser_properties]

parser_properties:
    min_token_size = int_value
    | max_token_size = int_value
    | ngram_token_size = int_value
    | ik_mode = 'char_value'
    | min_ngram_size = int_value
    | max_ngram_size = int_value

table_option_list:
    table_option [ table_option ...]

table_option:
      TABLEGROUP = tablegroup_name
    | block_size
    | lob_inrow_threshold [=] num
    | compression
    | AUTO_INCREMENT [=] INT_VALUE
    | COMMENT string_value
    | parallel_clause
    | TABLE_MODE [=] 'table_mode_value'
    | AUTO_INCREMENT_CACHE_SIZE [=] INT_VALUE
    | READ {ONLY | WRITE}
    | DUPLICATE_SCOPE= 'none | cluster'
    | enable_macro_block_bloom_filter [=] {True | False}
    | DYNAMIC_PARTITION_POLICY [=] (dynamic_partition_policy_list)
    | SEMISTRUCT_ENCODING_TYPE [=] 'encoding'

parallel_clause:
    {NOPARALLEL | PARALLEL integer}

table_mode_value:
    NORMAL
    | QUEUING
    | MODERATE
    | SUPER
    | EXTREME

dynamic_partition_policy_list:
    dynamic_partition_policy_option [, dynamic_partition_policy_option ...]

dynamic_partition_policy_option:
    ENABLE = {true | false}
    | PRECREATE_TIME = {'-1' | '0' | 'n {hour | day | week | month | year}'}
    | EXPIRE_TIME = {'-1' | '0' | 'n {hour | day | week | month | year}'}

partition_option:
      PARTITION BY HASH(expression)
      [subpartition_option] PARTITIONS partition_count
    | PARTITION BY KEY([column_name_list])
      [subpartition_option] PARTITIONS partition_count
    | PARTITION BY RANGE {(expression) | COLUMNS (column_name_list)}
      [subpartition_option] (range_partition_list)

subpartition_option:
      SUBPARTITION BY HASH(expression)
      SUBPARTITIONS subpartition_count
    | SUBPARTITION BY KEY(column_name_list)
      SUBPARTITIONS subpartition_count
    | SUBPARTITION BY RANGE {(expression) | COLUMNS (column_name_list)}
      (range_subpartition_list)

split_range_partition_list:
    PARTITION split_partition_name VALUES LESS THAN (value)
    [, PARTITION split_partition_name VALUES LESS THAN (value) ...]
     , PARTITION split_partition_name VALUES LESS THAN (source_value)

range_partition_list:
    range_partition [, range_partition ...]

range_partition:
    PARTITION partition_name
    VALUES LESS THAN {(expression_list) | MAXVALUE}

range_subpartition_list:
    range_subpartition [, range_subpartition ...]

range_subpartition:
    SUBPARTITION subpartition_name
    VALUES LESS THAN {(expression_list) | MAXVALUE}

expression_list:
    expression [, expression ...]

column_name_list:
    column_name [, column_name ...]

partition_name_list:
    partition_name [, partition_name ...]

partition_count | subpartition_count:
    INT_VALUE

add_subpartition_option:
    {SUBPARTITION subpartition_name VALUES LESS THAN range_partition_expr
        [, SUBPARTITION subpartition_name VALUES LESS THAN range_partition_expr] ...}
    | {SUBPARTITION subpartition_name VALUES IN list_partition_expr
        [, SUBPARTITION subpartition_name VALUES IN list_partition_expr] ...}
```

## Parameter description

|                           **Parameter**                           |        **Description**             |
|------------------------------------------------------------|---------------------------------------------------------------------|
| TEMPORARY | Optional. Specifies to modify a temporary table.<main id="notice" type='explain'><h4>Note</h4><p>This parameter is supported since OceanBase Database V4.3.5 BP4.</p></main>|
| ADD \[COLUMN\]                                             | Adds a column. The system supports adding a generated column.     |
| \[FIRST  \| BEFORE \| AFTER column_name\]                  | Specifies whether to make the new column the first column of the table, or to place the new column before or after the `column_name` column. OceanBase Database supports specifying the column position only in the `ADD COLUMN` clause.     |
| CHANGE \[COLUMN\]                                          | Modifies the column name and column definition. You can increase the length of specific character data types such as `VARCHAR`, `VARBINARY`, and `CHAR`.    |
| MODIFY \[COLUMN\]                                          | Modifies the column attributes. |
| ALTER \[COLUMN\] {SET DEFAULT const_value \| DROP DEFAULT} | Modifies the default value of the column.  |
| DROP \[COLUMN\]                                            | Drops a column.<main id="notice" type='notice'><h4>Notice</h4><p>The primary key column cannot be dropped. </p></main>|
| ADD FOREIGN KEY                                            | Adds a foreign key. If you do not specify a foreign key name, the system generates one based on the table name and the current time. (For example, the name of a foreign key created for the `t1` table on August 1, 2021, at 00:00:00 is `t1_OBFK_1627747200000000`). A foreign key can reference data in another table. When the `UPDATE` or `DELETE` operation affects the key values of the matching rows in the parent table, the result depends on the `ON UPDATE` and `ON DELETE` clauses. <ul><li>`CASCADE`: specifies to delete or update the rows in the parent table and automatically delete or update the matching rows in the child table. </li><li>`SET NULL`: specifies to delete or update the rows in the parent table and set the foreign key column in the child table to `NULL`. </li><li>`RESTRICT`: specifies to reject the `DELETE` or `UPDATE` operation on the parent table. </li><li>`NO ACTION`: specifies to delay the check. </li></ul> In addition, the `SET DEFAULT` operation is supported. |
| ADD PRIMARY KEY                                            | Adds a primary key. You can specify one or more columns as the primary key. If multiple columns are specified, they form a composite primary key.               |
|ADD {INDEX \| KEY} |Adds an index. For more information, see [ADD INDEX KEY](#ADD%20INDEX%20KEY).|
| ADD FULLTEXT \[INDEX \| KEY\]                              | Adds a full-text index. For more information, see [Create a full-text index](../../../../300.database-object-management/100.manage-object-of-mysql-mode/500.manage-indexes-of-mysql-mode/200.create-an-index-of-mysql-mode.md). |
| WITH PARSER tokenizer_option                 | Optional. Specifies the tokenizer for the full-text index. For more information, see [tokenizer_option](#tokenizer_option).|
| PARSER_PROPERTIES\[=\](parser_properties_list) | Optional. Specifies the properties of the tokenizer. For more information, see [parser_properties](#parser_properties). <main id="notice" type='explain'><h4>Note</h4><p>For OceanBase Database V4.3.5, the <code>PARSER_PROPERTIES</code> option is supported since V4.3.5 BP1. </p></main>|
| ALTER INDEX                                                | Modifies whether the index is visible. If the index is invisible, the SQL optimizer does not select it.    |
| key_part        | Creates a (function) index. |
| index_col_name  | Specifies the name of the column in the index. Each column name can be followed by `ASC` (ascending) but not by `DESC` (descending). The default is ascending. The sorting method for creating the index is as follows: First, the values of the first column in `index_col_name` are sorted. For records with the same value in the first column, the values of the next column name are sorted. This process continues. |
| expr            | Specifies a valid function index expression, which can be a Boolean expression, such as `c1=c1`. <br>**Notice** OceanBase Database does not support creating a function index on a generated column.             |
| ADD \[PARTITION\]                                          | Adds a partition to a partitioned table.  |
| DROP {PARTITION \| SUBPARTITION}                           | Drops a partition: <ul><li> `PARTITION`: specifies to drop a partition of the RANGE or LIST type. If the specified partition contains subpartitions, they are also dropped. This includes dropping the partition definition and data in the partition, and maintaining the indexes on the partition. </li>   <li> `SUBPARTITION`: specifies to drop a subpartition of the `*-RANGE` or `*-LIST` type. This includes dropping the partition definition and data in the subpartition, and maintaining the indexes on the partition. </li></ul>   Separate multiple partition names with commas. <br> **Notice**  When you drop a partition, make sure that no active transaction or query is running in the partition. Otherwise, an SQL statement error may be returned, or some abnormal situations may occur.   |
| TRUNCATE {PARTITION \| SUBPARTITION}                       | Deletes data in a partition: <ul><li> `PARTITION`: specifies to delete all data in a partition of the RANGE or LIST type. If the specified partition contains subpartitions, all data in the subpartitions is also deleted. This includes maintaining the indexes on the partition. </li>   <li> `SUBPARTITION`: specifies to delete all data in a subpartition of the `*-RANGE` or `*-LIST` type. This includes maintaining the indexes on the partition. </li> </ul>   Separate multiple partition names with commas. <br> **Notice**  When you delete data in a partition, make sure that no active transaction or query is running in the partition. Otherwise, an SQL statement error may be returned, or some abnormal situations may occur. |
| RENAME COLUMN old_col_name TO new_col_name| Renames a column. You can rename a column without changing the column definition.   <main id="notice" type='notice'><h4>Notice</h4> <p><ul><li>If the target name already exists in the table, an error is returned. </li><li> If a column is renamed in a loop, the statement can be executed. For example, <code>ALTER TABLE t1 RENAME COLUMN a to b, RENAME COLUMN b to a;</code>. </li><li> If an index or a foreign key constraint is created on the column to be renamed, <code>RENAME COLUMN</code> can be executed, and the index definition and foreign key constraint will be automatically updated. </li><li> <code>RENAME COLUMN</code> cannot be used in the same <code>ALTER TABLE</code> statement as <code>ADD PARTITION</code> or <code>ALTER COLUMN</code>. </li></ul></p></main>|
| RENAME \[TO\] table_name                                   | Renames a table. <main id="notice" type='notice'><h4>Notice</h4><p>During the <code>RENAME TABLE</code> operation, table locking and read/write defense measures are added, which increases the operation time. To avoid affecting other users' DDL operations, we recommend that you do not perform batch <code>RENAME TABLE</code> operations. </p></main>|
| RENAME {INDEX \| KEY}                                      | Renames an index or a key.   |
| DROP \[TABLEGROUP\]                                        | Drops a table group.  |
| DROP \[FOREIGN KEY\]                                       | Drops a foreign key.  |
| DROP \[PRIMARY KEY\]                                       | Drops a primary key.<main id="notice" type='explain'><h4>Note</h4><p>For the MySQL mode, you cannot drop a primary key in the following cases: <ul><li>The table contains foreign key information as the parent table. </li> <li>The table is a child table, and the primary key column contains a foreign key reference column. </li> </ul> </p>|
| \[SET\] table_option                                       | Sets a table-level attribute. Valid values: <ul><li> `REPLICA_NUM`: specifies the number of table replicas (currently not supported). </li>   <li> `tablegroup_name`: specifies the table group to which the table belongs. </li>   <li> `BLOCK_SIZE`: specifies the microblock size of the table. The default value is `16384`, which is 16 KB. The value range is \[1024,1048576\]. </li>  <li> `lob_inrow_threshold`: specifies the `INROW` threshold. When the size of LOB data exceeds this threshold, the LOB data is stored in the LOB Meta table in the `OUTROW` format. The default value is 4 KB. </li>   <li> `COMPRESSION`: specifies the compression method of the table. The default value is `None`, which indicates that no compression is performed. </li>   <li> `AUTO_INCREMENT`: specifies the next value of an auto-increment column. The value can be increased or decreased. <main id="notice" type='notice'><h4>Notice</h4><p>When you decrease the value of the auto-increment field of a table, note the following points: <br>If the table contains data and the maximum value of the auto-increment column is not less than the new specified <code>AUTO_INCREMENT</code> value, the new <code>AUTO_INCREMENT</code> value will automatically be adjusted to the next value of the existing maximum value of the auto-increment column. For example, if the current maximum value of the auto-increment column is 5 and the current <code>AUTO_INCREMENT</code> value is 8, and you set <code>AUTO_INCREMENT</code> to any value between 0 and 6, after the statement is executed, the actual <code>AUTO_INCREMENT</code> value will be adjusted to 6. </p></main></li>   <li> `comment`: specifies the comment of the table. </li>   <li> `PROGRESSIVE_MERGE_NUM`: specifies the number of progressive merges. The value range is \[0,100\]. </li>   <li> `parallel_clause`: specifies the table-level parallelism. </li> <li> `NOPARALLEL`: specifies a parallelism of `1`, which is the default configuration. </li>   <li> `PARALLEL integer`: specifies the parallelism. The value of `integer` must be greater than or equal to `1`. </li> </ul>     |
| CHECK                                                      | Modifies the `CHECK` constraint. Valid values: <ul><li> `ADD`: specifies to add a new `CHECK` constraint. </li>   <li> `DROP`: specifies to drop the `CHECK` constraint named `constraint_name`. </li>  </ul>  |
| \[NOT\] ENFORCED                                           | Specifies whether to enforce the `CHECK` constraint named `constraint_name`. <ul><li> If this option is omitted or specified as `ENFORCED`, the constraint is created and enforced by default. </li>   <li> If this option is specified as `NOT ENFORCED`, the constraint is created but not enforced. </li> </ul>   |
| ADD COLUMN GROUP([all columns, ]each column) [DELAYED] | Converts the table to a column-store table. The specific description is as follows: <ul><li><code>ADD COLUMN GROUP(all columns, each column)</code>: specifies to convert the table to a hybrid row-column store table. </li><li><code>ADD COLUMN GROUP(each column)</code>: specifies to convert the table to a column-store table. </li><li>`DELAYED`: optional. Specifies to delay (asynchronous) the conversion of the row-store table to a column-store table. After the statement is executed, the storage format in the table definition is modified, but the actual conversion from a row-store table to a column-store table is performed during a major compaction task. This operation does not block the current DML operation and is an online DDL operation. If this option is not specified, the conversion from a row-store table to a column-store table is performed synchronously. <main id="notice" type='notice'><h4>Notice</h4><p><ul><li>At present, you can specify <code>DELAYED</code> only when you want to convert the table to a column-store table (with <code>each column</code>) or a hybrid row-column store table (with <code>all columns, each column</code>). </li><li> After you execute the <code>DELAYED</code> command to convert a row-store table to a column-store table, the query performance may not meet expectations before the baseline data is compacted. This is because no real conversion of the data storage format has been performed. </li></ul></p></main></li></ul>|
| DROP COLUMN GROUP([all columns, ]each column) | Removes the storage format of the table. The specific description is as follows: <ul><li><code>DROP COLUMN GROUP(all columns, each column)</code>: specifies to remove the hybrid row-column store format of the table. </li><li><code>DROP COLUMN GROUP(all columns)</code>: specifies to remove the row-store format of the table. </li><li><code>DROP COLUMN GROUP(each column)</code>: specifies to remove the column-store format of the table. </li></ul>|
| index_column_group_option | Specifies the index options. The specific description is as follows: <ul><li><code>WITH COLUMN GROUP(all columns, each column)</code>: specifies to add a hybrid row-column store index. </li><li><code>WITH COLUMN GROUP(all columns)</code>: specifies to add a row-store index. </li><li><code>WITH COLUMN GROUP(each column)</code>: specifies to add a column-store index. </li></ul>|
| SKIP_INDEX | Modifies the Skip Index attribute of a column. Valid values: <ul><li><code>MIN_MAX</code>: specifies the most commonly used aggregate data type for Skip Index. It stores the maximum value, minimum value, and null count of the indexed column at the index node level. This type of data can accelerate the push-down of filters and `MIN/MAX` aggregates. </li><li> <code>SUM</code>: specifies to accelerate the push-down of numerical `SUM` aggregates. </li></ul>  <main id="notice" type='notice'><h4>Notice</h4><p><ul><li> Skip Index cannot be created for columns of the JSON or spatial data type. </li><li> Skip Index cannot be created for generated columns. </li></ul></p></main>|
| EXCHANGE PARTITION partition_name WITH TABLE origin_table_name | Specifies to exchange a partition. In this statement, `partition_name` specifies the name of the partition in the partitioned table. `origin_table_name` specifies the name of the source table, which can be a non-partitioned table or a partitioned table. <main id="notice" type='explain'><h4>Note</h4><p>For OceanBase Database V4.3.5, data exchange between a partition of a partitioned table and a partition of a non-partitioned table is supported since V4.3.5 BP3. </p></main> For more information, see [Exchange a partition](../../../../300.database-object-management/100.manage-object-of-mysql-mode/300.manage-partitions-of-mysql-mode/1000.exchange-partition-of-mysql-mode.md). |
| TABLE_MODE | Optional. Specifies the threshold and strategy for triggering a major compaction, which controls the behavior of a major compaction after data is compacted. For more information, see [table_mode_value](#table_mode_value). |
| AUTO_INCREMENT_CACHE_SIZE | Specifies the number of cached auto-increment values. The default value is 0, which indicates that this option is not configured. The system uses the tenant-level setting for [auto_increment_cache_size](../../../../800.configuration-items-and-system-variables/200.system-variable/300.global-system-variable/100.auto_increment_cache_size-global.md) as the cache size for the auto-increment column. |
| READ {ONLY \| WRITE} | Specifies the read/write permissions of a table. The specific description is as follows: <ul><li>`READ ONLY`: specifies that the table can be read but cannot be modified or deleted. <main id="notice" type='notice'><h4>Notice</h4><p>The <code>READ ONLY</code> option at the table level does not take effect for users with the <code>SUPER</code> privilege. It takes effect only for regular users. </p></main></li><li>`READ WRITE`: specifies that the table can be read, modified, and deleted. This is the default value. </li></ul> |
| DUPLICATE_SCOPE | Modifies the duplicate table attribute. Valid values: <ul><li>`none`: specifies to convert the current table to a regular table. </li><li>`cluster`: specifies to convert the current table to a duplicate table. </li></ul> For more information, see [Modify the duplicate table attribute](../../../../300.database-object-management/100.manage-object-of-mysql-mode/200.manage-tables-of-mysql-mode/650.change-duplicate-scope-of-mysql-mode.md). |
| enable_macro_block_bloom_filter [=] {True \| False} | Specifies whether to persist the macro block-level Bloom filter. The options are as follows:  <ul><li><code>True</code>: Enables persistence of the macro block-level Bloom filter.</li><li><code>False</code>: Disables persistence of the macro block-level Bloom filter.</li></ul><main id="notice" type='explain'><h4>Note</h4><p>For OceanBase Database V4.3.5, the <code>enable_macro_block_bloom_filter</code> option is supported in the <code>CREATE TABLE</code> statement starting from V4.3.5 BP2.</p></main>|
| DYNAMIC_PARTITION_POLICY \[=\] \(dynamic_partition_policy_list\) | Modifies the dynamic partition management attribute of a table. `dynamic_partition_policy_list` specifies the list of configurable parameters of the dynamic partition strategy. The parameters are separated with commas. For more information, see [dynamic_partition_policy_option](#dynamic_partition_policy_option). <main id="notice" type='explain'><h4>Note</h4><p>For OceanBase Database V4.3.5, the dynamic partition management attribute of a table is supported since V4.3.5 BP2. </p></main> |
| REORGANIZE PARTITION | Specifies to manually split a partition. The related parameters are as follows: <ul><li>`partition_name`: specifies the name of the partition to be split. </li><li>`split_partition_name`: specifies the name of the new partition. </li><li>`value`: specifies the value of the split boundary. The value range of `value` in the partition split statement must be the same as that in the source partition, and the values of `value` must be in ascending order. </li><li>`source_value`: specifies the original value of the split boundary of the partition to be split. That is, the value of the last split boundary definition is the same as that in the source partition. </li></ul> For more information, see [Manually split a partition](../../../../300.database-object-management/100.manage-object-of-mysql-mode/300.manage-partitions-of-mysql-mode/250.partition-splitting-of-mysql-mode/200.manual-partition-splitting-of-mysql-mode.md). <main id="notice" type='notice'><h4>Notice</h4><p>In MySQL mode, the current version supports splitting only one partition into multiple partitions and does not support splitting multiple partitions into multiple partitions. </p></main> |
| PARTITION BY | Modifies the automatic partition attribute or partitioning rule of a table. The related parameters are as follows: <ul><li> `partition_option`: specifies the partitioning rule. For more information, see [Modify the partitioning rule](../../../../300.database-object-management/100.manage-object-of-mysql-mode/300.manage-partitions-of-mysql-mode/300.modify-partition-rules-of-mysql-mode.md). </li><li> `RANGE [COLUMNS]([column_name_list]) [SIZE('size_value')]`: specifies to modify the automatic partition attribute. For more information, see [Modify the automatic partition attribute](../../../../300.database-object-management/100.manage-object-of-mysql-mode/300.manage-partitions-of-mysql-mode/250.partition-splitting-of-mysql-mode/300.automatic-partition-splitting-of-mysql-mode.md). </li></ul> |
| MODIFY PARTITION partition_name ADD SUBPARTITION (add_subpartition_option) | Specifies to add a subpartition. <main id="notice" type='notice'><h4>Notice</h4><p><ul><li> Subpartition addition is not supported for HASH or KEY subpartition types. </li><li> For OceanBase Database V4.3.5, subpartition addition is supported since V4.3.5 BP1. </li></ul></p></main> |
| add_subpartition_option | Specifies the definition of the new subpartition. |
| range_partition_expr    | Specifies the RANGE or RANGE COLUMNS partitioning expression. |
| list_partition_expr     | Specifies the LIST or LIST COLUMNS partitioning expression. |
| FORCE | Specifies to drop the obsolete column. <main id="notice" type='explain'><h4>Note</h4><p><ul><li> For OceanBase Database V4.3.5, dropping obsolete columns is supported since V4.3.5 BP2. </li><li> When some columns are deleted, they still occupy physical storage space even if they are no longer used. To remove these obsolete columns and reclaim the related space, you must drop the obsolete columns. </li></ul></p></main> |
| SEMISTRUCT_ENCODING_TYPE | Optional. Specifies the semi-structured encoding type. Valid values: <ul><li>`''`: specifies not to enable semi-structured encoding. </li><li>`'encoding'`: specifies to enable semi-structured encoding. </li></ul> For more information, see [Use semi-structured encoding](../100.basic-elements-of-mysql-mode/100.data-type-of-mysql-mode/800.json-formatted-data-type-of-mysql-mode/200.create-a-json-value-of-mysql-mode.md). |

### ADD INDEX KEY

* `ADD {INDEX | KEY} [index_name] [index_type] (key_part,...) [index_option_list][index_column_group_option] [algorithm] [lock]`
  * `INDEX | KEY` : Specifies the key or index for the created table. These two keywords are equivalent.
  * `index_name`: Optional. Specifies the index name. If no index name is specified, the first column referenced by the index is used as the index name. If the index name is duplicated, the index name is specified as underscore (_) plus the sequence number.
  * `index_type`: Optional. Specifies the index type.
  * `key_part`: Specifies the column name or expression to be included in the index.
  * `index_option`: Optional. Specifies the index options.
  * `algorithm`: Specifies the underlying algorithm type used to execute DDL operations (such as adding an index).<main id="notice"type='notice'><h4>Notice</h4><p>In the current version, the `algorithm` parameter is for compatibility with MySQL syntax and has no practical effect.</p></main>
  * `lock`: Specifies the table lock level applied during DDL operations, controlling the granularity of concurrent access.<main id="notice"type='notice'><h4>Notice</h4><p>In the current version, the `lock` parameter is for compatibility with MySQL syntax and has no practical effect.</p></main>

### table_mode_value

<main id="notice" type='explain'>
  <h4>Note</h4>
  <p>In the following <code>TABLE_MODE</code> modes, except for <code>NORMAL</code>, all other modes represent a <code>QUEUING</code> table. This is the most basic table type. The following modes (excluding <code>NORMAL</code>) indicate more aggressive compaction strategies. </p>
</main>

* `NORMAL`: the default value, indicating normal. In this mode, the probability of triggering a major compaction after a minor compaction is very low.
* `QUEUING`: in this mode, the probability of triggering a major compaction after a minor compaction is low.
* `MODERATE`: indicating moderate. In this mode, the probability of triggering a major compaction after a minor compaction is moderate.
* `SUPER`: indicating super. In this mode, the probability of triggering a major compaction after a minor compaction is high.
* `EXTREME`: indicating extreme. In this mode, the probability of triggering a major compaction after a minor compaction is high.

For more information about compaction, see [Adaptive compaction](../../../../200.system-management/500.manage-data-storage/200.merge-management/320.adaptive-compaction.md).

### tokenizer_option

* `SPACE`: the default value, which specifies to split text by spaces. You can specify the following parameters:

  |        Property      | Value range |
  |------------------|---------|
  | min_token_size   | [1, 16] |
  | max_token_size   | [10, 84]|

* `NGRAM`: specifies to split text by using the N-Gram (Chinese) tokenizer. You can specify the following parameters:

  |        Property      | Value range |
  |------------------|---------|
  | ngram_token_size | [1, 10] |

* `NGRAM2`: specifies to split text into continuous characters whose lengths range from `min_ngram_size` to `max_ngram_size`. You can specify the following parameters:

  |        Property      | Value range |
  |------------------|---------|
  | min_ngram_size   | [1, 16] |
  | max_ngram_size   | [1, 16] |

  <main id="notice" type='explain'>
    <h4>Note</h4>
    <p>For OceanBase Database V4.3.5, the <code>NGRAM2</code> tokenizer is supported since V4.3.5 BP2. </p>
  </main>

* `BENG`: specifies to split text by using the basic English tokenizer. You can specify the following parameters:

  |        Parameter      | Value range |
  |------------------|---------|
  | min_token_size   | [1, 16] |
  | max_token_size   | [10, 84]|

* `IK`: specifies to split text by using the Chinese IK tokenizer. Only the `utf-8` character set is supported. You can specify the following parameters:

  |        Property      | Value range |
  |------------------|---------|
  | ik_mode          | <ul><li>`smart`</li><li>`max_word`</li></ul>|

  <main id="notice" type='explain'>
    <h4>Note</h4>
    <p>For OceanBase Database V4.3.5, the <code>IK</code> tokenizer is supported since V4.3.5 BP1. </p>
  </main>

You can call the [TOKENIZE](../400.functions-of-mysql-mode/960.text-processing-functions-of-mysql-mode/200.tokenize-of-mysql-mode.md) function to view the tokenization results of text in JSON format by using the specified tokenizer.

### parser_properties

* `min_token_size`: the minimum token length. The default value is 3, and the value range is 1 to 16.

* `max_token_size`: the maximum token length. The default value is 84, and the value range is 10 to 84.

* `ngram_token_size`: the token length of the `NGRAM` tokenizer. This parameter is valid only for the `NGRAM` tokenizer. The default value is 2, and the value range is 1 to 10.

* `ik_mode`: the mode of the `IK` tokenizer. Valid values: `smart` and `max_word`.

  * `smart`: the default value. This mode specifies to use the words in the dictionary to improve the accuracy of tokenization and prioritize the boundaries of the words in the dictionary, which may reduce unnecessary expansion.
  * `max_word`: this mode specifies to identify the words defined in the dictionary but does not affect the maximum expansion of tokenization. Even if the dictionary defines a word, the `max_word` mode will still try to split the text into more words.

* `min_ngram_size`: the minimum token length. The value range is [1,16].

* `max_ngram_size`: the maximum token length. The value range is [1,16].

**Here is an example:**

1. Create a table named `tbl1`.

   ```sql
   CREATE TABLE tbl1 (col1 VARCHAR(200), col2 TEXT);
   ```

2. Add a full-text index named `fidx` to the `tbl1` table.

   ```sql
   ALTER TABLE tbl1 ADD FULLTEXT INDEX fidx(col2) WITH PARSER ik PARSER_PROPERTIES=(ik_mode='max_word');
   ```

### dynamic_partition_policy_option

* `ENABLE = {true | false}`: specifies whether to enable dynamic partition management. Valid values are as follows:

  * `true`: specifies to enable dynamic partition management. This value is the default.
  * `false`: specifies to disable dynamic partition management.

* `PRECREATE_TIME = {'-1' | '0' | 'n {hour | day | week | month | year}'}`: specifies the precreate time. A dynamic partition management job is scheduled, and partitions are precreated such that **the maximum partition upper bound > now() + precreate_time**. Valid values are as follows:

  * `-1`: specifies not to precreate any partitions. This value is the default.
  * `0`: specifies to precreate only the current partition.
  * `n {hour | day | week | month | year}`: specifies to precreate partitions within the specified time span. For example, `3 hour` specifies to precreate partitions within the last 3 hours.

  <main id="notice" type='explain'>
    <h4>Note</h4>
    <p><ul><li>When multiple partitions are to be precreated, the interval between partition boundaries is <code>TIME_UNIT</code>.</li><li>The first precreated partition boundary is the ceiling of the maximum existing partition boundary by <code>TIME_UNIT</code>.</li></ul></p>
  </main>

* `EXPIRE_TIME = {'-1' | '0' | 'n {hour | day | week | month | year}'}`: specifies the partition expiration time. A dynamic partition management job is scheduled, and all partitions whose upper bound is earlier than **now() - expire_time** are deleted. Valid values are as follows:

  * `-1`: specifies that partitions never expire. This value is the default.
  * `0`: specifies that all partitions except the current one expire.
  * `n {hour | day | week | month | year}`: specifies the partition expiration time. For example, `1 day` specifies that partitions expire after 1 day.

For more information about how to modify a dynamic partition table, see [Modify a dynamic partition table](../../../../300.database-object-management/100.manage-object-of-mysql-mode/300.manage-partitions-of-mysql-mode/260.dynamic-partition-of-mysql-mode/400.modify-dynamic-partition-table-of-mysql-mode.md).

**Here is an example:**

```sql
ALTER TABLE tbl2 SET DYNAMIC_PARTITION_POLICY(
    ENABLE = true,
    PRECREATE_TIME = '1 day',
    EXPIRE_TIME = '-1'
);
```

## Example

### Add and drop columns

Create a sample table named `tbl1` and execute the `DESCRIBE` command to view the table information.

```sql
obclient> CREATE TABLE tbl1 (c1 INT(11) PRIMARY KEY,c2 VARCHAR(50));
Query OK, 0 rows affected

obclient> DESCRIBE tbl1;
+-------+------------+----------+--------+---------+-------+
| Field | Type       | Null     | Key    | Default | Extra |
+-------+------------+----------+--------+---------+-------+
| c1    | int(11)    | NO       | PRI    | NULL    |       |
| c2    | varchar(50)| YES      |        | NULL    |       |
+-------+------------+----------+--------+---------+-------+
```

* Add the `c3` column and execute the `DESCRIBE` command to view the table information.

  ```sql
  obclient> ALTER TABLE tbl1 ADD c3 INT;
  Query OK, 1 row affected

  obclient> DESCRIBE tbl1;
  +-------+------------+----------+--------+---------+-------+
  | Field | Type       | Null     | Key    | Default | Extra |
  +-------+------------+----------+--------+---------+-------+
  | c1    | int(11)    | NO       | PRI    | NULL    |       |
  | c2    | varchar(50)| YES      |        | NULL    |       |
  | c3    | int(11)    | YES      |        | NULL    |       |
  +-------+------------+----------+--------+---------+-------+
  3 row affected
  ```

* Drop the `c3` column and execute the `DESCRIBE` command to view the table information.

  ```sql
  obclient> ALTER TABLE tbl1 DROP c3;
  Query OK, 1 row affected

  obclient> DESCRIBE tbl1;
  +-------+------------+----------+--------+---------+-------+
  | Field | Type       | Null     | Key    | Default | Extra |
  +-------+------------+----------+--------+---------+-------+
  | c1    | int(11)    | NO       | PRI    | NULL    |       |
  | c2    | varchar(50)| YES      |        | NULL    |       |
  +-------+------------+----------+--------+---------+-------+
  2 row affected
  ```

* Rename the `c2` column in the `tbl1` table to `c3` and execute the `DESCRIBE` command to view the table information.

  ```sql
  obclient> ALTER TABLE tbl1 CHANGE COLUMN c2 c3 VARCHAR(50);
  Query OK, 1 row affected

  obclient> DESCRIBE tbl1;
  +-------+------------+----------+--------+---------+-------+
  | Field | Type       | Null     | Key    | Default | Extra |
  +-------+------------+----------+--------+---------+-------+
  | c1    | int(11)    | NO       | PRI    | NULL    |       |
  | c3    | varchar(50)| YES      |        | NULL    |       |
  +-------+------------+----------+--------+---------+-------+
  2 rows affected
  ```

* Add the `c4` column to the `tbl1` table and set it as the first column of the table, and execute the `DESCRIBE` command to view the table information.

  ```sql
  obclient> ALTER TABLE tbl1 ADD COLUMN c4 INTEGER FIRST;
  Query OK, 1 row affected

  obclient> DESCRIBE tbl1;
  +-------+------------+----------+--------+---------+-------+
  | Field | Type       | Null     | Key    | Default | Extra |
  +-------+------------+----------+--------+---------+-------+
  | c4    | int(11)    | YES      |        | NULL    |       |
  | c1    | int(11)    | NO       | PRI    | NULL    |       |
  | c3    | varchar(50)| YES      |        | NULL    |       |
  +-------+------------+----------+--------+---------+-------+
  3 row affected
  ```

* Add the `c2` column after the `c1` column and execute the `DESCRIBE` command to view the table information.

  ```sql
  obclient> ALTER TABLE tbl1 ADD COLUMN c2 INTEGER AFTER c1;
  Query OK, 1 row affected

  obclient> DESCRIBE tbl1;
  +-------+------------+----------+--------+---------+-------+
  | Field | Type       | Null     | Key    | Default | Extra |
  +-------+------------+----------+--------+---------+-------+
  | c4    | int(11)    | YES      |        | NULL    |       |
  | c1    | int(11)    | NO       | PRI    | NULL    |       |
  | c2    | int(11)    | YES      |        | NULL    |       |
  | c3    | varchar(50)| YES      |        | NULL    |       |
  +-------+------------+----------+--------+---------+-------+
  4 row affected
  ```

* Add the `c5` column before the `c4` column and execute the `DESCRIBE` command to view the table information.

  ```sql
  obclient> ALTER TABLE tbl1 ADD COLUMN c5 INT BEFORE c4;
  Query OK, 1 row affected

  obclient> DESCRIBE tbl1;
  +-------+------------+----------+--------+---------+-------+
  | Field | Type       | Null     | Key    | Default | Extra |
  +-------+------------+----------+--------+---------+-------+
  | c5    | int(11)    | YES      |        | NULL    |       |
  | c4    | int(11)    | YES      |        | NULL    |       |
  | c1    | int(11)    | NO       | PRI    | NULL    |       |
  | c2    | int(11)    | YES      |        | NULL    |       |
  | c3    | varchar(50)| YES      |        | NULL    |       |
  +-------+------------+----------+--------+---------+-------+
  5 row affected
  ```

* Add the foreign key constraint `fk1` to the `tbl2` table. When the `UPDATE` operation affects the parent table's key values that match the rows in the child table, execute the `SET NULL` operation.

  ```sql
  obclient> CREATE TABLE tbl2(c1 INT PRIMARY KEY,c2 INT);
  Query OK, 0 row affected
  obclient> CREATE TABLE tbl3(c1 INT PRIMARY KEY,c2 INT);
  Query OK, 0 row affected
  obclient> ALTER TABLE tbl2 ADD CONSTRAINT fk1 FOREIGN KEY (c2) REFERENCES tbl3(c1) ON UPDATE SET NULL;
  Query OK, 0 row affected
  ```

* Drop the foreign key constraint `fk1` from the `tbl3` table.

  ```sql
  obclient> ALTER TABLE tbl2 DROP FOREIGN KEY fk1;
  Query OK, 0 row affected
  ```

* Drop the primary key from the `tbl2` table.

  ```sql
  obclient> ALTER TABLE tbl2 DROP PRIMARY KEY;
  Query OK, 0 row affected
  ```

### Index operations

* Rename the index `ind1` in the `tbl2` table to `ind2`.

  ```sql
  obclient> CREATE TABLE tbl2(c1 INT(11) PRIMARY KEY,c2 INT(50));
  Query OK, 0 row affected

  obclient> CREATE INDEX ind1 ON tbl2 (c2 ASC);
  Query OK, 0 row affected
  obclient> ALTER TABLE tbl2 RENAME INDEX ind1 TO ind2;
  Query OK, 0 row affected
  ```

* Create an index named `ind3` on the `tbl2` table, which references the `c1` and `c2` columns.

  ```sql
  obclient> ALTER TABLE tbl2 ADD INDEX ind3 (c1,c2);
  Query OK, 0 row affected
  ```

  You can run the `SHOW INDEX` statement to view the created index.

  ```sql
  obclient> SHOW INDEX FROM tbl2;
  +-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+-----------+---------------+---------+
  | Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment   | Index_comment | Visible |
  +-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+-----------+---------------+---------+
  | tbl2  |          0 | PRIMARY  |            1 | c1          | A         |        NULL | NULL     | NULL   |      | BTREE      | available |               | YES     |
  | tbl2  |          1 | ind2     |            1 | c2          | A         |        NULL | NULL     | NULL   |  YES | BTREE      | available |               | YES     |
  | tbl2  |          1 | ind3     |            1 | c1          | A         |        NULL | NULL     | NULL   |      | BTREE      | available |               | YES     |
  | tbl2  |          1 | ind3     |            2 | c2          | A         |        NULL | NULL     | NULL   |  YES | BTREE      | available |               | YES     |
  +-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+-----------+---------------+---------+
  4 rows in set
  ```

* Drop the index `ind2` from the `tbl2` table.

  ```sql
  obclient> ALTER TABLE tbl2 DROP INDEX ind2;
  Query OK, 0 row affected
  ```

  <main id="notice" type='explain'>
    <h4>Note</h4>
    <p>In actual operations, you can use the above methods to implement atomic index changes. </p>
  </main>

* Add three function indexes to the `t1_func` table, one of which is named `i2`, and the other two are automatically generated by the system, with names in the format of `functional_index` followed by a number.

  ```shell
  obclient> ALTER TABLE t1_func ADD INDEX ((CONCAT(c1,'a')));
  Query OK, 0 rows affected
  obclient> ALTER TABLE t1_func ADD INDEX ((c1+1));
  Query OK, 0 rows affected
  obclient> ALTER TABLE t1_func ADD INDEX i2 ((CONCAT(c1,'a')));
  Query OK, 0 rows affected
  obclient> SHOW CREATE TABLE t1_func;
  +---------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  | Table   | Create Table                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
  +---------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  | t1_func | CREATE TABLE `t1_func` (
  `c1` int(11) DEFAULT NULL,
  `c2` int(11) DEFAULT NULL,
  KEY `i1` (((`c1` + `c2`) < 1)) BLOCK_SIZE 16384 LOCAL,
  KEY `functional_index` (concat(`c1`,'a')) BLOCK_SIZE 16384 LOCAL,
  KEY `functional_index_2` ((`c1` + 1)) BLOCK_SIZE 16384 LOCAL,
  KEY `i2` (concat(`c1`,'a')) BLOCK_SIZE 16384 LOCAL
  ) DEFAULT CHARSET = utf8mb4 ROW_FORMAT = DYNAMIC COMPRESSION = 'zstd_1.3.8' REPLICA_NUM = 1 BLOCK_SIZE = 16384 USE_BLOOM_FILTER = FALSE TABLET_SIZE = 134217728 PCTFREE = 0 |
  +---------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  1 row in set
  ```

* Create a column store index for the table.

  1. Run the following SQL statement to create a table named `tbl3`.

     ```sql
     CREATE TABLE tbl3 (col1 INT, col2 VARCHAR(50));
     ```

  2. Create a column store index named `idx1_tbl3` on the `tbl3` table, which references the `col1` column.

     ```sql
     ALTER TABLE tbl3 ADD INDEX idx1_tbl3 (col1) WITH COLUMN GROUP(each column);
     ```

* Make the index invisible.

  <main id="notice" type='explain'>
    <h4>Note</h4>
    <p>After an index is made invisible, you can see the <code>/*!80000 INVISIBLE */</code> tag in the table schema. </p>
  </main>

  1. Create a table named `tbl4`.

     ```sql
     CREATE TABLE tbl4 (col1 INT PRIMARY KEY, col2 INT, col3 INT);
     ```

  2. Create an index named `idx1_tbl4`.

     ```sql
     CREATE INDEX idx1_tbl4 ON tbl4(col2);
     ```

  3. Make the `idx1_tbl4` index invisible.

     ```sql
     ALTER TABLE tbl4 ALTER INDEX idx1_tbl4 INVISIBLE;
     ```

  4. View the structure of the `tbl4` table again.

     ```sql
     SHOW CREATE TABLE tbl4;
     ```

     The returned result is as follows:

     ```shell
     +-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
     | Table | Create Table                                                                                                                                                                                                                                                                                                                                                                                                              |
     +-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
     | tbl4  | CREATE TABLE `tbl4` (
       `col1` int(11) NOT NULL,
       `col2` int(11) DEFAULT NULL,
       `col3` int(11) DEFAULT NULL,
       PRIMARY KEY (`col1`),
       KEY `idx1_tbl4` (`col2`) BLOCK_SIZE 16384 LOCAL /*!80000 INVISIBLE */
     ) DEFAULT CHARSET = utf8mb4 ROW_FORMAT = DYNAMIC COMPRESSION = 'zstd_1.3.8' REPLICA_NUM = 1 BLOCK_SIZE = 16384 USE_BLOOM_FILTER = FALSE TABLET_SIZE = 134217728 PCTFREE = 0 WITH COLUMN GROUP(each column) |
     +-------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
     1 row in set
     ```

### Partitioning operations

* Clear all data in the `M202001` and `M202002` partitions of the partitioned table `t_log_part_by_range`.

  ```sql
  obclient> CREATE TABLE t_log_part_by_range (
      log_id      bigint NOT NULL
      , log_value varchar(50)
      , log_date  timestamp NOT NULL
  ) PARTITION BY RANGE(UNIX_TIMESTAMP(log_date))
  (
      PARTITION M202001 VALUES LESS THAN(UNIX_TIMESTAMP('2020/02/01'))
      , PARTITION M202002 VALUES LESS THAN(UNIX_TIMESTAMP('2020/03/01'))
      , PARTITION M202003 VALUES LESS THAN(UNIX_TIMESTAMP('2020/04/01'))
      , PARTITION M202004 VALUES LESS THAN(UNIX_TIMESTAMP('2020/05/01'))
      , PARTITION M202005 VALUES LESS THAN(UNIX_TIMESTAMP('2020/06/01'))
  );
  Query OK, 0 rows affected

  obclient> ALTER TABLE t_log_part_by_range TRUNCATE PARTITION M202001, M202002;
  Query OK, 0 rows affected
  ```

* Add the `M202006` partition to the partitioned table `t_log_part_by_range`.

  ```sql
  obclient> CREATE TABLE t_log_part_by_range (
      log_id      bigint NOT NULL
      , log_value varchar(50)
      , log_date  timestamp NOT NULL
  ) PARTITION BY RANGE(UNIX_TIMESTAMP(log_date))
  (
      PARTITION M202001 VALUES LESS THAN(UNIX_TIMESTAMP('2020/02/01'))
      , PARTITION M202002 VALUES LESS THAN(UNIX_TIMESTAMP('2020/03/01'))
      , PARTITION M202003 VALUES LESS THAN(UNIX_TIMESTAMP('2020/04/01'))
      , PARTITION M202004 VALUES LESS THAN(UNIX_TIMESTAMP('2020/05/01'))
      , PARTITION M202005 VALUES LESS THAN(UNIX_TIMESTAMP('2020/06/01'))
  );
  Query OK, 0 rows affected

  obclient> ALTER TABLE t_log_part_by_range ADD PARTITION
           (PARTITION M202006 VALUES LESS THAN(UNIX_TIMESTAMP('2020/07/01'))
           );
  ```

### Change the degree of parallelism

* Change the degree of parallelism of `tbl3` to `2`.

  ```sql
  obclient> ALTER TABLE tbl3 PARALLEL 2;
  ```

  You can change the degree of parallelism of a table by using either `ALTER TABLE table_name PARALLEL int;` or the `PARALLEL` hint. The syntax for using the `PARALLEL` hint is `alter /*+ parallel(int) */ table`.

### Operations on column types

* Modify the `col1` column in the `tbl4` table to an auto-increment column.

  ```sql
  obclient> CREATE TABLE tbl4 (col1 BIGINT(10) NOT NULL,col2 INT);
  Query OK, 0 rows affected

  obclient> ALTER TABLE tbl4 MODIFY col1 BIGINT(10) AUTO_INCREMENT;
  Query OK, 0 rows affected
  ```

* Add the `col1` column as the primary key of the `tbl4` table and change the primary key to `col2`.

  ```sql
  obclient> ALTER TABLE tbl4 ADD PRIMARY KEY (col1);
  Query OK, 0 rows affected

  obclient> ALTER TABLE tbl4 DROP PRIMARY KEY,ADD PRIMARY KEY (`col2`);
  Query OK, 0 rows affected
  ```

* Add a `CHECK` constraint.

  ```sql
  obclient> CREATE TABLE tbl7(col1 VARCHAR(10),col2 VARCHAR(10));
  Query OK, 0 rows affected

  obclient> ALTER TABLE tbl7 ADD CONSTRAINT my_check CHECK (col1> col2) ;
  Query OK, 0 rows affected
  ```

* Delete the `CHECK` constraint from the `tbl7` table.

  ```sql
  obclient> ALTER TABLE tbl7 DROP CHECK my_check;
  Query OK, 0 rows affected
  ```

* Change the column type to `NOT NULL`.

  ```sql
  obclient> CREATE TABLE dept(
      deptno           NUMBER(2,0),
      dname            VARCHAR(14),
      location         VARCHAR(13),
      CONSTRAINT pk_dept PRIMARY KEY(deptno)
  );
  Query OK, 0 rows affected

  obclient> CREATE TABLE emp(
      empno         NUMBER(4,0) NOT NULL,
      empname       VARCHAR(10) NOT NULL,
      job           VARCHAR(9) NOT NULL,
      mgr           NUMBER(4,0) NOT NULL,
      hiredate      DATE NOT NULL,
      sal           NUMBER(7,2) DEFAULT NULL,
      comm          NUMBER(7,2) DEFAULT NULL,
      deptno        NUMBER(2,0) DEFAULT NULL,
      CONSTRAINT PK_emp PRIMARY KEY (empno),
      CONSTRAINT FK_deptno  FOREIGN KEY (deptno)  REFERENCES dept (deptno)
  );
  Query OK, 0 rows affected

  obclient> ALTER TABLE emp MODIFY deptno NUMBER(2,0) DEFAULT '12' NOT NULL;
  Query OK, 0 rows affected
  ```

#### Change the column name and add a NOT NULL column constraint

<main id="notice" type='notice'>
    <h4>Notice</h4>
    <p>Modify the column name and add a <code>not null</code> constraint only when the following conditions are met:<ul><li>You can change the name and constraint of only one column at a time. Multi-column operations are not supported.</li><li>You can add only <code>not null</code> constraints.</li><li>You can perform only the <code>alter_column</code> operation. Operations such as index and partition creation are not supported.</li><li>The column whose name is changed and the column to which the constraint is added must be the same column.</li></ul></p>
  </main>

```sql
obclient> ALTER TABLE test_alter1 MODIFY COLUMN `C1` varchar(10) NOT NULL;
Query OK, 0 rows affected (2.421 sec)
```

#### Add the NOT NULL constraint to two columns

  <main id="notice" type='notice'>
      <h4>Notice</h4>
      <p>Add the <code>NOT NULL</code> constraint to two columns only when the following conditions are met:<ul><li>You can add constraints to only two columns. </li><li>You can add only <code>not null</code> constraints.</li><li>You can perform only the <code>alter_column</code> operation. Operations such as index and partition creation are not supported.</li><li>You cannot modify other columns except the two columns to which the constraints are added. </li></ul></p>
    </main>

Run the following command to add the `NOT NULL` constraint to the `C1` and `c2` columns:

```sql
obclient> ALTER TABLE test_alter4 MODIFY COLUMN c1 varchar(10) NOT NULL, MODIFY COLUMN c2 varchar(10) NOT NULL;
Query OK, 0 rows affected (2.605 sec)
```

#### Change the type of a column with a prefix index

<main id="notice" type='notice'>
    <h4>Notice</h4>
    <p>Change the type of a column with a prefix index only when the following conditions are met:<ul><li>The original column type is <code>char</code>. </li><li>The target column type is <code>varchar</code>. </li><li>The lengths of the original and target columns are the same. </li></ul></p>
  </main>

1. Run the following command to create a table named `test_alter5` that contains the `c1` column. The data type of the `c1` column is `CHAR(20)`, and a prefix index named `idx_c1` is created on the `c1` column:

   ```sql
   obclient> CREATE TABLE test_alter5 (c1 char(20), KEY idx_c1(c1(10)));
   ```

2. Execute the following command to change the data type of the `c1` column to `varchar(20)`:

   ```sql
   obclient> ALTER TABLE test_alter5 MODIFY COLUMN c1 varchar(20);
   ```

#### Change the foreign key constraint rules

1. Run the following command to create a table named `t1` and add a unique constraint to the integer column `c1`:

   ```sql
   obclient> CREATE TABLE t1(c1 int unique key);
   ```

2. Run the following command to create a table named `t2` that contains an integer column `c1` and define a foreign key constraint:

   ```sql
   obclient> CREATE TABLE t2(c1 int, CONSTRAINT fk_cst_test FOREIGN KEY (c1) REFERENCES t1(c1) on update set null on delete no action);
   ```

3. Run the following command to query the system table `INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS` and obtain the update and delete rules of the foreign key constraint `fk_cst_test`:

   ```sql
   obclient> SELECT update_rule, delete_rule FROM information_schema.referential_constraints WHERE CONSTRAINT_NAME = 'fk_cst_test';
   ```

   The return result is as follows:

   ```sql
   +-------------+-------------+
   | update_rule | delete_rule |
   +-------------+-------------+
   | SET NULL    | NO ACTION   |
   +-------------+-------------+
   ```

   * `UPDATE_RULE`: `SET NULL` (the foreign key is set to `NULL` during an update).
   * `DELETE_RULE`: `NO ACTION` (a constraint is checked during a deletion, which may prevent the operation).

### Rename a column

* The `RENAME COLUMN` statement does not change the column definition but only modifies the column name. If the target name already exists in the table, the `RENAME COLUMN` statement will fail. However, renaming the column back to its original name will not cause any errors.

  ```shell
  obclient> CREATE TABLE tbl8 (a INT, b INT);
  Query OK, 0 rows affected

  obclient> ALTER TABLE tbl8 RENAME COLUMN a TO b;
  ERROR 1060 (42S21): Duplicate column name 'b'

  obclient> ALTER TABLE tbl8 RENAME COLUMN a TO a;
  Query OK, 0 rows affected
  ```

* If an index exists on the column to be renamed, the `RENAME COLUMN` statement can still be executed, and the index definition will be automatically updated.

  ```shell
  obclient> CREATE TABLE tbl9 (a INT, b INT, index idx_a(a));
  Query OK, 0 rows affected

  obclient> SHOW INDEX FROM tbl9;
  +-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+-----------+---------------+---------+------------+
  | Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment   | Index_comment | Visible | Expression |
  +-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+-----------+---------------+---------+------------+
  | tbl9  |          1 | idx_a    |            1 | a           | A         |        NULL | NULL     | NULL   | YES  | BTREE      | available |               | YES     | NULL       |
  +-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+-----------+---------------+---------+------------+
  1 row in set

  obclient> ALTER TABLE tbl9 RENAME COLUMN a TO c;
  Query OK, 0 rows affected

  obclient> SHOW INDEX FROM tbl9;
  +-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+-----------+---------------+---------+------------+
  | Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment   | Index_comment | Visible | Expression |
  +-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+-----------+---------------+---------+------------+
  | tbl9  |          1 | idx_a    |            1 | c           | A         |        NULL | NULL     | NULL   | YES  | BTREE      | available |               | YES     | NULL       |
  +-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+-----------+---------------+---------+------------+
  1 row in set
  ```

* If the column to be renamed is referenced by a prefix index, the `RENAME COLUMN` statement can still be executed, and the prefix index supports cascading updates.

  ```shell
  DROP TABLE tbl9;
  obclient> CREATE TABLE tbl9 (c1 INT PRIMARY KEY, c2 BLOB, c3 INT, INDEX i1 (c2(10)));
  Query OK, 0 rows affected

  obclient> ALTER TABLE tbl9 RENAME COLUMN c2 TO c2_, RENAME COLUMN c1 TO c2_1;
  DESC tbl9;
  Query OK, 0 rows affected

  obclient> SHOW INDEX FROM tbl9;
  +-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+-----------+---------------+---------+------------+
  | Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment   | Index_comment | Visible | Expression |
  +-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+-----------+---------------+---------+------------+
  | tbl9  |          0 | PRIMARY  |            1 | c2_1        | A         |        NULL | NULL     | NULL   |      | BTREE      | available |               | YES     | NULL       |
  | tbl9  |          1 | i1       |            1 | c2_         | A         |        NULL | 10       | NULL   | YES  | BTREE      | available |               | YES     | NULL       |
  +-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+-----------+---------------+---------+------------+
  2 rows in set
  ```

* If a foreign key constraint exists on the column to be renamed, the `RENAME COLUMN` statement can still be executed, and the foreign key constraint will be automatically updated.

  ```shell
  obclient> CREATE TABLE tbl10 (a INT PRIMARY KEY);
  Query OK, 0 rows affected

  obclient> CREATE TABLE tbl11(b INT, FOREIGN KEY (b) REFERENCES tbl10(a));

  obclient> SHOW CREATE TABLE tbl11;
  +-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  | Table | Create Table                                                                                                                                                                                                                                                                                                                                                      |
  +-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  | tbl11 | CREATE TABLE `tbl11` (
  `b` int(11) DEFAULT NULL,
  CONSTRAINT `tbl11_OBFK_1694681944513338` FOREIGN KEY (`b`) REFERENCES `test`.`tbl10`(`a`) ON UPDATE RESTRICT ON DELETE RESTRICT
  ) DEFAULT CHARSET = utf8mb4 ROW_FORMAT = DYNAMIC COMPRESSION = 'zstd_1.3.8' REPLICA_NUM = 1 BLOCK_SIZE =  16384 USE_BLOOM_FILTER = FALSE TABLET_SIZE = 134217728 PCTFREE = 0 |
  +-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  1 row in set

  obclient> ALTER TABLE tbl10 RENAME COLUMN a TO c;
  Query OK, 0 rows affected

  obclient> SHOW CREATE TABLE tbl11;
  +-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  | Table | Create Table                                                                                                                                                                                                                                                                                                                                                      |
  +-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  | tbl11 | CREATE TABLE `tbl11` (
  `b` int(11) DEFAULT NULL,
  CONSTRAINT `tbl11_OBFK_1694681944513338` FOREIGN KEY (`b`) REFERENCES `test`.`tbl10`(`c`) ON UPDATE RESTRICT ON DELETE RESTRICT
  ) DEFAULT CHARSET = utf8mb4 ROW_FORMAT = DYNAMIC COMPRESSION = 'zstd_1.3.8' REPLICA_NUM = 1 BLOCK_SIZE = 16384 USE_BLOOM_FILTER = FALSE TABLET_SIZE = 134217728 PCTFREE = 0 |
  +-------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
  1 row in set
  ```

OceanBase Database does not support modifying or automatically updating the column name in the following scenarios:

* The column to be renamed is referenced by a generated list expression. Modifying the column name is not supported, and an error will be returned upon execution.

  ```shell
  obclient> CREATE TABLE tbl12(a INT, b INT AS (a + 1), c INT, d INT, CONSTRAINT d_check CHECK(d > 0)) PARTITION BY HASH(c + 1) PARTITIONS 2;

  obclient> ALTER TABLE tbl12 RENAME COLUMN a TO e;
  ERROR 3108 (HY000): Column 'a' has a generated column dependency
  ```

* The column to be renamed is referenced by a partitioning expression. Modifying the column name is not supported, and an error will be returned upon execution.

  ```shell
  obclient> ALTER TABLE tbl12 RENAME COLUMN c TO e;
  ERROR 3855 (HY000): Column 'c' has a partitioning function dependency and cannot be dropped or renamed.
  ```

* The column to be renamed is referenced by a `CHECK` constraint. Modifying the column name is not supported, and an error will be returned upon execution.

  ```shell
  obclient> ALTER TABLE tbl12 RENAME COLUMN d TO e;
  ERROR 3959 (HY000): Check constraint 'd_check' uses column 'd', hence column cannot be dropped or renamed.
  ```

* The column to be renamed is referenced by a function-based index. Modifying the column name is not supported, and an error will be returned upon execution.

  ```shell
  DROP TABLE IF EXISTS tbl12;
  obclient> CREATE TABLE tbl12(i INT, INDEX ((i+1)));
  Query OK, 0 rows affected

  obclient> ALTER TABLE tbl12 RENAME COLUMN i TO j;
  ERROR 3837 (HY000): Column 'i' has a functional index dependency and cannot be dropped or renamed.
  ```

* The column to be renamed is referenced by a view. The `RENAME COLUMN` statement will execute successfully, but an error will be returned when querying the view. In this case, you must manually modify the view definition.

  ```shell
  obclient> CREATE TABLE tbl13(a INT);
  Query OK, 0 rows affected

  obclient> CREATE VIEW v1 AS SELECT a + 1 FROM tbl13;
  Query OK, 0 rows affected

  obclient> SELECT * FROM v1;
  Empty set

  obclient> ALTER TABLE tbl13 RENAME COLUMN a TO b;
  Query OK, 0 rows affected

  obclient> SELECT * FROM v1;
  ERROR 1356 (42S22): View 'test.v1' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
  ```

* The column to be renamed is referenced by a stored procedure. The `RENAME COLUMN` statement will execute successfully, but an error will be returned when you call the stored procedure. In this case, you must manually modify the stored procedure definition.

  ```shell
  obclient> CREATE TABLE tbl14(a INT);
  Query OK, 0 rows affected

  obclient> CREATE PROCEDURE proc() SELECT a + 1 FROM tbl14;
  Query OK, 0 rows affected

  obclient> CALL proc();
  Empty set

  obclient> ALTER TABLE tbl14 RENAME COLUMN a TO b;
  Query OK, 0 rows affected

  obclient> CALL proc();
  ERROR 1054 (42S22): Unknown column 'a' in 'field list'
  ```

### Change the column store attribute of a table

1. Run the following statement to create a table named `tbl1`.

   ```sql
   CREATE TABLE tbl1 (col1 INT PRIMARY KEY, col2 VARCHAR(50));
   ```

2. Convert the `tbl1` table to a hybrid row-column store table and then delete the hybrid row-column store attribute.

   ```sql
   ALTER TABLE tbl1 ADD COLUMN GROUP(all columns, each column);
   ```

   ```sql
   ALTER TABLE tbl1 DROP COLUMN GROUP(all columns, each column);
   ```

3. Convert the `tbl1` table to a column store table and then delete the column store attribute.

   ```sql
   ALTER TABLE tbl1 ADD COLUMN GROUP(each column);
   ```

   ```sql
   ALTER TABLE tbl1 DROP COLUMN GROUP(each column);
   ```

### Modify the Skip Index attribute of a column

Run the following statement to create a table named `test_skidx`.

```sql
CREATE TABLE test_skidx(
  col1 INT SKIP_INDEX(MIN_MAX, SUM),
  col2 FLOAT SKIP_INDEX(MIN_MAX),
  col3 VARCHAR(1024) SKIP_INDEX(MIN_MAX),
  col4 CHAR(10)
  );
```

* Modify the Skip Index attribute of the `col2` column in the `test_skidx` table to the `SUM` Skip Index type.

  ```sql
  ALTER TABLE test_skidx MODIFY COLUMN col2 FLOAT SKIP_INDEX(SUM);
  ```

* Set the Skip Index attribute of a new column to `MIN_MAX` Skip Index type after the table is created. Add the `MIN_MAX` Skip Index attribute to the `col4` column in the `test_skidx` table.

  ```sql
  ALTER TABLE test_skidx MODIFY COLUMN col4 CHAR(10) SKIP_INDEX(MIN_MAX);
  ```

* Drop the Skip Index attribute of a column after the table is created. Drop the Skip Index attribute of the `col1` column in the `test_skidx` table.

  ```sql
  ALTER TABLE test_skidx MODIFY COLUMN col1 INT SKIP_INDEX();
  ```

  or

  ```sql
  ALTER TABLE test_skidx MODIFY COLUMN col1 INT;
  ```

### Modify table attributes

Disable the persistent macroblock-level Bloom filter for the table `tb`.

```sql
ALTER TABLE tb SET enable_macro_block_bloom_filter = False;
```

## References

[Change a table](../../../../300.database-object-management/100.manage-object-of-mysql-mode/200.manage-tables-of-mysql-mode/600.change-table-of-mysql-mode.md)