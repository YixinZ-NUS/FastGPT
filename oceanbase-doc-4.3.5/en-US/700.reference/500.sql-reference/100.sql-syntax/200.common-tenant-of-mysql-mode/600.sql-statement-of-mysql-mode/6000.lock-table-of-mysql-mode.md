| Description   |                 |
|---------------|-----------------|
| keywords      |                 |
| dir-name      |                 |
| dir-name-en   |                 |
| tenant-type   | MySQL Mode      |
|machine-translation||

# LOCK TABLES

## Purpose

You can use this statement to lock a table within a session to prevent other sessions from performing concurrent operations on the same table. When it is necessary to stop all DML and DDL operations on a table, this statement can be used to lock the table.

<main id="notice" type='explain'>
  <h4>Note</h4>
  <p>For OceanBase Database V4.3.5, the <code>LOCK TABLES</code> statement is available starting from V4.3.5 BP2. </p>
</main>

## Prerequisites

* Before you use the `LOCK TABLES` statement, you need to enable the following tenant-level parameter:

    ```sql
    ALTER SYSTEM SET enable_lock_priority = TRUE;
    ```

    For more information about the tenant-level parameter, see [enable_lock_priority](../../../../800.configuration-items-and-system-variables/100.system-configuration-items/400.tenant-level-configuration-items/2650.enable_lock_priority.md).

    <main id="notice" type='notice'>
      <h4>Notice</h4>
      <p>After you enable the <code>enable_lock_priority</code> parameter for a tenant, the parameter value is not immediately recognized by all nodes. Therefore, you must query the value of the <code>enable_lock_priority</code> parameter on all nodes using the <code>GV$OB_PARAMETERS</code> view to ensure that the parameter is enabled on all machines in the tenant. </p>
    </main>

* If you use a proxy to connect to the cluster, you also need to enable the following proxy parameters:

    ```sql
    ALTER PROXYCONFIG SET proxy_id = 1;
    ALTER PROXYCONFIG SET client_session_id_version = 2;
    ALTER PROXYCONFIG SET enable_single_leader_node_routing = false;
    ```

    For more information about the proxy parameters, see [proxy_id](https://en.oceanbase.com/docs/common-odp-doc-en-10000000001957913), [client_session_id_version](https://en.oceanbase.com/docs/common-odp-doc-en-10000000001957998) and [enable_single_leader_node_routing](https://en.oceanbase.com/docs/common-odp-doc-en-10000000001957990).

## Limitations and considerations

* After enabling table locks, it is recommended not to perform `RENAME TABLE` operations independently. Instead, acquire write locks (`WRITE`) before executing `RENAME TABLE` operations.
* Once a session locks a table, read and write operations on the locked tables are not supported. Only `RENAME TABLE` operations are allowed.
* Locking a table by its alias name is equivalent to locking the table by its original name.
* If the current session holds a table lock, executing the `LOCK TABLES` statement again will add locks to additional tables.
* `START TRANSACTION` does not release table locks. The locks can only be released using the `UNLOCK TABLES` statement or by disconnecting the session.
* The `LOCK TABLES` statement does not automatically commit transactions.
* Views cannot be locked.
* For tables involved in foreign key relationships, only the explicitly locked table is affected. For example, if a child table is locked, the parent table is not locked, and vice versa.
* If the `LOCK TABLES` statement is executed on a temporary table, no lock is applied, and no error is returned.

## Privilege requirements

To execute the `LOCK TABLES` statement, the current user must have the `LOCK TABLES` privilege on the corresponding object. For more information about OceanBase Database privileges, see [Privilege types in MySQL mode](../../../../../600.manage/500.security-and-permissions/300.access-control/200.user-and-permission/200.permission-of-mysql-mode/100.permission-classification-of-mysql.md).

## Syntax

```sql
LOCK {TABLE | TABLES}
    tbl_name [[AS] alias] lock_type
    [, tbl_name [[AS] alias] lock_type ...];

lock_type:
    READ [LOCAL]
    | [LOW_PRIORTY] WRITE
```

## Parameters

|       **Parameter**     | **Description** |
|------------------------|----------|
| LOCK {TABLE \| TABLES} | The statement to lock a table or multiple tables. `LOCK TABLE` is a synonym of `LOCK TABLES`.|
| table_name             | The name of the table to be locked. |
| [AS] alias             | The alias name of the table. |
| lock_type              | The type of the table lock. For more information about the table lock types, see [lock_type](#lock_type). |

### lock_type

* `READ [LOCAL]`:

  * `READ`: All sessions can read the locked table but cannot modify it, including the session that applies the lock. Multiple sessions can obtain a read lock on the same table at the same time.
  * `READ LOCAL`: The same as `READ`.

* `[LOW_PRIORITY] WRITE`:

  * `WRITE`: The same as `READ`.
  * `LOW_PRIORITY WRITE`: The same as `WRITE`.

## Examples

1. Create sample tables and insert test data.

   1. Create a table named `test_tbl1`.

       ```sql
       CREATE TABLE test_tbl1(col1 INT, col2 VARCHAR(25), col3 INT);
       ```

   2. Insert test data into `test_tbl1`.

       ```sql
       INSERT INTO test_tbl1 VALUES(1, 'A1', 100);
       ```

2. Enable the tenant-level parameter `enable_lock_priority`.

    ```sql
    ALTER SYSTEM SET enable_lock_priority = TRUE;
    ```

3. Execute the following statement to commit the transaction.

    ```sql
    COMMIT;
    ```

4. In Session 1, execute the following statement to obtain a read lock on the `test_tbl1` table.

    ```sql
    LOCK TABLES test_tbl1 READ;
    ```

5. In Session 1, execute the following statement to query data from the `test_tbl1` table.

    ```sql
    SELECT * FROM test_tbl1;
    ```

    The return result is as follows:

    ```shell
    +------+------+------+
    | col1 | col2 | col3 |
    +------+------+------+
    |    1 | A1   |  100 |
    +------+------+------+
    1 row in set
    ```

6. In Session 1, execute the following statement to insert a row of data into the `test_tbl1` table.

    ```shell
    INSERT INTO test_tbl1 VALUES(2, 'A2', 200);
    ```

    The return result is as follows:

    ```shell
    ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
    ```

7. In Session 2, execute the following statement to query data from the `test_tbl1` table.

    ```sql
    SELECT * FROM test_tbl1;
    ```

    The return result is as follows:

    ```shell
    +------+------+------+
    | col1 | col2 | col3 |
    +------+------+------+
    |    1 | A1   |  100 |
    +------+------+------+
    1 row in set
    ```

8. In Session 2, execute the following statement to insert a row of data into the `test_tbl1` table.

    ```shell
    INSERT INTO test_tbl1 VALUES(2, 'A2', 200);
    ```

    The return result is as follows:

    ```shell
    ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
    ```

9. In Session 1, execute the following statement to release all table locks held by the current session.

    ```sql
    UNLOCK TABLES;
    ```

10. In Session 1, execute the following statement to insert a row of data into the `test_tbl1` table.

    ```shell
    INSERT INTO test_tbl1 VALUES(2, 'A2', 200);
    ```

    The return result is as follows:

    ```shell
    Query OK, 1 row affected
    ```

11. In Session 2, execute the following statement to insert a row of data into the `test_tbl1` table.

    ```shell
    INSERT INTO test_tbl1 VALUES(3, 'A3', 300);
    ```

    The return result is as follows:

    ```shell
    Query OK, 1 row affected
    ```

## References

[UNLOCK TABLES](8950.unlock-tables-of-mysql-mode.md)