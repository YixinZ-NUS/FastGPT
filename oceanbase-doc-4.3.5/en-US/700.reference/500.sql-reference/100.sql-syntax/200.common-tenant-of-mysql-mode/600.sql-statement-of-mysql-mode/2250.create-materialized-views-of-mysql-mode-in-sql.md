| Description   |                 |
|---------------|-----------------|
| keywords      |                 |
| dir-name      |                 |
| dir-name-en   |                 |
| tenant-type   | MySQL Mode      |
|machine-translation||

# CREATE MATERIALIZED VIEW

## Purpose

This statement is used to create a materialized view.

A materialized view is a special type of database object that stores a copy of the query results and is periodically refreshed (or can be manually refreshed) to keep the data up to date. Materialized views can include operations such as aggregations, joins, and subqueries, and can be indexed and partitioned to further improve performance.

## Privilege requirements

You must have the `CREATE TABLE` privilege to create a materialized view. For more information about the privileges of OceanBase Database, see [Privilege types in MySQL mode](../../../../../600.manage/500.security-and-permissions/300.access-control/200.user-and-permission/200.permission-of-mysql-mode/100.permission-classification-of-mysql.md).

## Syntax

```sql
CREATE MATERIALIZED VIEW view_name [([column_list] [PRIMARY KEY(column_list)])]
    [table_option_list]
    [partition_option]
    [mv_column_group_option]
    [refresh_clause]
    [query_rewrite_clause]
    [on_query_computation_clause]
    AS view_select_stmt;

column_list:
    column_name [, column_name ...]

refresh_clause:
    REFRESH [refresh_option [nested_refresh_option]] [mv_refresh_on_clause]
    | NEVER REFRESH

refresh_option:
    COMPLETE
    | FAST
    | FORCE

nested_refresh_option:
    INDIVIDUAL
    | INCONSISTENT
    | CONSISTENT

mv_refresh_on_clause:
    [ON DEMAND] [[START WITH expr] [NEXT expr]]

query_rewrite_clause:
    DISABLE QUERY REWRITE
    | ENABLE QUERY REWRITE

on_query_computation_clause:
    DISABLE ON QUERY COMPUTATION
    | ENABLE ON QUERY COMPUTATION

mv_column_group_option:
    WITH COLUMN GROUP(all columns)
    | WITH COLUMN GROUP(each column)
    | WITH COLUMN GROUP(all columns, each column)
```

## Parameters

<main id="notice" type='explain'>
  <h4>Note</h4>
  <p>You cannot create an index in the statement for creating a materialized view. You can use the <a href="2200.create-index-of-mysql-mode.md">CREATE INDEX</a> or <a href="1600.alter-table-of-mysql-mode.md">ALTER TABLE</a> statement to create an index for a materialized view. </p>
</main>

|       **Parameter**        |       **Description**           |
|-----------------------|--------------------------|
| view_name             | The name of the materialized view to be created.|
| column_list       | Optional. The list of columns of the materialized view. If you want to specify the names of the view columns, you can use the column_list clause and separate the column names with commas. <main id="notice" type='explain'><h4>Note</h4><p><ul><li>The view must have unique column names, just like the base table. By default, the column names of the view are the same as those retrieved in the <code>SELECT</code> statement. </li><li>The number of column names specified in the <code>column_list</code> clause must be the same as the number of columns retrieved in the <code>SELECT</code> statement. </li></ul></p></main>|
| column_name           | The name of the column of the materialized view. By default, the column names retrieved in the `SELECT` statement are used as the view column names.|
| PRIMARY KEY           | The primary key of the materialized view. <main id="notice" type='notice'><h4>Notice</h4><p><ul><li>If the column name of the materialized view is not specified, the column names used in the primary key of the materialized view must be the same as those retrieved in the <code>SELECT</code> statement. </li><li>If the column names of the materialized view are specified, a comma must be placed between the last column name in the column name list and the <code>PRIMARY KEY</code> clause. </li></ul></p></main>|
| table_option_list | Optional. The table options of the materialized view. Like a regular table, a materialized view can have table options. For more information, see [CREATE TABLE](2600.create-table-of-mysql-mode.md).|
| partition_option  | Optional. The partition options of the materialized view. Like a regular table, a materialized view can have partition options. For more information, see [CREATE TABLE](2600.create-table-of-mysql-mode.md).|
| mv_column_group_option      | Optional. The storage format of the materialized view. If this option is not specified, a row-based materialized view is created by default. For more information, see [mv_column_group_option](#mv_column_group_option).|
| refresh_clause        | Optional. The refresh method of the materialized view. For more information, see [refresh_clause](#refresh_clause).|
| mv_refresh_on_clause  | Optional. The refresh timing of the materialized view. For more information, see [mv_refresh_on_clause](#mv_refresh_on_clause).|
| query_rewrite_clause  | Optional. Specifies whether to enable automatic query rewriting for the materialized view. For more information, see [query_rewrite_clause](#query_rewrite_clause).|
| on_query_computation_clause | Optional. Specifies whether the materialized view is a real-time materialized view. For more information, see [on_query_computation_clause](#on_query_computation_clause).|
| view_select_stmt      | The query (SELECT statement) used to define the data of the materialized view. This statement is used to retrieve data from the base table and store the results in the materialized view. The syntax of `view_select_stmt` is the same as that of a regular `SELECT` statement. For more information, see [SELECT statement](8100.select-of-mysql-mode/100.select-of-mysql-mode.md). <main id="notice" type='explain'><h4>Note</h4><p>For OceanBase Database V4.3.5: <ul><li> Starting from V4.3.5 BP2, you can create a full-refresh materialized view with a standard view or an external table as the base table. </li><li> Starting from V4.3.5 BP4, you can add the <code>AS OF PROCTIME()</code> clause to the base table when you create a materialized view. If the <code>AS OF PROCTIME()</code> clause is used outside the base table in a materialized view creation statement, an error is returned. The <code>AS OF PROCTIME()</code> clause is used to specify that the refresh of this table is skipped during an incremental refresh. The <code>AS OF PROCTIME()</code> table does not require an mlog. </li><li> Starting from V4.3.5 BP5, a standard view declared as a dimension table (<code>AS OF PROCTIME()</code>) can be used as the base table for an incremental-refresh materialized view. </li></ul></p></main>|

### mv_column_group_option

* `WITH COLUMN GROUP(all columns)`: specifies to create a materialized view in row store format.

* `WITH COLUMN GROUP(each column)`: specifies to create a materialized view in column store format.

* `WITH COLUMN GROUP(all columns, each column)`: specifies to create a materialized view in redundant row and column store format.

<main id="notice" type='explain'>
  <h4>Note</h4>
  <p>You can use the <code>SHOW CREATE TABLE view_name;</code> or <code>SHOW CREATE VIEW view_name;</code> statement to view the definition of the materialized view and determine its storage format.</p>
</main>

### refresh_clause

* `REFRESH [refresh_option [nested_refresh_option]] [mv_refresh_on_clause]`: specifies the refresh method for the materialized view.

  * `refresh_option`: specifies the refresh method for the materialized view. This is an optional parameter. If you do not specify a refresh method, the default value is `FORCE`. Valid values:

    * `COMPLETE`: specifies to perform a complete refresh. This means that the entire data of the materialized view is recalculated to ensure that the data in the view is completely consistent with the source table.

    * `FAST`: specifies to perform an incremental refresh. This means that only the data related to changes in the source table is refreshed, avoiding the need to recalculate the entire view.

      <main id="notice" type='notice'>
        <h4>Notice</h4>
        <p><ul><li>When you use the <code>REFRESH FAST</code> method, you must create a materialized view log (mlog) for the base table before you create the materialized view. This is because the <code>REFRESH FAST</code> method uses the records in the materialized view log to determine which data to incrementally refresh. </li><li>All columns used in the incremental refresh of the materialized view must be included in the mlog. </li></ul>For more information about how to create a materialized view log, see <a href="../../../../300.database-object-management/100.manage-object-of-mysql-mode/600.manage-views-of-mysql-mode/200.manage-materialized-views-of-mysql-mode/200.materialized-views-log-of-mysql-mode.md">Materialized view logs</a>.</p>
      </main>

    * `FORCE`: the default value. Specifies to perform a hybrid refresh. First, an incremental refresh is attempted. If the incremental refresh fails, a complete refresh is performed.

    * `nested_refresh_option`: specifies the refresh strategy for nested materialized views. This is an optional parameter. If you do not specify a refresh strategy, the default value is `INDIVIDUAL`. Valid values:

      * `INDIVIDUAL`: the default value. Specifies to perform an independent refresh.
      * `INCONSISTENT`: specifies to perform a cascading inconsistent refresh.
      * `CONSISTENT`: specifies to perform a cascading consistent refresh.

      <main id="notice" type='explain'>
        <h4>Note</h4>
        <p><ul><li>Starting from OceanBase Database V4.3.5 BP3, the parameter <code>nested_refresh_option</code> (specifies the refresh strategy for nested materialized views) is supported in OceanBase Database V4.3.5. </li><li>For non-nested materialized views, there is no cascading refresh behavior. Therefore, regardless of the refresh strategy you specify, the default value of `INDIVIDUAL` is used. The three specified refresh strategies only take effect in background tasks. When you manually schedule a refresh using the PL package (<a href="../../../../600.pl-reference/200.pl-mysql/1000.pl-system-package-mysql/9950.dbms-mview-mysql/300.refresh-mysql.md">DBMS_MVIEW.REFRESH</a>), the refresh is performed based on the specified PL parameters. </li></ul></p>
      </main>

* `NEVER REFRESH`: specifies that the materialized view does not need to be refreshed. This means that the materialized view is only refreshed when it is created and cannot be refreshed again after creation.

### mv_refresh_on_clause

<main id="notice" type='explain'>
  <h4>Note</h4>
  <p>Except for using the <code>mv_refresh_on_clause</code> clause to define a refresh plan, you can also manually refresh a materialized view by calling the <code>dbms_mviews.refresh</code> stored procedure. </p>
</main>

* `ON DEMAND`: an optional parameter. Specifies to refresh the materialized view on demand.

* `[[START WITH expr] [NEXT expr]]`: an optional parameter. Specifies the refresh interval.

  * `[START WITH expr]`: an optional parameter. Specifies the start time of the refresh plan.
  * `[NEXT expr]`: an optional parameter. Specifies the next refresh time.

    <main id="notice" type='notice'>
      <h4>Notice</h4>
      <p><ul><li>If you use the <code>NEXT</code> clause, the time expression of the refresh plan must be set to a future time. Otherwise, an error will be triggered. </li><li>If you want the materialized view to periodically and automatically schedule refresh tasks, define the <code>NEXT</code> clause to set the scheduling cycle. </li></ul></p>
    </main>

We recommend that you use `sysdate()` to represent the current time in the current time zone. Here is an example of a time expression:

```sql
START WITH sysdate() NEXT sysdate() + INTERVAL 1 DAY
```

The preceding clause indicates that the materialized view is refreshed every 1 day starting from the current time (`sysdate()`).

### query_rewrite_clause

<main id="notice" type='notice'>
  <h4>Notice</h4>
  <p>This feature is applicable only to materialized views that contain only the <code>SELECT JOIN</code> and <code>WHERE</code> clauses, that is, SPJ queries. Materialized views that do not meet the conditions will not be reported as errors, but will not be used for rewriting. </p>
</main>

* `DISABLE QUERY REWRITE`: the default value. Specifies to disable automatic rewriting for the materialized view.
* `ENABLE QUERY REWRITE`: specifies to enable automatic rewriting for the materialized view.

For more information about materialized view rewriting, see [Materialized view query rewriting](../../../../300.database-object-management/100.manage-object-of-mysql-mode/600.manage-views-of-mysql-mode/200.manage-materialized-views-of-mysql-mode/500.materialized-views-rewrite-of-mysql-mode.md).

### on_query_computation_clause

* `DISABLE ON QUERY COMPUTATION`: the default value, which specifies to create a regular materialized view.
* `ENABLE ON QUERY COMPUTATION`: specifies to create a real-time materialized view.

For more information about real-time materialized views, see the **Create a real-time materialized view** section in [Create a materialized view](../../../../300.database-object-management/100.manage-object-of-mysql-mode/600.manage-views-of-mysql-mode/200.manage-materialized-views-of-mysql-mode/300.create-materialized-views-of-mysql-mode.md).

## Examples

1. Create a table named `test_tbl1`.

   ```sql
   CREATE TABLE test_tbl1 (col1 INT PRIMARY KEY, col2 VARCHAR(20), col3 INT, col4 INT);
   ```

2. Create a materialized view named `mv_test_tbl1`. Hash partition the materialized view by the `col1` column into 8 partitions. Refresh the materialized view using the complete refresh method, starting from the current date and refreshing every 1 day. Query the `test_tbl1` table for records where `col3 >= 30` and use these records as the base table for the materialized view.

   ```sql
   CREATE MATERIALIZED VIEW mv_test_tbl1
     PARTITION BY HASH(col1) PARTITIONS 8
     REFRESH COMPLETE START WITH sysdate() NEXT sysdate() + INTERVAL 1 DAY
     AS SELECT col1, col2, col3
       FROM test_tbl1
       WHERE col3 >= 30;
   ```

3. Create a materialized view named `mv2_test_tbl1` and specify the primary key.

   ```sql
   CREATE MATERIALIZED VIEW mv2_test_tbl1(c1, c2, c3, PRIMARY KEY(c1))
         AS SELECT col1, col2, col3
           FROM test_tbl1;
   ```

4. Create a columnar format materialized view named `mv3_test_tbl1`.

   ```sql
   CREATE MATERIALIZED VIEW mv3_test_tbl1
     WITH COLUMN GROUP(each column)
     AS SELECT col1, col2, col3
       FROM test_tbl1;
   ```

5. View the definition of the materialized view `mv3_test_tbl1`.

   ```sql
   SHOW CREATE VIEW mv3_test_tbl1;
   ```

## References

* [Overview of materialized views](../../../../300.database-object-management/100.manage-object-of-mysql-mode/600.manage-views-of-mysql-mode/200.manage-materialized-views-of-mysql-mode/100.materialized-views-overview-of-mysql-mode.md)

* [Create a materialized view](../../../../300.database-object-management/100.manage-object-of-mysql-mode/600.manage-views-of-mysql-mode/200.manage-materialized-views-of-mysql-mode/300.create-materialized-views-of-mysql-mode.md)

* [Query a materialized view](../../../../300.database-object-management/100.manage-object-of-mysql-mode/600.manage-views-of-mysql-mode/200.manage-materialized-views-of-mysql-mode/600.view-materialized-views-of-mysql-mode.md)

* [Drop a materialized view](../../../../300.database-object-management/100.manage-object-of-mysql-mode/600.manage-views-of-mysql-mode/200.manage-materialized-views-of-mysql-mode/700.delete-materialized-views-of-mysql-mode.md)

* [Refresh a materialized view](../../../../300.database-object-management/100.manage-object-of-mysql-mode/600.manage-views-of-mysql-mode/200.manage-materialized-views-of-mysql-mode/400.refresh-materialized-views-of-mysql-mode.md)