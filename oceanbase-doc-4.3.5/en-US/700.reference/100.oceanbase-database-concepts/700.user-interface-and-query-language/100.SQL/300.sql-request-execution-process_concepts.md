|description||
|---|---|
|keywords||
|dir-name||
|dir-name-en||
|tenant-type||

# Execution process of SQL queries

This topic describes the typical SQL query execution process after an SQL query is received by the SQL engine.

The process is illustrated in the following figure.

![sql-new](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/observer-enterprise/V4.2.1/EN_US/700.reference/100.oceanbase-database-concepts/%E5%86%85%E6%A0%B815.png)

  <main id="notice" type='explain'>
    <h4>Note</h4>
    <p>The process applies to DML and <code>SELECT</code> statements. Other statements, such as DCL statements, do not need to be processed by the optimizer. </p>
  </main>

The following table describes roles of the SQL engine modules in the SQL query execution process.

| **Module** | **Description** |
|-----------------------|--------|
| Fast parameterization module (Fast-parser) | Fast-parser parameterizes text strings based on lexical analysis to obtain parameterized text and constant parameters.  |
| Plan cache module           | The plan cache module stores the execution plan generated for a SQL statement in memory the first time it is executed. Subsequent executions can reuse this plan, avoiding repeated query optimization processes. |
| Lexical/syntactic parsing module (parser) | After receiving the SQL request string sent by the user, the parser splits the string into individual "tokens" and parses the entire request according to predefined grammar rules. This process converts the SQL request string into an in-memory data structure containing syntactic information, called a syntax tree. |
| Resolver (semantic parsing module) | Resolver converts the syntax tree generated by Parser into an internal data structure with database semantic information. During the conversion, Resolver translates tokens in the SQL query into the corresponding objects (such as libraries, tables, columns, and indexes) based on the database metadata to generate a statement tree.  |
| Query rewrite | After Resolver generates the statement tree, Transformer analyzes the semantics of the user SQL query and rewrites it into an equivalent query based on internal rules or cost models. Then, Transformer sends the equivalent query to Optimizer for optimization. In this process, Transformer performs an equivalent transformation on the original statement tree, and the result of the transformation is still a statement tree.  |
| Optimizer | As the core of the SQL tuning process, Optimizer generates the optimal execution plans for SQL queries. During the optimization, Optimizer needs to comprehensively consider various factors, such as SQL query semantics, object data characteristics, and the physical distribution of objects. It solves many problems such as access path selection, connection order selection, connection algorithm selection, and distributed plan generation. Finally, Optimizer selects the best execution plan for each SQL query.  |
| Code generator | Code Generator converts an execution plan to executable code without any optimization.  |
| Executor | Executor starts the execution of an SQL statement.  <ul><li> For local execution plans, Executor starts by calling the operator at the top of each execution plan. The operator logic completes the entire execution process and returns the execution result.    </li><li> For remote or distributed plans, Executor divides the execution tree of each plan into multiple schedulable sub-plans and sends these sub-plans to the relevant nodes for execution by using remote procedure calls (RPCs). </li></ul>
